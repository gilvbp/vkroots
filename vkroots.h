// The vkroots.h header is licensed under Apache-2.0 OR MIT
// as it was generated from the Vulkan Registry, which is licensed
// under the same license.

#pragma once

#include <vulkan/vk_layer.h>
#include <vulkan/vulkan.h>

#include <cstring>
#include <unordered_map>
#include <memory>
#include <mutex>
#include <type_traits>
#include <memory>
#include <cassert>
#include <vector>
#include <utility>
#include <optional>
#include <string_view>
#include <array>
#include <functional>

#define VKROOTS_VERSION_MAJOR 0
#define VKROOTS_VERSION_MINOR 1
#define VKROOTS_VERSION_PATCH 0

#define VKROOTS_VERSION VK_MAKE_API_VERSION(0, VKROOTS_VERSION_MAJOR, VKROOTS_VERSION_MINOR, VKROOTS_VERSION_PATCH)

namespace vkroots {

  // Consistency!
  using PFN_vkGetPhysicalDeviceProcAddr = PFN_GetPhysicalDeviceProcAddr;

  class VkInstanceDispatch;
  class VkPhysicalDeviceDispatch;
  class VkDeviceDispatch;

  class NoOverrides { static constexpr bool IsNoOverrides = true; };

  template <typename Type>
  constexpr VkStructureType ResolveSType();

  template <> constexpr VkStructureType ResolveSType<VkLayerInstanceCreateInfo>() { return VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkLayerInstanceCreateInfo>() { return VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<VkLayerDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkLayerDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO; }

  template <typename T>
  static constexpr bool TypeIsSinglePointer() {
    // If we aren't a pointer at all, return false
    // eg. int
    if (!std::is_pointer<T>::value)
      return false;

    // If we are still a pointer after removing pointer, return false.
    // eg. void**
    if (std::is_pointer<typename std::remove_pointer<T>::type>::value)
      return false;

    // Must be a single * ptr.
    return true;
  }

  template <typename Type, typename AnyStruct>
  const Type* FindInChain(const AnyStruct* obj) {
    static_assert(TypeIsSinglePointer<decltype(obj)>());

    for (const VkBaseInStructure* header = reinterpret_cast<const VkBaseInStructure*>(obj); header; header = header->pNext) {
      if (header->sType == ResolveSType<Type>())
        return reinterpret_cast<const Type*>(header);
    }
    return nullptr;
  }

  template <typename Type, typename AnyStruct>
  Type* FindInChainMutable(AnyStruct* obj) {
    static_assert(TypeIsSinglePointer<decltype(obj)>());

    for (VkBaseOutStructure* header = reinterpret_cast<VkBaseOutStructure*>(obj); header; header = header->pNext) {
      if (header->sType == ResolveSType<Type>())
        return reinterpret_cast<Type*>(header);
    }
    return nullptr;
  }

  template <typename Type, typename AnyStruct>
  std::tuple<Type *, VkBaseOutStructure *> RemoveFromChain(AnyStruct *obj) {
    static_assert(TypeIsSinglePointer<decltype(obj)>());

    for (VkBaseOutStructure* header = reinterpret_cast<VkBaseOutStructure*>(obj); header; header = header->pNext) {
      VkBaseOutStructure *pNextInChain = header->pNext;
      if (pNextInChain && pNextInChain->sType == ResolveSType<Type>()) {
        header->pNext = pNextInChain->pNext;
        return std::make_tuple(reinterpret_cast<Type*>(pNextInChain), header);
      }
    }
    return std::make_tuple(nullptr, nullptr);
  }

  template <typename Type, typename AnyStruct>
  Type *AddToChain(AnyStruct *pParent, Type *pType) {
    static_assert(TypeIsSinglePointer<decltype(pParent)>());
    static_assert(TypeIsSinglePointer<decltype(pType)>());

    void **ppParentNext = reinterpret_cast<void **>(&pParent->pNext);
    void **ppTypeNext   = reinterpret_cast<void **>(&pType->pNext);

    *ppTypeNext = std::exchange(*ppParentNext, reinterpret_cast<void *>(pType));
    return pType;
  }

  namespace tables {

    template <typename T>
    class RawPointer {
    public:
      RawPointer(T* value) : m_value(value) {}
            T* get()       { return m_value; }
      const T* get() const { return m_value; }
    private:
      T* m_value;
    };

    template <typename Object, typename DispatchType, typename DispatchPtr>
    class VkDispatchTableMap {
    public:
      const DispatchType* insert(Object obj, DispatchPtr ptr) {
        assert(obj);
        auto lock = std::unique_lock(m_mutex);
        const DispatchType* val = ptr.get();
        m_map.insert(std::make_pair(obj, std::move(ptr)));
        return val;
      }
      void remove(Object obj) {
        assert(obj);
        auto lock = std::unique_lock(m_mutex);
        m_map.erase(obj);
      }
      const DispatchType* find(Object obj) const {
        if (!obj) return nullptr;
        auto lock = std::unique_lock(m_mutex);
        auto iter = m_map.find(obj);
        if (iter == m_map.end())
          return nullptr;
        return iter->second.get();
      }
    private:
      std::unordered_map<Object, DispatchPtr> m_map;
      mutable std::mutex m_mutex;
    };

    // All our dispatchables...
    inline VkDispatchTableMap<VkInstance,       VkInstanceDispatch,       std::unique_ptr<const VkInstanceDispatch>>       InstanceDispatches;
    inline VkDispatchTableMap<VkInstance,       VkPhysicalDeviceDispatch, std::unique_ptr<const VkPhysicalDeviceDispatch>> PhysicalDeviceInstanceDispatches;
    inline VkDispatchTableMap<VkPhysicalDevice, VkPhysicalDeviceDispatch, RawPointer     <const VkPhysicalDeviceDispatch>> PhysicalDeviceDispatches;
    inline VkDispatchTableMap<VkDevice,         VkDeviceDispatch,         std::unique_ptr<const VkDeviceDispatch>>         DeviceDispatches;
    inline VkDispatchTableMap<VkQueue,          VkDeviceDispatch,         RawPointer     <const VkDeviceDispatch>>         QueueDispatches;
    inline VkDispatchTableMap<VkCommandBuffer,  VkDeviceDispatch,         RawPointer     <const VkDeviceDispatch>>         CommandBufferDispatches;
    inline VkDispatchTableMap<VkExternalComputeQueueNV, VkDeviceDispatch, RawPointer     <const VkDeviceDispatch>>         ExternalComputeQueueDispatches;

    static inline const VkInstanceDispatch*       LookupInstanceDispatch      (VkInstance instance)             { return InstanceDispatches.find(instance); }
    static inline const VkPhysicalDeviceDispatch* LookupPhysicalDeviceDispatch(VkInstance instance)             { return PhysicalDeviceInstanceDispatches.find(instance); }
    static inline const VkPhysicalDeviceDispatch* LookupPhysicalDeviceDispatch(VkPhysicalDevice physicalDevice) { return PhysicalDeviceDispatches.find(physicalDevice); }
    static inline const VkDeviceDispatch*         LookupDeviceDispatch        (VkDevice device)                 { return DeviceDispatches.find(device); }
    static inline const VkDeviceDispatch*         LookupDeviceDispatch        (VkQueue device)                  { return QueueDispatches.find(device); }
    static inline const VkDeviceDispatch*         LookupDeviceDispatch        (VkCommandBuffer cmdBuffer)       { return CommandBufferDispatches.find(cmdBuffer); }
    static inline const VkDeviceDispatch*         LookupDeviceDispatch        (VkExternalComputeQueueNV externalComputeQueueNV) { return ExternalComputeQueueDispatches.find(externalComputeQueueNV); }

    static inline void CreateDispatchTable(PFN_vkGetInstanceProcAddr nextInstanceProcAddr, PFN_GetPhysicalDeviceProcAddr nextPhysDevProcAddr, VkInstance instance);
    static inline void CreateDispatchTable(const VkDeviceCreateInfo* pCreateInfo, PFN_vkGetDeviceProcAddr nextProcAddr, VkPhysicalDevice physicalDevice, VkDevice device);
    static inline void DestroyDispatchTable(VkInstance instance);
    static inline void DestroyDispatchTable(VkDevice device);

    static inline void AssignDispatchTable(VkCommandBuffer cmdBuffer, const VkDeviceDispatch *pDispatch) { CommandBufferDispatches.insert(cmdBuffer, RawPointer(pDispatch)); }
    static inline void UnassignDispatchTable(VkCommandBuffer cmdBuffer) { CommandBufferDispatches.remove(cmdBuffer); }
  }

  struct VkInstanceProcAddrFuncs {
    PFN_vkGetInstanceProcAddr NextGetInstanceProcAddr;
    PFN_vkGetPhysicalDeviceProcAddr NextGetPhysicalDeviceProcAddr;
  };

  static inline VkResult GetProcAddrs(const VkInstanceCreateInfo* pInfo, VkInstanceProcAddrFuncs *pOutFuncs) {
    const void* pNext = (const void*) pInfo;
    const VkLayerInstanceCreateInfo* layerInfo;
    while ((layerInfo = FindInChain<const VkLayerInstanceCreateInfo>(pNext)) && layerInfo->function != VK_LAYER_LINK_INFO)
      pNext = layerInfo->pNext;
    assert(layerInfo);
    if (!layerInfo)
      return VK_ERROR_INITIALIZATION_FAILED;
    *pOutFuncs = VkInstanceProcAddrFuncs{ layerInfo->u.pLayerInfo->pfnNextGetInstanceProcAddr, layerInfo->u.pLayerInfo->pfnNextGetPhysicalDeviceProcAddr };
    // Josh:
    // It really sucks that we have to advance this ourselves given the const situation here... 
    VkLayerInstanceCreateInfo* layerInfoMutable = const_cast<VkLayerInstanceCreateInfo *>(layerInfo);
    layerInfoMutable->u.pLayerInfo = layerInfoMutable->u.pLayerInfo->pNext;
    return VK_SUCCESS;
  }

  static inline VkResult GetProcAddrs(const VkDeviceCreateInfo* pInfo, PFN_vkGetDeviceProcAddr *pOutAddr) {
    const void* pNext = (const void*) pInfo;
    const VkLayerDeviceCreateInfo* layerInfo;
    while ((layerInfo = FindInChain<const VkLayerDeviceCreateInfo>(pNext)) && layerInfo->function != VK_LAYER_LINK_INFO)
      pNext = layerInfo->pNext;
    assert(layerInfo);
    if (!layerInfo)
      return VK_ERROR_INITIALIZATION_FAILED;
    *pOutAddr = layerInfo->u.pLayerInfo->pfnNextGetDeviceProcAddr;
    // Josh:
    // It really sucks that we have to advance this ourselves given the const situation here... 
    VkLayerDeviceCreateInfo* layerInfoMutable = const_cast<VkLayerDeviceCreateInfo *>(layerInfo);
    layerInfoMutable->u.pLayerInfo = layerInfoMutable->u.pLayerInfo->pNext;
    return VK_SUCCESS;
  }

}
namespace vkroots {
  static VkResult implicit_wrap_CreateInstance(const VkInstanceCreateInfo* pCreateInfo, const VkAllocationCallbacks* pAllocator, VkInstance* pInstance);
  static VkResult implicit_wrap_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo*pCreateInfo, const VkAllocationCallbacks* pAllocator, VkDevice* pDevice);
  static void implicit_wrap_DestroyInstance(VkInstance instance, const VkAllocationCallbacks* pAllocator);
  static void implicit_wrap_DestroyDevice(VkDevice device, const VkAllocationCallbacks* pAllocator);
  static VkResult implicit_wrap_AllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers);
  static void implicit_wrap_FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers);
  class VkInstanceDispatch {
  public:
    VkInstanceDispatch(PFN_vkGetInstanceProcAddr NextGetInstanceProcAddr, VkInstance instance) {
      this->Instance = instance;
#ifdef VK_USE_PLATFORM_ANDROID_KHR
      this->CreateAndroidSurfaceKHR = (PFN_vkCreateAndroidSurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateAndroidSurfaceKHR");
#endif
      this->CreateDebugReportCallbackEXT = (PFN_vkCreateDebugReportCallbackEXT) NextGetInstanceProcAddr(instance, "vkCreateDebugReportCallbackEXT");
      this->CreateDebugUtilsMessengerEXT = (PFN_vkCreateDebugUtilsMessengerEXT) NextGetInstanceProcAddr(instance, "vkCreateDebugUtilsMessengerEXT");
      this->_RealCreateDevice = (PFN_vkCreateDevice) NextGetInstanceProcAddr(instance, "vkCreateDevice");
      this->CreateDevice = (PFN_vkCreateDevice) implicit_wrap_CreateDevice;
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
      this->CreateDirectFBSurfaceEXT = (PFN_vkCreateDirectFBSurfaceEXT) NextGetInstanceProcAddr(instance, "vkCreateDirectFBSurfaceEXT");
#endif
      this->CreateDisplayModeKHR = (PFN_vkCreateDisplayModeKHR) NextGetInstanceProcAddr(instance, "vkCreateDisplayModeKHR");
      this->CreateDisplayPlaneSurfaceKHR = (PFN_vkCreateDisplayPlaneSurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateDisplayPlaneSurfaceKHR");
      this->CreateHeadlessSurfaceEXT = (PFN_vkCreateHeadlessSurfaceEXT) NextGetInstanceProcAddr(instance, "vkCreateHeadlessSurfaceEXT");
#ifdef VK_USE_PLATFORM_IOS_MVK
      this->CreateIOSSurfaceMVK = (PFN_vkCreateIOSSurfaceMVK) NextGetInstanceProcAddr(instance, "vkCreateIOSSurfaceMVK");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->CreateImagePipeSurfaceFUCHSIA = (PFN_vkCreateImagePipeSurfaceFUCHSIA) NextGetInstanceProcAddr(instance, "vkCreateImagePipeSurfaceFUCHSIA");
#endif
      this->_RealCreateInstance = (PFN_vkCreateInstance) NextGetInstanceProcAddr(instance, "vkCreateInstance");
      this->CreateInstance = (PFN_vkCreateInstance) implicit_wrap_CreateInstance;
#ifdef VK_USE_PLATFORM_MACOS_MVK
      this->CreateMacOSSurfaceMVK = (PFN_vkCreateMacOSSurfaceMVK) NextGetInstanceProcAddr(instance, "vkCreateMacOSSurfaceMVK");
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
      this->CreateMetalSurfaceEXT = (PFN_vkCreateMetalSurfaceEXT) NextGetInstanceProcAddr(instance, "vkCreateMetalSurfaceEXT");
#endif
#ifdef VK_USE_PLATFORM_SCREEN_QNX
      this->CreateScreenSurfaceQNX = (PFN_vkCreateScreenSurfaceQNX) NextGetInstanceProcAddr(instance, "vkCreateScreenSurfaceQNX");
#endif
#ifdef VK_USE_PLATFORM_GGP
      this->CreateStreamDescriptorSurfaceGGP = (PFN_vkCreateStreamDescriptorSurfaceGGP) NextGetInstanceProcAddr(instance, "vkCreateStreamDescriptorSurfaceGGP");
#endif
#ifdef VK_USE_PLATFORM_OHOS
      this->CreateSurfaceOHOS = (PFN_vkCreateSurfaceOHOS) NextGetInstanceProcAddr(instance, "vkCreateSurfaceOHOS");
#endif
#ifdef VK_USE_PLATFORM_VI_NN
      this->CreateViSurfaceNN = (PFN_vkCreateViSurfaceNN) NextGetInstanceProcAddr(instance, "vkCreateViSurfaceNN");
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
      this->CreateWaylandSurfaceKHR = (PFN_vkCreateWaylandSurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateWaylandSurfaceKHR");
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->CreateWin32SurfaceKHR = (PFN_vkCreateWin32SurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateWin32SurfaceKHR");
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
      this->CreateXcbSurfaceKHR = (PFN_vkCreateXcbSurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateXcbSurfaceKHR");
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
      this->CreateXlibSurfaceKHR = (PFN_vkCreateXlibSurfaceKHR) NextGetInstanceProcAddr(instance, "vkCreateXlibSurfaceKHR");
#endif
      this->DebugReportMessageEXT = (PFN_vkDebugReportMessageEXT) NextGetInstanceProcAddr(instance, "vkDebugReportMessageEXT");
      this->DestroyDebugReportCallbackEXT = (PFN_vkDestroyDebugReportCallbackEXT) NextGetInstanceProcAddr(instance, "vkDestroyDebugReportCallbackEXT");
      this->DestroyDebugUtilsMessengerEXT = (PFN_vkDestroyDebugUtilsMessengerEXT) NextGetInstanceProcAddr(instance, "vkDestroyDebugUtilsMessengerEXT");
      this->_RealDestroyInstance = (PFN_vkDestroyInstance) NextGetInstanceProcAddr(instance, "vkDestroyInstance");
      this->DestroyInstance = (PFN_vkDestroyInstance) DestroyInstanceWrapper;
      this->DestroySurfaceKHR = (PFN_vkDestroySurfaceKHR) NextGetInstanceProcAddr(instance, "vkDestroySurfaceKHR");
      this->EnumerateDeviceExtensionProperties = (PFN_vkEnumerateDeviceExtensionProperties) NextGetInstanceProcAddr(instance, "vkEnumerateDeviceExtensionProperties");
      this->EnumerateDeviceLayerProperties = (PFN_vkEnumerateDeviceLayerProperties) NextGetInstanceProcAddr(instance, "vkEnumerateDeviceLayerProperties");
      this->EnumeratePhysicalDeviceGroups = (PFN_vkEnumeratePhysicalDeviceGroups) NextGetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceGroups");
      this->EnumeratePhysicalDeviceGroupsKHR = (PFN_vkEnumeratePhysicalDeviceGroupsKHR) NextGetInstanceProcAddr(instance, "vkEnumeratePhysicalDeviceGroupsKHR");
      this->EnumeratePhysicalDevices = (PFN_vkEnumeratePhysicalDevices) NextGetInstanceProcAddr(instance, "vkEnumeratePhysicalDevices");
      this->GetDisplayModePropertiesKHR = (PFN_vkGetDisplayModePropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetDisplayModePropertiesKHR");
      this->GetDisplayPlaneCapabilitiesKHR = (PFN_vkGetDisplayPlaneCapabilitiesKHR) NextGetInstanceProcAddr(instance, "vkGetDisplayPlaneCapabilitiesKHR");
      this->GetDisplayPlaneSupportedDisplaysKHR = (PFN_vkGetDisplayPlaneSupportedDisplaysKHR) NextGetInstanceProcAddr(instance, "vkGetDisplayPlaneSupportedDisplaysKHR");
      this->GetInstanceProcAddr = NextGetInstanceProcAddr;
      this->GetPhysicalDeviceDisplayPlanePropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlanePropertiesKHR");
      this->GetPhysicalDeviceDisplayPropertiesKHR = (PFN_vkGetPhysicalDeviceDisplayPropertiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceDisplayPropertiesKHR");
      this->GetPhysicalDeviceExternalBufferProperties = (PFN_vkGetPhysicalDeviceExternalBufferProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferProperties");
      this->GetPhysicalDeviceExternalFenceProperties = (PFN_vkGetPhysicalDeviceExternalFenceProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalFenceProperties");
      this->GetPhysicalDeviceExternalSemaphoreProperties = (PFN_vkGetPhysicalDeviceExternalSemaphoreProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphoreProperties");
      this->GetPhysicalDeviceFeatures = (PFN_vkGetPhysicalDeviceFeatures) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures");
      this->GetPhysicalDeviceFeatures2 = (PFN_vkGetPhysicalDeviceFeatures2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFeatures2");
      this->GetPhysicalDeviceFormatProperties = (PFN_vkGetPhysicalDeviceFormatProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties");
      this->GetPhysicalDeviceFormatProperties2 = (PFN_vkGetPhysicalDeviceFormatProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties2");
      this->GetPhysicalDeviceImageFormatProperties = (PFN_vkGetPhysicalDeviceImageFormatProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties");
      this->GetPhysicalDeviceImageFormatProperties2 = (PFN_vkGetPhysicalDeviceImageFormatProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties2");
      this->GetPhysicalDeviceMemoryProperties = (PFN_vkGetPhysicalDeviceMemoryProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties");
      this->GetPhysicalDeviceMemoryProperties2 = (PFN_vkGetPhysicalDeviceMemoryProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties2");
      this->GetPhysicalDevicePresentRectanglesKHR = (PFN_vkGetPhysicalDevicePresentRectanglesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDevicePresentRectanglesKHR");
      this->GetPhysicalDeviceProperties = (PFN_vkGetPhysicalDeviceProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties");
      this->GetPhysicalDeviceProperties2 = (PFN_vkGetPhysicalDeviceProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceProperties2");
      this->GetPhysicalDeviceQueueFamilyProperties = (PFN_vkGetPhysicalDeviceQueueFamilyProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties");
      this->GetPhysicalDeviceQueueFamilyProperties2 = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2");
      this->GetPhysicalDeviceSparseImageFormatProperties = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties");
      this->GetPhysicalDeviceSparseImageFormatProperties2 = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2");
      this->GetPhysicalDeviceSurfaceCapabilities2KHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2KHR");
      this->GetPhysicalDeviceSurfaceCapabilitiesKHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilitiesKHR");
      this->GetPhysicalDeviceSurfaceFormats2KHR = (PFN_vkGetPhysicalDeviceSurfaceFormats2KHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceFormats2KHR");
      this->GetPhysicalDeviceSurfaceFormatsKHR = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceFormatsKHR");
      this->GetPhysicalDeviceSurfacePresentModesKHR = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfacePresentModesKHR");
      this->GetPhysicalDeviceSurfaceSupportKHR = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceSurfaceSupportKHR");
      this->GetPhysicalDeviceToolProperties = (PFN_vkGetPhysicalDeviceToolProperties) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceToolProperties");
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
      this->GetPhysicalDeviceWaylandPresentationSupportKHR = (PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceWaylandPresentationSupportKHR");
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->GetPhysicalDeviceWin32PresentationSupportKHR = (PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceWin32PresentationSupportKHR");
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
      this->GetPhysicalDeviceXcbPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceXcbPresentationSupportKHR");
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
      this->GetPhysicalDeviceXlibPresentationSupportKHR = (PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR) NextGetInstanceProcAddr(instance, "vkGetPhysicalDeviceXlibPresentationSupportKHR");
#endif
      this->SubmitDebugUtilsMessageEXT = (PFN_vkSubmitDebugUtilsMessageEXT) NextGetInstanceProcAddr(instance, "vkSubmitDebugUtilsMessageEXT");
    }

    mutable uint64_t UserData = 0;
    VkInstance Instance;
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    PFN_vkCreateAndroidSurfaceKHR CreateAndroidSurfaceKHR;
#endif
    PFN_vkCreateDebugReportCallbackEXT CreateDebugReportCallbackEXT;
    PFN_vkCreateDebugUtilsMessengerEXT CreateDebugUtilsMessengerEXT;
    PFN_vkCreateDevice _RealCreateDevice;
    PFN_vkCreateDevice CreateDevice;
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    PFN_vkCreateDirectFBSurfaceEXT CreateDirectFBSurfaceEXT;
#endif
    PFN_vkCreateDisplayModeKHR CreateDisplayModeKHR;
    PFN_vkCreateDisplayPlaneSurfaceKHR CreateDisplayPlaneSurfaceKHR;
    PFN_vkCreateHeadlessSurfaceEXT CreateHeadlessSurfaceEXT;
#ifdef VK_USE_PLATFORM_IOS_MVK
    PFN_vkCreateIOSSurfaceMVK CreateIOSSurfaceMVK;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkCreateImagePipeSurfaceFUCHSIA CreateImagePipeSurfaceFUCHSIA;
#endif
    PFN_vkCreateInstance _RealCreateInstance;
    PFN_vkCreateInstance CreateInstance;
#ifdef VK_USE_PLATFORM_MACOS_MVK
    PFN_vkCreateMacOSSurfaceMVK CreateMacOSSurfaceMVK;
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    PFN_vkCreateMetalSurfaceEXT CreateMetalSurfaceEXT;
#endif
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    PFN_vkCreateScreenSurfaceQNX CreateScreenSurfaceQNX;
#endif
#ifdef VK_USE_PLATFORM_GGP
    PFN_vkCreateStreamDescriptorSurfaceGGP CreateStreamDescriptorSurfaceGGP;
#endif
#ifdef VK_USE_PLATFORM_OHOS
    PFN_vkCreateSurfaceOHOS CreateSurfaceOHOS;
#endif
#ifdef VK_USE_PLATFORM_VI_NN
    PFN_vkCreateViSurfaceNN CreateViSurfaceNN;
#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    PFN_vkCreateWaylandSurfaceKHR CreateWaylandSurfaceKHR;
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkCreateWin32SurfaceKHR CreateWin32SurfaceKHR;
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    PFN_vkCreateXcbSurfaceKHR CreateXcbSurfaceKHR;
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    PFN_vkCreateXlibSurfaceKHR CreateXlibSurfaceKHR;
#endif
    PFN_vkDebugReportMessageEXT DebugReportMessageEXT;
    PFN_vkDestroyDebugReportCallbackEXT DestroyDebugReportCallbackEXT;
    PFN_vkDestroyDebugUtilsMessengerEXT DestroyDebugUtilsMessengerEXT;
    PFN_vkDestroyInstance DestroyInstance;
    PFN_vkDestroySurfaceKHR DestroySurfaceKHR;
    PFN_vkEnumerateDeviceExtensionProperties EnumerateDeviceExtensionProperties;
    PFN_vkEnumerateDeviceLayerProperties EnumerateDeviceLayerProperties;
    PFN_vkEnumeratePhysicalDeviceGroups EnumeratePhysicalDeviceGroups;
    PFN_vkEnumeratePhysicalDeviceGroupsKHR EnumeratePhysicalDeviceGroupsKHR;
    PFN_vkEnumeratePhysicalDevices EnumeratePhysicalDevices;
    PFN_vkGetDisplayModePropertiesKHR GetDisplayModePropertiesKHR;
    PFN_vkGetDisplayPlaneCapabilitiesKHR GetDisplayPlaneCapabilitiesKHR;
    PFN_vkGetDisplayPlaneSupportedDisplaysKHR GetDisplayPlaneSupportedDisplaysKHR;
    PFN_vkGetInstanceProcAddr GetInstanceProcAddr;
    PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR GetPhysicalDeviceDisplayPlanePropertiesKHR;
    PFN_vkGetPhysicalDeviceDisplayPropertiesKHR GetPhysicalDeviceDisplayPropertiesKHR;
    PFN_vkGetPhysicalDeviceExternalBufferProperties GetPhysicalDeviceExternalBufferProperties;
    PFN_vkGetPhysicalDeviceExternalFenceProperties GetPhysicalDeviceExternalFenceProperties;
    PFN_vkGetPhysicalDeviceExternalSemaphoreProperties GetPhysicalDeviceExternalSemaphoreProperties;
    PFN_vkGetPhysicalDeviceFeatures GetPhysicalDeviceFeatures;
    PFN_vkGetPhysicalDeviceFeatures2 GetPhysicalDeviceFeatures2;
    PFN_vkGetPhysicalDeviceFormatProperties GetPhysicalDeviceFormatProperties;
    PFN_vkGetPhysicalDeviceFormatProperties2 GetPhysicalDeviceFormatProperties2;
    PFN_vkGetPhysicalDeviceImageFormatProperties GetPhysicalDeviceImageFormatProperties;
    PFN_vkGetPhysicalDeviceImageFormatProperties2 GetPhysicalDeviceImageFormatProperties2;
    PFN_vkGetPhysicalDeviceMemoryProperties GetPhysicalDeviceMemoryProperties;
    PFN_vkGetPhysicalDeviceMemoryProperties2 GetPhysicalDeviceMemoryProperties2;
    PFN_vkGetPhysicalDevicePresentRectanglesKHR GetPhysicalDevicePresentRectanglesKHR;
    PFN_vkGetPhysicalDeviceProperties GetPhysicalDeviceProperties;
    PFN_vkGetPhysicalDeviceProperties2 GetPhysicalDeviceProperties2;
    PFN_vkGetPhysicalDeviceQueueFamilyProperties GetPhysicalDeviceQueueFamilyProperties;
    PFN_vkGetPhysicalDeviceQueueFamilyProperties2 GetPhysicalDeviceQueueFamilyProperties2;
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties GetPhysicalDeviceSparseImageFormatProperties;
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2 GetPhysicalDeviceSparseImageFormatProperties2;
    PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR GetPhysicalDeviceSurfaceCapabilities2KHR;
    PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR GetPhysicalDeviceSurfaceCapabilitiesKHR;
    PFN_vkGetPhysicalDeviceSurfaceFormats2KHR GetPhysicalDeviceSurfaceFormats2KHR;
    PFN_vkGetPhysicalDeviceSurfaceFormatsKHR GetPhysicalDeviceSurfaceFormatsKHR;
    PFN_vkGetPhysicalDeviceSurfacePresentModesKHR GetPhysicalDeviceSurfacePresentModesKHR;
    PFN_vkGetPhysicalDeviceSurfaceSupportKHR GetPhysicalDeviceSurfaceSupportKHR;
    PFN_vkGetPhysicalDeviceToolProperties GetPhysicalDeviceToolProperties;
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    PFN_vkGetPhysicalDeviceWaylandPresentationSupportKHR GetPhysicalDeviceWaylandPresentationSupportKHR;
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetPhysicalDeviceWin32PresentationSupportKHR GetPhysicalDeviceWin32PresentationSupportKHR;
#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
    PFN_vkGetPhysicalDeviceXcbPresentationSupportKHR GetPhysicalDeviceXcbPresentationSupportKHR;
#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
    PFN_vkGetPhysicalDeviceXlibPresentationSupportKHR GetPhysicalDeviceXlibPresentationSupportKHR;
#endif
    PFN_vkSubmitDebugUtilsMessageEXT SubmitDebugUtilsMessageEXT;
  private:
    PFN_vkDestroyInstance _RealDestroyInstance;
    static void DestroyInstanceWrapper(VkInstance object, const VkAllocationCallbacks* pAllocator) {
      auto dispatch = vkroots::tables::LookupInstanceDispatch(object);
      auto destroyFunc = dispatch->_RealDestroyInstance;
      vkroots::tables::DestroyDispatchTable(object);
      destroyFunc(object, pAllocator);
    }
  };

  class VkPhysicalDeviceDispatch {
  public:
    VkPhysicalDeviceDispatch(PFN_vkGetPhysicalDeviceProcAddr NextGetPhysicalDeviceProcAddr, VkInstance instance, const VkInstanceDispatch* pInstanceDispatch) {
      this->Instance = instance;
      this->pInstanceDispatch = pInstanceDispatch;
      this->GetPhysicalDeviceProcAddr = NextGetPhysicalDeviceProcAddr;
      this->AcquireDrmDisplayEXT = (PFN_vkAcquireDrmDisplayEXT) NextGetPhysicalDeviceProcAddr(instance, "vkAcquireDrmDisplayEXT");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->AcquireWinrtDisplayNV = (PFN_vkAcquireWinrtDisplayNV) NextGetPhysicalDeviceProcAddr(instance, "vkAcquireWinrtDisplayNV");
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
      this->AcquireXlibDisplayEXT = (PFN_vkAcquireXlibDisplayEXT) NextGetPhysicalDeviceProcAddr(instance, "vkAcquireXlibDisplayEXT");
#endif
      this->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = (PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR) NextGetPhysicalDeviceProcAddr(instance, "vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR");
      this->GetDisplayModeProperties2KHR = (PFN_vkGetDisplayModeProperties2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetDisplayModeProperties2KHR");
      this->GetDisplayPlaneCapabilities2KHR = (PFN_vkGetDisplayPlaneCapabilities2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetDisplayPlaneCapabilities2KHR");
      this->GetDrmDisplayEXT = (PFN_vkGetDrmDisplayEXT) NextGetPhysicalDeviceProcAddr(instance, "vkGetDrmDisplayEXT");
      this->GetPhysicalDeviceCalibrateableTimeDomainsEXT = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsEXT");
      this->GetPhysicalDeviceCalibrateableTimeDomainsKHR = (PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceCalibrateableTimeDomainsKHR");
      this->GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = (PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV");
      this->GetPhysicalDeviceCooperativeMatrixPropertiesKHR = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR");
      this->GetPhysicalDeviceCooperativeMatrixPropertiesNV = (PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceCooperativeMatrixPropertiesNV");
      this->GetPhysicalDeviceCooperativeVectorPropertiesNV = (PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceCooperativeVectorPropertiesNV");
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
      this->GetPhysicalDeviceDirectFBPresentationSupportEXT = (PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT");
#endif
      this->GetPhysicalDeviceDisplayPlaneProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceDisplayPlaneProperties2KHR");
      this->GetPhysicalDeviceDisplayProperties2KHR = (PFN_vkGetPhysicalDeviceDisplayProperties2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceDisplayProperties2KHR");
      this->GetPhysicalDeviceExternalBufferPropertiesKHR = (PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceExternalBufferPropertiesKHR");
      this->GetPhysicalDeviceExternalFencePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceExternalFencePropertiesKHR");
      this->GetPhysicalDeviceExternalImageFormatPropertiesNV = (PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceExternalImageFormatPropertiesNV");
      this->GetPhysicalDeviceExternalSemaphorePropertiesKHR = (PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceExternalSemaphorePropertiesKHR");
      this->GetPhysicalDeviceExternalTensorPropertiesARM = (PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceExternalTensorPropertiesARM");
      this->GetPhysicalDeviceFeatures2KHR = (PFN_vkGetPhysicalDeviceFeatures2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceFeatures2KHR");
      this->GetPhysicalDeviceFormatProperties2KHR = (PFN_vkGetPhysicalDeviceFormatProperties2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceFormatProperties2KHR");
      this->GetPhysicalDeviceFragmentShadingRatesKHR = (PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceFragmentShadingRatesKHR");
      this->GetPhysicalDeviceImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceImageFormatProperties2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceImageFormatProperties2KHR");
      this->GetPhysicalDeviceMemoryProperties2KHR = (PFN_vkGetPhysicalDeviceMemoryProperties2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceMemoryProperties2KHR");
      this->GetPhysicalDeviceMultisamplePropertiesEXT = (PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceMultisamplePropertiesEXT");
      this->GetPhysicalDeviceOpticalFlowImageFormatsNV = (PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceOpticalFlowImageFormatsNV");
      this->GetPhysicalDeviceProperties2KHR = (PFN_vkGetPhysicalDeviceProperties2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceProperties2KHR");
      this->GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = (PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM");
      this->GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = (PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM");
      this->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = (PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR");
      this->GetPhysicalDeviceQueueFamilyProperties2KHR = (PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceQueueFamilyProperties2KHR");
#ifdef VK_USE_PLATFORM_SCREEN_QNX
      this->GetPhysicalDeviceScreenPresentationSupportQNX = (PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceScreenPresentationSupportQNX");
#endif
      this->GetPhysicalDeviceSparseImageFormatProperties2KHR = (PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceSparseImageFormatProperties2KHR");
      this->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = (PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV");
      this->GetPhysicalDeviceSurfaceCapabilities2EXT = (PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceSurfaceCapabilities2EXT");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->GetPhysicalDeviceSurfacePresentModes2EXT = (PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceSurfacePresentModes2EXT");
#endif
      this->GetPhysicalDeviceToolPropertiesEXT = (PFN_vkGetPhysicalDeviceToolPropertiesEXT) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceToolPropertiesEXT");
      this->GetPhysicalDeviceVideoCapabilitiesKHR = (PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceVideoCapabilitiesKHR");
      this->GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = (PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR");
      this->GetPhysicalDeviceVideoFormatPropertiesKHR = (PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR) NextGetPhysicalDeviceProcAddr(instance, "vkGetPhysicalDeviceVideoFormatPropertiesKHR");
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
      this->GetRandROutputDisplayEXT = (PFN_vkGetRandROutputDisplayEXT) NextGetPhysicalDeviceProcAddr(instance, "vkGetRandROutputDisplayEXT");
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->GetWinrtDisplayNV = (PFN_vkGetWinrtDisplayNV) NextGetPhysicalDeviceProcAddr(instance, "vkGetWinrtDisplayNV");
#endif
      this->ReleaseDisplayEXT = (PFN_vkReleaseDisplayEXT) NextGetPhysicalDeviceProcAddr(instance, "vkReleaseDisplayEXT");
    }

    mutable uint64_t UserData = 0;
    VkInstance Instance;
    const VkInstanceDispatch* pInstanceDispatch;
    PFN_GetPhysicalDeviceProcAddr GetPhysicalDeviceProcAddr;
    PFN_vkAcquireDrmDisplayEXT AcquireDrmDisplayEXT;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkAcquireWinrtDisplayNV AcquireWinrtDisplayNV;
#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    PFN_vkAcquireXlibDisplayEXT AcquireXlibDisplayEXT;
#endif
    PFN_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR;
    PFN_vkGetDisplayModeProperties2KHR GetDisplayModeProperties2KHR;
    PFN_vkGetDisplayPlaneCapabilities2KHR GetDisplayPlaneCapabilities2KHR;
    PFN_vkGetDrmDisplayEXT GetDrmDisplayEXT;
    PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT GetPhysicalDeviceCalibrateableTimeDomainsEXT;
    PFN_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR GetPhysicalDeviceCalibrateableTimeDomainsKHR;
    PFN_vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV;
    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR GetPhysicalDeviceCooperativeMatrixPropertiesKHR;
    PFN_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV GetPhysicalDeviceCooperativeMatrixPropertiesNV;
    PFN_vkGetPhysicalDeviceCooperativeVectorPropertiesNV GetPhysicalDeviceCooperativeVectorPropertiesNV;
#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    PFN_vkGetPhysicalDeviceDirectFBPresentationSupportEXT GetPhysicalDeviceDirectFBPresentationSupportEXT;
#endif
    PFN_vkGetPhysicalDeviceDisplayPlaneProperties2KHR GetPhysicalDeviceDisplayPlaneProperties2KHR;
    PFN_vkGetPhysicalDeviceDisplayProperties2KHR GetPhysicalDeviceDisplayProperties2KHR;
    PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR GetPhysicalDeviceExternalBufferPropertiesKHR;
    PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR GetPhysicalDeviceExternalFencePropertiesKHR;
    PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV GetPhysicalDeviceExternalImageFormatPropertiesNV;
    PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR GetPhysicalDeviceExternalSemaphorePropertiesKHR;
    PFN_vkGetPhysicalDeviceExternalTensorPropertiesARM GetPhysicalDeviceExternalTensorPropertiesARM;
    PFN_vkGetPhysicalDeviceFeatures2KHR GetPhysicalDeviceFeatures2KHR;
    PFN_vkGetPhysicalDeviceFormatProperties2KHR GetPhysicalDeviceFormatProperties2KHR;
    PFN_vkGetPhysicalDeviceFragmentShadingRatesKHR GetPhysicalDeviceFragmentShadingRatesKHR;
    PFN_vkGetPhysicalDeviceImageFormatProperties2KHR GetPhysicalDeviceImageFormatProperties2KHR;
    PFN_vkGetPhysicalDeviceMemoryProperties2KHR GetPhysicalDeviceMemoryProperties2KHR;
    PFN_vkGetPhysicalDeviceMultisamplePropertiesEXT GetPhysicalDeviceMultisamplePropertiesEXT;
    PFN_vkGetPhysicalDeviceOpticalFlowImageFormatsNV GetPhysicalDeviceOpticalFlowImageFormatsNV;
    PFN_vkGetPhysicalDeviceProperties2KHR GetPhysicalDeviceProperties2KHR;
    PFN_vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM;
    PFN_vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM;
    PFN_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR;
    PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR GetPhysicalDeviceQueueFamilyProperties2KHR;
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    PFN_vkGetPhysicalDeviceScreenPresentationSupportQNX GetPhysicalDeviceScreenPresentationSupportQNX;
#endif
    PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR GetPhysicalDeviceSparseImageFormatProperties2KHR;
    PFN_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV;
    PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT GetPhysicalDeviceSurfaceCapabilities2EXT;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetPhysicalDeviceSurfacePresentModes2EXT GetPhysicalDeviceSurfacePresentModes2EXT;
#endif
    PFN_vkGetPhysicalDeviceToolPropertiesEXT GetPhysicalDeviceToolPropertiesEXT;
    PFN_vkGetPhysicalDeviceVideoCapabilitiesKHR GetPhysicalDeviceVideoCapabilitiesKHR;
    PFN_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR;
    PFN_vkGetPhysicalDeviceVideoFormatPropertiesKHR GetPhysicalDeviceVideoFormatPropertiesKHR;
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    PFN_vkGetRandROutputDisplayEXT GetRandROutputDisplayEXT;
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetWinrtDisplayNV GetWinrtDisplayNV;
#endif
    PFN_vkReleaseDisplayEXT ReleaseDisplayEXT;
  private:
  };

  namespace tables {
    static inline const VkInstanceDispatch* LookupInstanceDispatch(VkPhysicalDevice physicalDevice) { return PhysicalDeviceDispatches.find(physicalDevice)->pInstanceDispatch; }
  }
  class VkDeviceDispatch {
  public:
    VkDeviceDispatch(PFN_vkGetDeviceProcAddr NextGetDeviceProcAddr, VkDevice device, VkPhysicalDevice PhysicalDevice, const VkPhysicalDeviceDispatch* pPhysicalDeviceDispatch, const VkDeviceCreateInfo* pCreateInfo) {
      this->PhysicalDevice = PhysicalDevice;
      this->Device = device;
      this->pPhysicalDeviceDispatch = pPhysicalDeviceDispatch;
      for (uint32_t i = 0; i < pCreateInfo->queueCreateInfoCount; i++) {
        VkDeviceQueueCreateInfo queueInfo = pCreateInfo->pQueueCreateInfos[i];
        queueInfo.pNext = nullptr;
        DeviceQueueInfos.push_back(queueInfo);
      }
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->AcquireFullScreenExclusiveModeEXT = (PFN_vkAcquireFullScreenExclusiveModeEXT) NextGetDeviceProcAddr(device, "vkAcquireFullScreenExclusiveModeEXT");
#endif
      this->AcquireNextImage2KHR = (PFN_vkAcquireNextImage2KHR) NextGetDeviceProcAddr(device, "vkAcquireNextImage2KHR");
      this->AcquireNextImageKHR = (PFN_vkAcquireNextImageKHR) NextGetDeviceProcAddr(device, "vkAcquireNextImageKHR");
      this->AcquirePerformanceConfigurationINTEL = (PFN_vkAcquirePerformanceConfigurationINTEL) NextGetDeviceProcAddr(device, "vkAcquirePerformanceConfigurationINTEL");
      this->AcquireProfilingLockKHR = (PFN_vkAcquireProfilingLockKHR) NextGetDeviceProcAddr(device, "vkAcquireProfilingLockKHR");
      this->_RealAllocateCommandBuffers = (PFN_vkAllocateCommandBuffers) NextGetDeviceProcAddr(device, "vkAllocateCommandBuffers");
      this->AllocateCommandBuffers = (PFN_vkAllocateCommandBuffers) implicit_wrap_AllocateCommandBuffers;
      this->AllocateDescriptorSets = (PFN_vkAllocateDescriptorSets) NextGetDeviceProcAddr(device, "vkAllocateDescriptorSets");
      this->AllocateMemory = (PFN_vkAllocateMemory) NextGetDeviceProcAddr(device, "vkAllocateMemory");
      this->AntiLagUpdateAMD = (PFN_vkAntiLagUpdateAMD) NextGetDeviceProcAddr(device, "vkAntiLagUpdateAMD");
      this->BeginCommandBuffer = (PFN_vkBeginCommandBuffer) NextGetDeviceProcAddr(device, "vkBeginCommandBuffer");
      this->BindAccelerationStructureMemoryNV = (PFN_vkBindAccelerationStructureMemoryNV) NextGetDeviceProcAddr(device, "vkBindAccelerationStructureMemoryNV");
      this->BindBufferMemory = (PFN_vkBindBufferMemory) NextGetDeviceProcAddr(device, "vkBindBufferMemory");
      this->BindBufferMemory2 = (PFN_vkBindBufferMemory2) NextGetDeviceProcAddr(device, "vkBindBufferMemory2");
      this->BindBufferMemory2KHR = (PFN_vkBindBufferMemory2KHR) NextGetDeviceProcAddr(device, "vkBindBufferMemory2KHR");
      this->BindDataGraphPipelineSessionMemoryARM = (PFN_vkBindDataGraphPipelineSessionMemoryARM) NextGetDeviceProcAddr(device, "vkBindDataGraphPipelineSessionMemoryARM");
      this->BindImageMemory = (PFN_vkBindImageMemory) NextGetDeviceProcAddr(device, "vkBindImageMemory");
      this->BindImageMemory2 = (PFN_vkBindImageMemory2) NextGetDeviceProcAddr(device, "vkBindImageMemory2");
      this->BindImageMemory2KHR = (PFN_vkBindImageMemory2KHR) NextGetDeviceProcAddr(device, "vkBindImageMemory2KHR");
      this->BindOpticalFlowSessionImageNV = (PFN_vkBindOpticalFlowSessionImageNV) NextGetDeviceProcAddr(device, "vkBindOpticalFlowSessionImageNV");
      this->BindTensorMemoryARM = (PFN_vkBindTensorMemoryARM) NextGetDeviceProcAddr(device, "vkBindTensorMemoryARM");
      this->BindVideoSessionMemoryKHR = (PFN_vkBindVideoSessionMemoryKHR) NextGetDeviceProcAddr(device, "vkBindVideoSessionMemoryKHR");
      this->BuildAccelerationStructuresKHR = (PFN_vkBuildAccelerationStructuresKHR) NextGetDeviceProcAddr(device, "vkBuildAccelerationStructuresKHR");
      this->BuildMicromapsEXT = (PFN_vkBuildMicromapsEXT) NextGetDeviceProcAddr(device, "vkBuildMicromapsEXT");
      this->CmdBeginConditionalRenderingEXT = (PFN_vkCmdBeginConditionalRenderingEXT) NextGetDeviceProcAddr(device, "vkCmdBeginConditionalRenderingEXT");
      this->CmdBeginDebugUtilsLabelEXT = (PFN_vkCmdBeginDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkCmdBeginDebugUtilsLabelEXT");
      this->CmdBeginPerTileExecutionQCOM = (PFN_vkCmdBeginPerTileExecutionQCOM) NextGetDeviceProcAddr(device, "vkCmdBeginPerTileExecutionQCOM");
      this->CmdBeginQuery = (PFN_vkCmdBeginQuery) NextGetDeviceProcAddr(device, "vkCmdBeginQuery");
      this->CmdBeginQueryIndexedEXT = (PFN_vkCmdBeginQueryIndexedEXT) NextGetDeviceProcAddr(device, "vkCmdBeginQueryIndexedEXT");
      this->CmdBeginRenderPass = (PFN_vkCmdBeginRenderPass) NextGetDeviceProcAddr(device, "vkCmdBeginRenderPass");
      this->CmdBeginRenderPass2 = (PFN_vkCmdBeginRenderPass2) NextGetDeviceProcAddr(device, "vkCmdBeginRenderPass2");
      this->CmdBeginRenderPass2KHR = (PFN_vkCmdBeginRenderPass2KHR) NextGetDeviceProcAddr(device, "vkCmdBeginRenderPass2KHR");
      this->CmdBeginRendering = (PFN_vkCmdBeginRendering) NextGetDeviceProcAddr(device, "vkCmdBeginRendering");
      this->CmdBeginRenderingKHR = (PFN_vkCmdBeginRenderingKHR) NextGetDeviceProcAddr(device, "vkCmdBeginRenderingKHR");
      this->CmdBeginTransformFeedbackEXT = (PFN_vkCmdBeginTransformFeedbackEXT) NextGetDeviceProcAddr(device, "vkCmdBeginTransformFeedbackEXT");
      this->CmdBeginVideoCodingKHR = (PFN_vkCmdBeginVideoCodingKHR) NextGetDeviceProcAddr(device, "vkCmdBeginVideoCodingKHR");
      this->CmdBindDescriptorBufferEmbeddedSamplers2EXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT) NextGetDeviceProcAddr(device, "vkCmdBindDescriptorBufferEmbeddedSamplers2EXT");
      this->CmdBindDescriptorBufferEmbeddedSamplersEXT = (PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT) NextGetDeviceProcAddr(device, "vkCmdBindDescriptorBufferEmbeddedSamplersEXT");
      this->CmdBindDescriptorBuffersEXT = (PFN_vkCmdBindDescriptorBuffersEXT) NextGetDeviceProcAddr(device, "vkCmdBindDescriptorBuffersEXT");
      this->CmdBindDescriptorSets = (PFN_vkCmdBindDescriptorSets) NextGetDeviceProcAddr(device, "vkCmdBindDescriptorSets");
      this->CmdBindDescriptorSets2KHR = (PFN_vkCmdBindDescriptorSets2KHR) NextGetDeviceProcAddr(device, "vkCmdBindDescriptorSets2KHR");
      this->CmdBindIndexBuffer = (PFN_vkCmdBindIndexBuffer) NextGetDeviceProcAddr(device, "vkCmdBindIndexBuffer");
      this->CmdBindIndexBuffer2KHR = (PFN_vkCmdBindIndexBuffer2KHR) NextGetDeviceProcAddr(device, "vkCmdBindIndexBuffer2KHR");
      this->CmdBindInvocationMaskHUAWEI = (PFN_vkCmdBindInvocationMaskHUAWEI) NextGetDeviceProcAddr(device, "vkCmdBindInvocationMaskHUAWEI");
      this->CmdBindPipeline = (PFN_vkCmdBindPipeline) NextGetDeviceProcAddr(device, "vkCmdBindPipeline");
      this->CmdBindPipelineShaderGroupNV = (PFN_vkCmdBindPipelineShaderGroupNV) NextGetDeviceProcAddr(device, "vkCmdBindPipelineShaderGroupNV");
      this->CmdBindShadersEXT = (PFN_vkCmdBindShadersEXT) NextGetDeviceProcAddr(device, "vkCmdBindShadersEXT");
      this->CmdBindShadingRateImageNV = (PFN_vkCmdBindShadingRateImageNV) NextGetDeviceProcAddr(device, "vkCmdBindShadingRateImageNV");
      this->CmdBindTileMemoryQCOM = (PFN_vkCmdBindTileMemoryQCOM) NextGetDeviceProcAddr(device, "vkCmdBindTileMemoryQCOM");
      this->CmdBindTransformFeedbackBuffersEXT = (PFN_vkCmdBindTransformFeedbackBuffersEXT) NextGetDeviceProcAddr(device, "vkCmdBindTransformFeedbackBuffersEXT");
      this->CmdBindVertexBuffers = (PFN_vkCmdBindVertexBuffers) NextGetDeviceProcAddr(device, "vkCmdBindVertexBuffers");
      this->CmdBindVertexBuffers2 = (PFN_vkCmdBindVertexBuffers2) NextGetDeviceProcAddr(device, "vkCmdBindVertexBuffers2");
      this->CmdBindVertexBuffers2EXT = (PFN_vkCmdBindVertexBuffers2EXT) NextGetDeviceProcAddr(device, "vkCmdBindVertexBuffers2EXT");
      this->CmdBlitImage = (PFN_vkCmdBlitImage) NextGetDeviceProcAddr(device, "vkCmdBlitImage");
      this->CmdBlitImage2 = (PFN_vkCmdBlitImage2) NextGetDeviceProcAddr(device, "vkCmdBlitImage2");
      this->CmdBlitImage2KHR = (PFN_vkCmdBlitImage2KHR) NextGetDeviceProcAddr(device, "vkCmdBlitImage2KHR");
      this->CmdBuildAccelerationStructureNV = (PFN_vkCmdBuildAccelerationStructureNV) NextGetDeviceProcAddr(device, "vkCmdBuildAccelerationStructureNV");
      this->CmdBuildAccelerationStructuresIndirectKHR = (PFN_vkCmdBuildAccelerationStructuresIndirectKHR) NextGetDeviceProcAddr(device, "vkCmdBuildAccelerationStructuresIndirectKHR");
      this->CmdBuildAccelerationStructuresKHR = (PFN_vkCmdBuildAccelerationStructuresKHR) NextGetDeviceProcAddr(device, "vkCmdBuildAccelerationStructuresKHR");
      this->CmdBuildClusterAccelerationStructureIndirectNV = (PFN_vkCmdBuildClusterAccelerationStructureIndirectNV) NextGetDeviceProcAddr(device, "vkCmdBuildClusterAccelerationStructureIndirectNV");
      this->CmdBuildMicromapsEXT = (PFN_vkCmdBuildMicromapsEXT) NextGetDeviceProcAddr(device, "vkCmdBuildMicromapsEXT");
      this->CmdBuildPartitionedAccelerationStructuresNV = (PFN_vkCmdBuildPartitionedAccelerationStructuresNV) NextGetDeviceProcAddr(device, "vkCmdBuildPartitionedAccelerationStructuresNV");
      this->CmdClearAttachments = (PFN_vkCmdClearAttachments) NextGetDeviceProcAddr(device, "vkCmdClearAttachments");
      this->CmdClearColorImage = (PFN_vkCmdClearColorImage) NextGetDeviceProcAddr(device, "vkCmdClearColorImage");
      this->CmdClearDepthStencilImage = (PFN_vkCmdClearDepthStencilImage) NextGetDeviceProcAddr(device, "vkCmdClearDepthStencilImage");
      this->CmdControlVideoCodingKHR = (PFN_vkCmdControlVideoCodingKHR) NextGetDeviceProcAddr(device, "vkCmdControlVideoCodingKHR");
      this->CmdConvertCooperativeVectorMatrixNV = (PFN_vkCmdConvertCooperativeVectorMatrixNV) NextGetDeviceProcAddr(device, "vkCmdConvertCooperativeVectorMatrixNV");
      this->CmdCopyAccelerationStructureKHR = (PFN_vkCmdCopyAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureKHR");
      this->CmdCopyAccelerationStructureNV = (PFN_vkCmdCopyAccelerationStructureNV) NextGetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureNV");
      this->CmdCopyAccelerationStructureToMemoryKHR = (PFN_vkCmdCopyAccelerationStructureToMemoryKHR) NextGetDeviceProcAddr(device, "vkCmdCopyAccelerationStructureToMemoryKHR");
      this->CmdCopyBuffer = (PFN_vkCmdCopyBuffer) NextGetDeviceProcAddr(device, "vkCmdCopyBuffer");
      this->CmdCopyBuffer2 = (PFN_vkCmdCopyBuffer2) NextGetDeviceProcAddr(device, "vkCmdCopyBuffer2");
      this->CmdCopyBuffer2KHR = (PFN_vkCmdCopyBuffer2KHR) NextGetDeviceProcAddr(device, "vkCmdCopyBuffer2KHR");
      this->CmdCopyBufferToImage = (PFN_vkCmdCopyBufferToImage) NextGetDeviceProcAddr(device, "vkCmdCopyBufferToImage");
      this->CmdCopyBufferToImage2 = (PFN_vkCmdCopyBufferToImage2) NextGetDeviceProcAddr(device, "vkCmdCopyBufferToImage2");
      this->CmdCopyBufferToImage2KHR = (PFN_vkCmdCopyBufferToImage2KHR) NextGetDeviceProcAddr(device, "vkCmdCopyBufferToImage2KHR");
      this->CmdCopyImage = (PFN_vkCmdCopyImage) NextGetDeviceProcAddr(device, "vkCmdCopyImage");
      this->CmdCopyImage2 = (PFN_vkCmdCopyImage2) NextGetDeviceProcAddr(device, "vkCmdCopyImage2");
      this->CmdCopyImage2KHR = (PFN_vkCmdCopyImage2KHR) NextGetDeviceProcAddr(device, "vkCmdCopyImage2KHR");
      this->CmdCopyImageToBuffer = (PFN_vkCmdCopyImageToBuffer) NextGetDeviceProcAddr(device, "vkCmdCopyImageToBuffer");
      this->CmdCopyImageToBuffer2 = (PFN_vkCmdCopyImageToBuffer2) NextGetDeviceProcAddr(device, "vkCmdCopyImageToBuffer2");
      this->CmdCopyImageToBuffer2KHR = (PFN_vkCmdCopyImageToBuffer2KHR) NextGetDeviceProcAddr(device, "vkCmdCopyImageToBuffer2KHR");
      this->CmdCopyMemoryIndirectNV = (PFN_vkCmdCopyMemoryIndirectNV) NextGetDeviceProcAddr(device, "vkCmdCopyMemoryIndirectNV");
      this->CmdCopyMemoryToAccelerationStructureKHR = (PFN_vkCmdCopyMemoryToAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkCmdCopyMemoryToAccelerationStructureKHR");
      this->CmdCopyMemoryToImageIndirectNV = (PFN_vkCmdCopyMemoryToImageIndirectNV) NextGetDeviceProcAddr(device, "vkCmdCopyMemoryToImageIndirectNV");
      this->CmdCopyMemoryToMicromapEXT = (PFN_vkCmdCopyMemoryToMicromapEXT) NextGetDeviceProcAddr(device, "vkCmdCopyMemoryToMicromapEXT");
      this->CmdCopyMicromapEXT = (PFN_vkCmdCopyMicromapEXT) NextGetDeviceProcAddr(device, "vkCmdCopyMicromapEXT");
      this->CmdCopyMicromapToMemoryEXT = (PFN_vkCmdCopyMicromapToMemoryEXT) NextGetDeviceProcAddr(device, "vkCmdCopyMicromapToMemoryEXT");
      this->CmdCopyQueryPoolResults = (PFN_vkCmdCopyQueryPoolResults) NextGetDeviceProcAddr(device, "vkCmdCopyQueryPoolResults");
      this->CmdCopyTensorARM = (PFN_vkCmdCopyTensorARM) NextGetDeviceProcAddr(device, "vkCmdCopyTensorARM");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->CmdCudaLaunchKernelNV = (PFN_vkCmdCudaLaunchKernelNV) NextGetDeviceProcAddr(device, "vkCmdCudaLaunchKernelNV");
#endif
      this->CmdDebugMarkerBeginEXT = (PFN_vkCmdDebugMarkerBeginEXT) NextGetDeviceProcAddr(device, "vkCmdDebugMarkerBeginEXT");
      this->CmdDebugMarkerEndEXT = (PFN_vkCmdDebugMarkerEndEXT) NextGetDeviceProcAddr(device, "vkCmdDebugMarkerEndEXT");
      this->CmdDebugMarkerInsertEXT = (PFN_vkCmdDebugMarkerInsertEXT) NextGetDeviceProcAddr(device, "vkCmdDebugMarkerInsertEXT");
      this->CmdDecodeVideoKHR = (PFN_vkCmdDecodeVideoKHR) NextGetDeviceProcAddr(device, "vkCmdDecodeVideoKHR");
      this->CmdDecompressMemoryIndirectCountNV = (PFN_vkCmdDecompressMemoryIndirectCountNV) NextGetDeviceProcAddr(device, "vkCmdDecompressMemoryIndirectCountNV");
      this->CmdDecompressMemoryNV = (PFN_vkCmdDecompressMemoryNV) NextGetDeviceProcAddr(device, "vkCmdDecompressMemoryNV");
      this->CmdDispatch = (PFN_vkCmdDispatch) NextGetDeviceProcAddr(device, "vkCmdDispatch");
      this->CmdDispatchBase = (PFN_vkCmdDispatchBase) NextGetDeviceProcAddr(device, "vkCmdDispatchBase");
      this->CmdDispatchBaseKHR = (PFN_vkCmdDispatchBaseKHR) NextGetDeviceProcAddr(device, "vkCmdDispatchBaseKHR");
      this->CmdDispatchDataGraphARM = (PFN_vkCmdDispatchDataGraphARM) NextGetDeviceProcAddr(device, "vkCmdDispatchDataGraphARM");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->CmdDispatchGraphAMDX = (PFN_vkCmdDispatchGraphAMDX) NextGetDeviceProcAddr(device, "vkCmdDispatchGraphAMDX");
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->CmdDispatchGraphIndirectAMDX = (PFN_vkCmdDispatchGraphIndirectAMDX) NextGetDeviceProcAddr(device, "vkCmdDispatchGraphIndirectAMDX");
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->CmdDispatchGraphIndirectCountAMDX = (PFN_vkCmdDispatchGraphIndirectCountAMDX) NextGetDeviceProcAddr(device, "vkCmdDispatchGraphIndirectCountAMDX");
#endif
      this->CmdDispatchIndirect = (PFN_vkCmdDispatchIndirect) NextGetDeviceProcAddr(device, "vkCmdDispatchIndirect");
      this->CmdDispatchTileQCOM = (PFN_vkCmdDispatchTileQCOM) NextGetDeviceProcAddr(device, "vkCmdDispatchTileQCOM");
      this->CmdDraw = (PFN_vkCmdDraw) NextGetDeviceProcAddr(device, "vkCmdDraw");
      this->CmdDrawClusterHUAWEI = (PFN_vkCmdDrawClusterHUAWEI) NextGetDeviceProcAddr(device, "vkCmdDrawClusterHUAWEI");
      this->CmdDrawClusterIndirectHUAWEI = (PFN_vkCmdDrawClusterIndirectHUAWEI) NextGetDeviceProcAddr(device, "vkCmdDrawClusterIndirectHUAWEI");
      this->CmdDrawIndexed = (PFN_vkCmdDrawIndexed) NextGetDeviceProcAddr(device, "vkCmdDrawIndexed");
      this->CmdDrawIndexedIndirect = (PFN_vkCmdDrawIndexedIndirect) NextGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirect");
      this->CmdDrawIndexedIndirectCount = (PFN_vkCmdDrawIndexedIndirectCount) NextGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCount");
      this->CmdDrawIndexedIndirectCountAMD = (PFN_vkCmdDrawIndexedIndirectCountAMD) NextGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCountAMD");
      this->CmdDrawIndexedIndirectCountKHR = (PFN_vkCmdDrawIndexedIndirectCountKHR) NextGetDeviceProcAddr(device, "vkCmdDrawIndexedIndirectCountKHR");
      this->CmdDrawIndirect = (PFN_vkCmdDrawIndirect) NextGetDeviceProcAddr(device, "vkCmdDrawIndirect");
      this->CmdDrawIndirectByteCountEXT = (PFN_vkCmdDrawIndirectByteCountEXT) NextGetDeviceProcAddr(device, "vkCmdDrawIndirectByteCountEXT");
      this->CmdDrawIndirectCount = (PFN_vkCmdDrawIndirectCount) NextGetDeviceProcAddr(device, "vkCmdDrawIndirectCount");
      this->CmdDrawIndirectCountAMD = (PFN_vkCmdDrawIndirectCountAMD) NextGetDeviceProcAddr(device, "vkCmdDrawIndirectCountAMD");
      this->CmdDrawIndirectCountKHR = (PFN_vkCmdDrawIndirectCountKHR) NextGetDeviceProcAddr(device, "vkCmdDrawIndirectCountKHR");
      this->CmdDrawMeshTasksEXT = (PFN_vkCmdDrawMeshTasksEXT) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksEXT");
      this->CmdDrawMeshTasksIndirectCountEXT = (PFN_vkCmdDrawMeshTasksIndirectCountEXT) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectCountEXT");
      this->CmdDrawMeshTasksIndirectCountNV = (PFN_vkCmdDrawMeshTasksIndirectCountNV) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectCountNV");
      this->CmdDrawMeshTasksIndirectEXT = (PFN_vkCmdDrawMeshTasksIndirectEXT) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectEXT");
      this->CmdDrawMeshTasksIndirectNV = (PFN_vkCmdDrawMeshTasksIndirectNV) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksIndirectNV");
      this->CmdDrawMeshTasksNV = (PFN_vkCmdDrawMeshTasksNV) NextGetDeviceProcAddr(device, "vkCmdDrawMeshTasksNV");
      this->CmdDrawMultiEXT = (PFN_vkCmdDrawMultiEXT) NextGetDeviceProcAddr(device, "vkCmdDrawMultiEXT");
      this->CmdDrawMultiIndexedEXT = (PFN_vkCmdDrawMultiIndexedEXT) NextGetDeviceProcAddr(device, "vkCmdDrawMultiIndexedEXT");
      this->CmdEncodeVideoKHR = (PFN_vkCmdEncodeVideoKHR) NextGetDeviceProcAddr(device, "vkCmdEncodeVideoKHR");
      this->CmdEndConditionalRenderingEXT = (PFN_vkCmdEndConditionalRenderingEXT) NextGetDeviceProcAddr(device, "vkCmdEndConditionalRenderingEXT");
      this->CmdEndDebugUtilsLabelEXT = (PFN_vkCmdEndDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkCmdEndDebugUtilsLabelEXT");
      this->CmdEndPerTileExecutionQCOM = (PFN_vkCmdEndPerTileExecutionQCOM) NextGetDeviceProcAddr(device, "vkCmdEndPerTileExecutionQCOM");
      this->CmdEndQuery = (PFN_vkCmdEndQuery) NextGetDeviceProcAddr(device, "vkCmdEndQuery");
      this->CmdEndQueryIndexedEXT = (PFN_vkCmdEndQueryIndexedEXT) NextGetDeviceProcAddr(device, "vkCmdEndQueryIndexedEXT");
      this->CmdEndRenderPass = (PFN_vkCmdEndRenderPass) NextGetDeviceProcAddr(device, "vkCmdEndRenderPass");
      this->CmdEndRenderPass2 = (PFN_vkCmdEndRenderPass2) NextGetDeviceProcAddr(device, "vkCmdEndRenderPass2");
      this->CmdEndRenderPass2KHR = (PFN_vkCmdEndRenderPass2KHR) NextGetDeviceProcAddr(device, "vkCmdEndRenderPass2KHR");
      this->CmdEndRendering = (PFN_vkCmdEndRendering) NextGetDeviceProcAddr(device, "vkCmdEndRendering");
      this->CmdEndRendering2EXT = (PFN_vkCmdEndRendering2EXT) NextGetDeviceProcAddr(device, "vkCmdEndRendering2EXT");
      this->CmdEndRenderingKHR = (PFN_vkCmdEndRenderingKHR) NextGetDeviceProcAddr(device, "vkCmdEndRenderingKHR");
      this->CmdEndTransformFeedbackEXT = (PFN_vkCmdEndTransformFeedbackEXT) NextGetDeviceProcAddr(device, "vkCmdEndTransformFeedbackEXT");
      this->CmdEndVideoCodingKHR = (PFN_vkCmdEndVideoCodingKHR) NextGetDeviceProcAddr(device, "vkCmdEndVideoCodingKHR");
      this->CmdExecuteCommands = (PFN_vkCmdExecuteCommands) NextGetDeviceProcAddr(device, "vkCmdExecuteCommands");
      this->CmdExecuteGeneratedCommandsEXT = (PFN_vkCmdExecuteGeneratedCommandsEXT) NextGetDeviceProcAddr(device, "vkCmdExecuteGeneratedCommandsEXT");
      this->CmdExecuteGeneratedCommandsNV = (PFN_vkCmdExecuteGeneratedCommandsNV) NextGetDeviceProcAddr(device, "vkCmdExecuteGeneratedCommandsNV");
      this->CmdFillBuffer = (PFN_vkCmdFillBuffer) NextGetDeviceProcAddr(device, "vkCmdFillBuffer");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->CmdInitializeGraphScratchMemoryAMDX = (PFN_vkCmdInitializeGraphScratchMemoryAMDX) NextGetDeviceProcAddr(device, "vkCmdInitializeGraphScratchMemoryAMDX");
#endif
      this->CmdInsertDebugUtilsLabelEXT = (PFN_vkCmdInsertDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkCmdInsertDebugUtilsLabelEXT");
      this->CmdNextSubpass = (PFN_vkCmdNextSubpass) NextGetDeviceProcAddr(device, "vkCmdNextSubpass");
      this->CmdNextSubpass2 = (PFN_vkCmdNextSubpass2) NextGetDeviceProcAddr(device, "vkCmdNextSubpass2");
      this->CmdNextSubpass2KHR = (PFN_vkCmdNextSubpass2KHR) NextGetDeviceProcAddr(device, "vkCmdNextSubpass2KHR");
      this->CmdOpticalFlowExecuteNV = (PFN_vkCmdOpticalFlowExecuteNV) NextGetDeviceProcAddr(device, "vkCmdOpticalFlowExecuteNV");
      this->CmdPipelineBarrier = (PFN_vkCmdPipelineBarrier) NextGetDeviceProcAddr(device, "vkCmdPipelineBarrier");
      this->CmdPipelineBarrier2 = (PFN_vkCmdPipelineBarrier2) NextGetDeviceProcAddr(device, "vkCmdPipelineBarrier2");
      this->CmdPipelineBarrier2KHR = (PFN_vkCmdPipelineBarrier2KHR) NextGetDeviceProcAddr(device, "vkCmdPipelineBarrier2KHR");
      this->CmdPreprocessGeneratedCommandsEXT = (PFN_vkCmdPreprocessGeneratedCommandsEXT) NextGetDeviceProcAddr(device, "vkCmdPreprocessGeneratedCommandsEXT");
      this->CmdPreprocessGeneratedCommandsNV = (PFN_vkCmdPreprocessGeneratedCommandsNV) NextGetDeviceProcAddr(device, "vkCmdPreprocessGeneratedCommandsNV");
      this->CmdPushConstants = (PFN_vkCmdPushConstants) NextGetDeviceProcAddr(device, "vkCmdPushConstants");
      this->CmdPushConstants2KHR = (PFN_vkCmdPushConstants2KHR) NextGetDeviceProcAddr(device, "vkCmdPushConstants2KHR");
      this->CmdPushDescriptorSet2KHR = (PFN_vkCmdPushDescriptorSet2KHR) NextGetDeviceProcAddr(device, "vkCmdPushDescriptorSet2KHR");
      this->CmdPushDescriptorSetKHR = (PFN_vkCmdPushDescriptorSetKHR) NextGetDeviceProcAddr(device, "vkCmdPushDescriptorSetKHR");
      this->CmdPushDescriptorSetWithTemplate2KHR = (PFN_vkCmdPushDescriptorSetWithTemplate2KHR) NextGetDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplate2KHR");
      this->CmdPushDescriptorSetWithTemplateKHR = (PFN_vkCmdPushDescriptorSetWithTemplateKHR) NextGetDeviceProcAddr(device, "vkCmdPushDescriptorSetWithTemplateKHR");
      this->CmdResetEvent = (PFN_vkCmdResetEvent) NextGetDeviceProcAddr(device, "vkCmdResetEvent");
      this->CmdResetEvent2 = (PFN_vkCmdResetEvent2) NextGetDeviceProcAddr(device, "vkCmdResetEvent2");
      this->CmdResetEvent2KHR = (PFN_vkCmdResetEvent2KHR) NextGetDeviceProcAddr(device, "vkCmdResetEvent2KHR");
      this->CmdResetQueryPool = (PFN_vkCmdResetQueryPool) NextGetDeviceProcAddr(device, "vkCmdResetQueryPool");
      this->CmdResolveImage = (PFN_vkCmdResolveImage) NextGetDeviceProcAddr(device, "vkCmdResolveImage");
      this->CmdResolveImage2 = (PFN_vkCmdResolveImage2) NextGetDeviceProcAddr(device, "vkCmdResolveImage2");
      this->CmdResolveImage2KHR = (PFN_vkCmdResolveImage2KHR) NextGetDeviceProcAddr(device, "vkCmdResolveImage2KHR");
      this->CmdSetAlphaToCoverageEnableEXT = (PFN_vkCmdSetAlphaToCoverageEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetAlphaToCoverageEnableEXT");
      this->CmdSetAlphaToOneEnableEXT = (PFN_vkCmdSetAlphaToOneEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetAlphaToOneEnableEXT");
      this->CmdSetAttachmentFeedbackLoopEnableEXT = (PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetAttachmentFeedbackLoopEnableEXT");
      this->CmdSetBlendConstants = (PFN_vkCmdSetBlendConstants) NextGetDeviceProcAddr(device, "vkCmdSetBlendConstants");
      this->CmdSetCheckpointNV = (PFN_vkCmdSetCheckpointNV) NextGetDeviceProcAddr(device, "vkCmdSetCheckpointNV");
      this->CmdSetCoarseSampleOrderNV = (PFN_vkCmdSetCoarseSampleOrderNV) NextGetDeviceProcAddr(device, "vkCmdSetCoarseSampleOrderNV");
      this->CmdSetColorBlendAdvancedEXT = (PFN_vkCmdSetColorBlendAdvancedEXT) NextGetDeviceProcAddr(device, "vkCmdSetColorBlendAdvancedEXT");
      this->CmdSetColorBlendEnableEXT = (PFN_vkCmdSetColorBlendEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetColorBlendEnableEXT");
      this->CmdSetColorBlendEquationEXT = (PFN_vkCmdSetColorBlendEquationEXT) NextGetDeviceProcAddr(device, "vkCmdSetColorBlendEquationEXT");
      this->CmdSetColorWriteEnableEXT = (PFN_vkCmdSetColorWriteEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetColorWriteEnableEXT");
      this->CmdSetColorWriteMaskEXT = (PFN_vkCmdSetColorWriteMaskEXT) NextGetDeviceProcAddr(device, "vkCmdSetColorWriteMaskEXT");
      this->CmdSetConservativeRasterizationModeEXT = (PFN_vkCmdSetConservativeRasterizationModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetConservativeRasterizationModeEXT");
      this->CmdSetCoverageModulationModeNV = (PFN_vkCmdSetCoverageModulationModeNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageModulationModeNV");
      this->CmdSetCoverageModulationTableEnableNV = (PFN_vkCmdSetCoverageModulationTableEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageModulationTableEnableNV");
      this->CmdSetCoverageModulationTableNV = (PFN_vkCmdSetCoverageModulationTableNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageModulationTableNV");
      this->CmdSetCoverageReductionModeNV = (PFN_vkCmdSetCoverageReductionModeNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageReductionModeNV");
      this->CmdSetCoverageToColorEnableNV = (PFN_vkCmdSetCoverageToColorEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageToColorEnableNV");
      this->CmdSetCoverageToColorLocationNV = (PFN_vkCmdSetCoverageToColorLocationNV) NextGetDeviceProcAddr(device, "vkCmdSetCoverageToColorLocationNV");
      this->CmdSetCullMode = (PFN_vkCmdSetCullMode) NextGetDeviceProcAddr(device, "vkCmdSetCullMode");
      this->CmdSetCullModeEXT = (PFN_vkCmdSetCullModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetCullModeEXT");
      this->CmdSetDepthBias = (PFN_vkCmdSetDepthBias) NextGetDeviceProcAddr(device, "vkCmdSetDepthBias");
      this->CmdSetDepthBias2EXT = (PFN_vkCmdSetDepthBias2EXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthBias2EXT");
      this->CmdSetDepthBiasEnable = (PFN_vkCmdSetDepthBiasEnable) NextGetDeviceProcAddr(device, "vkCmdSetDepthBiasEnable");
      this->CmdSetDepthBiasEnableEXT = (PFN_vkCmdSetDepthBiasEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthBiasEnableEXT");
      this->CmdSetDepthBounds = (PFN_vkCmdSetDepthBounds) NextGetDeviceProcAddr(device, "vkCmdSetDepthBounds");
      this->CmdSetDepthBoundsTestEnable = (PFN_vkCmdSetDepthBoundsTestEnable) NextGetDeviceProcAddr(device, "vkCmdSetDepthBoundsTestEnable");
      this->CmdSetDepthBoundsTestEnableEXT = (PFN_vkCmdSetDepthBoundsTestEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthBoundsTestEnableEXT");
      this->CmdSetDepthClampEnableEXT = (PFN_vkCmdSetDepthClampEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthClampEnableEXT");
      this->CmdSetDepthClampRangeEXT = (PFN_vkCmdSetDepthClampRangeEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthClampRangeEXT");
      this->CmdSetDepthClipEnableEXT = (PFN_vkCmdSetDepthClipEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthClipEnableEXT");
      this->CmdSetDepthClipNegativeOneToOneEXT = (PFN_vkCmdSetDepthClipNegativeOneToOneEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthClipNegativeOneToOneEXT");
      this->CmdSetDepthCompareOp = (PFN_vkCmdSetDepthCompareOp) NextGetDeviceProcAddr(device, "vkCmdSetDepthCompareOp");
      this->CmdSetDepthCompareOpEXT = (PFN_vkCmdSetDepthCompareOpEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthCompareOpEXT");
      this->CmdSetDepthTestEnable = (PFN_vkCmdSetDepthTestEnable) NextGetDeviceProcAddr(device, "vkCmdSetDepthTestEnable");
      this->CmdSetDepthTestEnableEXT = (PFN_vkCmdSetDepthTestEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthTestEnableEXT");
      this->CmdSetDepthWriteEnable = (PFN_vkCmdSetDepthWriteEnable) NextGetDeviceProcAddr(device, "vkCmdSetDepthWriteEnable");
      this->CmdSetDepthWriteEnableEXT = (PFN_vkCmdSetDepthWriteEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDepthWriteEnableEXT");
      this->CmdSetDescriptorBufferOffsets2EXT = (PFN_vkCmdSetDescriptorBufferOffsets2EXT) NextGetDeviceProcAddr(device, "vkCmdSetDescriptorBufferOffsets2EXT");
      this->CmdSetDescriptorBufferOffsetsEXT = (PFN_vkCmdSetDescriptorBufferOffsetsEXT) NextGetDeviceProcAddr(device, "vkCmdSetDescriptorBufferOffsetsEXT");
      this->CmdSetDeviceMask = (PFN_vkCmdSetDeviceMask) NextGetDeviceProcAddr(device, "vkCmdSetDeviceMask");
      this->CmdSetDeviceMaskKHR = (PFN_vkCmdSetDeviceMaskKHR) NextGetDeviceProcAddr(device, "vkCmdSetDeviceMaskKHR");
      this->CmdSetDiscardRectangleEXT = (PFN_vkCmdSetDiscardRectangleEXT) NextGetDeviceProcAddr(device, "vkCmdSetDiscardRectangleEXT");
      this->CmdSetDiscardRectangleEnableEXT = (PFN_vkCmdSetDiscardRectangleEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetDiscardRectangleEnableEXT");
      this->CmdSetDiscardRectangleModeEXT = (PFN_vkCmdSetDiscardRectangleModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetDiscardRectangleModeEXT");
      this->CmdSetEvent = (PFN_vkCmdSetEvent) NextGetDeviceProcAddr(device, "vkCmdSetEvent");
      this->CmdSetEvent2 = (PFN_vkCmdSetEvent2) NextGetDeviceProcAddr(device, "vkCmdSetEvent2");
      this->CmdSetEvent2KHR = (PFN_vkCmdSetEvent2KHR) NextGetDeviceProcAddr(device, "vkCmdSetEvent2KHR");
      this->CmdSetExclusiveScissorEnableNV = (PFN_vkCmdSetExclusiveScissorEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetExclusiveScissorEnableNV");
      this->CmdSetExclusiveScissorNV = (PFN_vkCmdSetExclusiveScissorNV) NextGetDeviceProcAddr(device, "vkCmdSetExclusiveScissorNV");
      this->CmdSetExtraPrimitiveOverestimationSizeEXT = (PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT) NextGetDeviceProcAddr(device, "vkCmdSetExtraPrimitiveOverestimationSizeEXT");
      this->CmdSetFragmentShadingRateEnumNV = (PFN_vkCmdSetFragmentShadingRateEnumNV) NextGetDeviceProcAddr(device, "vkCmdSetFragmentShadingRateEnumNV");
      this->CmdSetFragmentShadingRateKHR = (PFN_vkCmdSetFragmentShadingRateKHR) NextGetDeviceProcAddr(device, "vkCmdSetFragmentShadingRateKHR");
      this->CmdSetFrontFace = (PFN_vkCmdSetFrontFace) NextGetDeviceProcAddr(device, "vkCmdSetFrontFace");
      this->CmdSetFrontFaceEXT = (PFN_vkCmdSetFrontFaceEXT) NextGetDeviceProcAddr(device, "vkCmdSetFrontFaceEXT");
      this->CmdSetLineRasterizationModeEXT = (PFN_vkCmdSetLineRasterizationModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetLineRasterizationModeEXT");
      this->CmdSetLineStippleEXT = (PFN_vkCmdSetLineStippleEXT) NextGetDeviceProcAddr(device, "vkCmdSetLineStippleEXT");
      this->CmdSetLineStippleEnableEXT = (PFN_vkCmdSetLineStippleEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetLineStippleEnableEXT");
      this->CmdSetLineStippleKHR = (PFN_vkCmdSetLineStippleKHR) NextGetDeviceProcAddr(device, "vkCmdSetLineStippleKHR");
      this->CmdSetLineWidth = (PFN_vkCmdSetLineWidth) NextGetDeviceProcAddr(device, "vkCmdSetLineWidth");
      this->CmdSetLogicOpEXT = (PFN_vkCmdSetLogicOpEXT) NextGetDeviceProcAddr(device, "vkCmdSetLogicOpEXT");
      this->CmdSetLogicOpEnableEXT = (PFN_vkCmdSetLogicOpEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetLogicOpEnableEXT");
      this->CmdSetPatchControlPointsEXT = (PFN_vkCmdSetPatchControlPointsEXT) NextGetDeviceProcAddr(device, "vkCmdSetPatchControlPointsEXT");
      this->CmdSetPerformanceMarkerINTEL = (PFN_vkCmdSetPerformanceMarkerINTEL) NextGetDeviceProcAddr(device, "vkCmdSetPerformanceMarkerINTEL");
      this->CmdSetPerformanceOverrideINTEL = (PFN_vkCmdSetPerformanceOverrideINTEL) NextGetDeviceProcAddr(device, "vkCmdSetPerformanceOverrideINTEL");
      this->CmdSetPerformanceStreamMarkerINTEL = (PFN_vkCmdSetPerformanceStreamMarkerINTEL) NextGetDeviceProcAddr(device, "vkCmdSetPerformanceStreamMarkerINTEL");
      this->CmdSetPolygonModeEXT = (PFN_vkCmdSetPolygonModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetPolygonModeEXT");
      this->CmdSetPrimitiveRestartEnable = (PFN_vkCmdSetPrimitiveRestartEnable) NextGetDeviceProcAddr(device, "vkCmdSetPrimitiveRestartEnable");
      this->CmdSetPrimitiveRestartEnableEXT = (PFN_vkCmdSetPrimitiveRestartEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetPrimitiveRestartEnableEXT");
      this->CmdSetPrimitiveTopology = (PFN_vkCmdSetPrimitiveTopology) NextGetDeviceProcAddr(device, "vkCmdSetPrimitiveTopology");
      this->CmdSetPrimitiveTopologyEXT = (PFN_vkCmdSetPrimitiveTopologyEXT) NextGetDeviceProcAddr(device, "vkCmdSetPrimitiveTopologyEXT");
      this->CmdSetProvokingVertexModeEXT = (PFN_vkCmdSetProvokingVertexModeEXT) NextGetDeviceProcAddr(device, "vkCmdSetProvokingVertexModeEXT");
      this->CmdSetRasterizationSamplesEXT = (PFN_vkCmdSetRasterizationSamplesEXT) NextGetDeviceProcAddr(device, "vkCmdSetRasterizationSamplesEXT");
      this->CmdSetRasterizationStreamEXT = (PFN_vkCmdSetRasterizationStreamEXT) NextGetDeviceProcAddr(device, "vkCmdSetRasterizationStreamEXT");
      this->CmdSetRasterizerDiscardEnable = (PFN_vkCmdSetRasterizerDiscardEnable) NextGetDeviceProcAddr(device, "vkCmdSetRasterizerDiscardEnable");
      this->CmdSetRasterizerDiscardEnableEXT = (PFN_vkCmdSetRasterizerDiscardEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetRasterizerDiscardEnableEXT");
      this->CmdSetRayTracingPipelineStackSizeKHR = (PFN_vkCmdSetRayTracingPipelineStackSizeKHR) NextGetDeviceProcAddr(device, "vkCmdSetRayTracingPipelineStackSizeKHR");
      this->CmdSetRenderingAttachmentLocationsKHR = (PFN_vkCmdSetRenderingAttachmentLocationsKHR) NextGetDeviceProcAddr(device, "vkCmdSetRenderingAttachmentLocationsKHR");
      this->CmdSetRenderingInputAttachmentIndicesKHR = (PFN_vkCmdSetRenderingInputAttachmentIndicesKHR) NextGetDeviceProcAddr(device, "vkCmdSetRenderingInputAttachmentIndicesKHR");
      this->CmdSetRepresentativeFragmentTestEnableNV = (PFN_vkCmdSetRepresentativeFragmentTestEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetRepresentativeFragmentTestEnableNV");
      this->CmdSetSampleLocationsEXT = (PFN_vkCmdSetSampleLocationsEXT) NextGetDeviceProcAddr(device, "vkCmdSetSampleLocationsEXT");
      this->CmdSetSampleLocationsEnableEXT = (PFN_vkCmdSetSampleLocationsEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetSampleLocationsEnableEXT");
      this->CmdSetSampleMaskEXT = (PFN_vkCmdSetSampleMaskEXT) NextGetDeviceProcAddr(device, "vkCmdSetSampleMaskEXT");
      this->CmdSetScissor = (PFN_vkCmdSetScissor) NextGetDeviceProcAddr(device, "vkCmdSetScissor");
      this->CmdSetScissorWithCount = (PFN_vkCmdSetScissorWithCount) NextGetDeviceProcAddr(device, "vkCmdSetScissorWithCount");
      this->CmdSetScissorWithCountEXT = (PFN_vkCmdSetScissorWithCountEXT) NextGetDeviceProcAddr(device, "vkCmdSetScissorWithCountEXT");
      this->CmdSetShadingRateImageEnableNV = (PFN_vkCmdSetShadingRateImageEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetShadingRateImageEnableNV");
      this->CmdSetStencilCompareMask = (PFN_vkCmdSetStencilCompareMask) NextGetDeviceProcAddr(device, "vkCmdSetStencilCompareMask");
      this->CmdSetStencilOp = (PFN_vkCmdSetStencilOp) NextGetDeviceProcAddr(device, "vkCmdSetStencilOp");
      this->CmdSetStencilOpEXT = (PFN_vkCmdSetStencilOpEXT) NextGetDeviceProcAddr(device, "vkCmdSetStencilOpEXT");
      this->CmdSetStencilReference = (PFN_vkCmdSetStencilReference) NextGetDeviceProcAddr(device, "vkCmdSetStencilReference");
      this->CmdSetStencilTestEnable = (PFN_vkCmdSetStencilTestEnable) NextGetDeviceProcAddr(device, "vkCmdSetStencilTestEnable");
      this->CmdSetStencilTestEnableEXT = (PFN_vkCmdSetStencilTestEnableEXT) NextGetDeviceProcAddr(device, "vkCmdSetStencilTestEnableEXT");
      this->CmdSetStencilWriteMask = (PFN_vkCmdSetStencilWriteMask) NextGetDeviceProcAddr(device, "vkCmdSetStencilWriteMask");
      this->CmdSetTessellationDomainOriginEXT = (PFN_vkCmdSetTessellationDomainOriginEXT) NextGetDeviceProcAddr(device, "vkCmdSetTessellationDomainOriginEXT");
      this->CmdSetVertexInputEXT = (PFN_vkCmdSetVertexInputEXT) NextGetDeviceProcAddr(device, "vkCmdSetVertexInputEXT");
      this->CmdSetViewport = (PFN_vkCmdSetViewport) NextGetDeviceProcAddr(device, "vkCmdSetViewport");
      this->CmdSetViewportShadingRatePaletteNV = (PFN_vkCmdSetViewportShadingRatePaletteNV) NextGetDeviceProcAddr(device, "vkCmdSetViewportShadingRatePaletteNV");
      this->CmdSetViewportSwizzleNV = (PFN_vkCmdSetViewportSwizzleNV) NextGetDeviceProcAddr(device, "vkCmdSetViewportSwizzleNV");
      this->CmdSetViewportWScalingEnableNV = (PFN_vkCmdSetViewportWScalingEnableNV) NextGetDeviceProcAddr(device, "vkCmdSetViewportWScalingEnableNV");
      this->CmdSetViewportWScalingNV = (PFN_vkCmdSetViewportWScalingNV) NextGetDeviceProcAddr(device, "vkCmdSetViewportWScalingNV");
      this->CmdSetViewportWithCount = (PFN_vkCmdSetViewportWithCount) NextGetDeviceProcAddr(device, "vkCmdSetViewportWithCount");
      this->CmdSetViewportWithCountEXT = (PFN_vkCmdSetViewportWithCountEXT) NextGetDeviceProcAddr(device, "vkCmdSetViewportWithCountEXT");
      this->CmdSubpassShadingHUAWEI = (PFN_vkCmdSubpassShadingHUAWEI) NextGetDeviceProcAddr(device, "vkCmdSubpassShadingHUAWEI");
      this->CmdTraceRaysIndirect2KHR = (PFN_vkCmdTraceRaysIndirect2KHR) NextGetDeviceProcAddr(device, "vkCmdTraceRaysIndirect2KHR");
      this->CmdTraceRaysIndirectKHR = (PFN_vkCmdTraceRaysIndirectKHR) NextGetDeviceProcAddr(device, "vkCmdTraceRaysIndirectKHR");
      this->CmdTraceRaysKHR = (PFN_vkCmdTraceRaysKHR) NextGetDeviceProcAddr(device, "vkCmdTraceRaysKHR");
      this->CmdTraceRaysNV = (PFN_vkCmdTraceRaysNV) NextGetDeviceProcAddr(device, "vkCmdTraceRaysNV");
      this->CmdUpdateBuffer = (PFN_vkCmdUpdateBuffer) NextGetDeviceProcAddr(device, "vkCmdUpdateBuffer");
      this->CmdUpdatePipelineIndirectBufferNV = (PFN_vkCmdUpdatePipelineIndirectBufferNV) NextGetDeviceProcAddr(device, "vkCmdUpdatePipelineIndirectBufferNV");
      this->CmdWaitEvents = (PFN_vkCmdWaitEvents) NextGetDeviceProcAddr(device, "vkCmdWaitEvents");
      this->CmdWaitEvents2 = (PFN_vkCmdWaitEvents2) NextGetDeviceProcAddr(device, "vkCmdWaitEvents2");
      this->CmdWaitEvents2KHR = (PFN_vkCmdWaitEvents2KHR) NextGetDeviceProcAddr(device, "vkCmdWaitEvents2KHR");
      this->CmdWriteAccelerationStructuresPropertiesKHR = (PFN_vkCmdWriteAccelerationStructuresPropertiesKHR) NextGetDeviceProcAddr(device, "vkCmdWriteAccelerationStructuresPropertiesKHR");
      this->CmdWriteAccelerationStructuresPropertiesNV = (PFN_vkCmdWriteAccelerationStructuresPropertiesNV) NextGetDeviceProcAddr(device, "vkCmdWriteAccelerationStructuresPropertiesNV");
      this->CmdWriteBufferMarker2AMD = (PFN_vkCmdWriteBufferMarker2AMD) NextGetDeviceProcAddr(device, "vkCmdWriteBufferMarker2AMD");
      this->CmdWriteBufferMarkerAMD = (PFN_vkCmdWriteBufferMarkerAMD) NextGetDeviceProcAddr(device, "vkCmdWriteBufferMarkerAMD");
      this->CmdWriteMicromapsPropertiesEXT = (PFN_vkCmdWriteMicromapsPropertiesEXT) NextGetDeviceProcAddr(device, "vkCmdWriteMicromapsPropertiesEXT");
      this->CmdWriteTimestamp = (PFN_vkCmdWriteTimestamp) NextGetDeviceProcAddr(device, "vkCmdWriteTimestamp");
      this->CmdWriteTimestamp2 = (PFN_vkCmdWriteTimestamp2) NextGetDeviceProcAddr(device, "vkCmdWriteTimestamp2");
      this->CmdWriteTimestamp2KHR = (PFN_vkCmdWriteTimestamp2KHR) NextGetDeviceProcAddr(device, "vkCmdWriteTimestamp2KHR");
      this->CompileDeferredNV = (PFN_vkCompileDeferredNV) NextGetDeviceProcAddr(device, "vkCompileDeferredNV");
      this->ConvertCooperativeVectorMatrixNV = (PFN_vkConvertCooperativeVectorMatrixNV) NextGetDeviceProcAddr(device, "vkConvertCooperativeVectorMatrixNV");
      this->CopyAccelerationStructureKHR = (PFN_vkCopyAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkCopyAccelerationStructureKHR");
      this->CopyAccelerationStructureToMemoryKHR = (PFN_vkCopyAccelerationStructureToMemoryKHR) NextGetDeviceProcAddr(device, "vkCopyAccelerationStructureToMemoryKHR");
      this->CopyImageToImageEXT = (PFN_vkCopyImageToImageEXT) NextGetDeviceProcAddr(device, "vkCopyImageToImageEXT");
      this->CopyImageToMemoryEXT = (PFN_vkCopyImageToMemoryEXT) NextGetDeviceProcAddr(device, "vkCopyImageToMemoryEXT");
      this->CopyMemoryToAccelerationStructureKHR = (PFN_vkCopyMemoryToAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkCopyMemoryToAccelerationStructureKHR");
      this->CopyMemoryToImageEXT = (PFN_vkCopyMemoryToImageEXT) NextGetDeviceProcAddr(device, "vkCopyMemoryToImageEXT");
      this->CopyMemoryToMicromapEXT = (PFN_vkCopyMemoryToMicromapEXT) NextGetDeviceProcAddr(device, "vkCopyMemoryToMicromapEXT");
      this->CopyMicromapEXT = (PFN_vkCopyMicromapEXT) NextGetDeviceProcAddr(device, "vkCopyMicromapEXT");
      this->CopyMicromapToMemoryEXT = (PFN_vkCopyMicromapToMemoryEXT) NextGetDeviceProcAddr(device, "vkCopyMicromapToMemoryEXT");
      this->CreateAccelerationStructureKHR = (PFN_vkCreateAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkCreateAccelerationStructureKHR");
      this->CreateAccelerationStructureNV = (PFN_vkCreateAccelerationStructureNV) NextGetDeviceProcAddr(device, "vkCreateAccelerationStructureNV");
      this->CreateBuffer = (PFN_vkCreateBuffer) NextGetDeviceProcAddr(device, "vkCreateBuffer");
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->CreateBufferCollectionFUCHSIA = (PFN_vkCreateBufferCollectionFUCHSIA) NextGetDeviceProcAddr(device, "vkCreateBufferCollectionFUCHSIA");
#endif
      this->CreateBufferView = (PFN_vkCreateBufferView) NextGetDeviceProcAddr(device, "vkCreateBufferView");
      this->CreateCommandPool = (PFN_vkCreateCommandPool) NextGetDeviceProcAddr(device, "vkCreateCommandPool");
      this->CreateComputePipelines = (PFN_vkCreateComputePipelines) NextGetDeviceProcAddr(device, "vkCreateComputePipelines");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->CreateCudaFunctionNV = (PFN_vkCreateCudaFunctionNV) NextGetDeviceProcAddr(device, "vkCreateCudaFunctionNV");
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->CreateCudaModuleNV = (PFN_vkCreateCudaModuleNV) NextGetDeviceProcAddr(device, "vkCreateCudaModuleNV");
#endif
      this->CreateDataGraphPipelineSessionARM = (PFN_vkCreateDataGraphPipelineSessionARM) NextGetDeviceProcAddr(device, "vkCreateDataGraphPipelineSessionARM");
      this->CreateDataGraphPipelinesARM = (PFN_vkCreateDataGraphPipelinesARM) NextGetDeviceProcAddr(device, "vkCreateDataGraphPipelinesARM");
      this->CreateDeferredOperationKHR = (PFN_vkCreateDeferredOperationKHR) NextGetDeviceProcAddr(device, "vkCreateDeferredOperationKHR");
      this->CreateDescriptorPool = (PFN_vkCreateDescriptorPool) NextGetDeviceProcAddr(device, "vkCreateDescriptorPool");
      this->CreateDescriptorSetLayout = (PFN_vkCreateDescriptorSetLayout) NextGetDeviceProcAddr(device, "vkCreateDescriptorSetLayout");
      this->CreateDescriptorUpdateTemplate = (PFN_vkCreateDescriptorUpdateTemplate) NextGetDeviceProcAddr(device, "vkCreateDescriptorUpdateTemplate");
      this->CreateDescriptorUpdateTemplateKHR = (PFN_vkCreateDescriptorUpdateTemplateKHR) NextGetDeviceProcAddr(device, "vkCreateDescriptorUpdateTemplateKHR");
      this->CreateEvent = (PFN_vkCreateEvent) NextGetDeviceProcAddr(device, "vkCreateEvent");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->CreateExecutionGraphPipelinesAMDX = (PFN_vkCreateExecutionGraphPipelinesAMDX) NextGetDeviceProcAddr(device, "vkCreateExecutionGraphPipelinesAMDX");
#endif
      this->CreateExternalComputeQueueNV = (PFN_vkCreateExternalComputeQueueNV) NextGetDeviceProcAddr(device, "vkCreateExternalComputeQueueNV");
      this->CreateFence = (PFN_vkCreateFence) NextGetDeviceProcAddr(device, "vkCreateFence");
      this->CreateFramebuffer = (PFN_vkCreateFramebuffer) NextGetDeviceProcAddr(device, "vkCreateFramebuffer");
      this->CreateGraphicsPipelines = (PFN_vkCreateGraphicsPipelines) NextGetDeviceProcAddr(device, "vkCreateGraphicsPipelines");
      this->CreateImage = (PFN_vkCreateImage) NextGetDeviceProcAddr(device, "vkCreateImage");
      this->CreateImageView = (PFN_vkCreateImageView) NextGetDeviceProcAddr(device, "vkCreateImageView");
      this->CreateIndirectCommandsLayoutEXT = (PFN_vkCreateIndirectCommandsLayoutEXT) NextGetDeviceProcAddr(device, "vkCreateIndirectCommandsLayoutEXT");
      this->CreateIndirectCommandsLayoutNV = (PFN_vkCreateIndirectCommandsLayoutNV) NextGetDeviceProcAddr(device, "vkCreateIndirectCommandsLayoutNV");
      this->CreateIndirectExecutionSetEXT = (PFN_vkCreateIndirectExecutionSetEXT) NextGetDeviceProcAddr(device, "vkCreateIndirectExecutionSetEXT");
      this->CreateMicromapEXT = (PFN_vkCreateMicromapEXT) NextGetDeviceProcAddr(device, "vkCreateMicromapEXT");
      this->CreateOpticalFlowSessionNV = (PFN_vkCreateOpticalFlowSessionNV) NextGetDeviceProcAddr(device, "vkCreateOpticalFlowSessionNV");
      this->CreatePipelineBinariesKHR = (PFN_vkCreatePipelineBinariesKHR) NextGetDeviceProcAddr(device, "vkCreatePipelineBinariesKHR");
      this->CreatePipelineCache = (PFN_vkCreatePipelineCache) NextGetDeviceProcAddr(device, "vkCreatePipelineCache");
      this->CreatePipelineLayout = (PFN_vkCreatePipelineLayout) NextGetDeviceProcAddr(device, "vkCreatePipelineLayout");
      this->CreatePrivateDataSlot = (PFN_vkCreatePrivateDataSlot) NextGetDeviceProcAddr(device, "vkCreatePrivateDataSlot");
      this->CreatePrivateDataSlotEXT = (PFN_vkCreatePrivateDataSlotEXT) NextGetDeviceProcAddr(device, "vkCreatePrivateDataSlotEXT");
      this->CreateQueryPool = (PFN_vkCreateQueryPool) NextGetDeviceProcAddr(device, "vkCreateQueryPool");
      this->CreateRayTracingPipelinesKHR = (PFN_vkCreateRayTracingPipelinesKHR) NextGetDeviceProcAddr(device, "vkCreateRayTracingPipelinesKHR");
      this->CreateRayTracingPipelinesNV = (PFN_vkCreateRayTracingPipelinesNV) NextGetDeviceProcAddr(device, "vkCreateRayTracingPipelinesNV");
      this->CreateRenderPass = (PFN_vkCreateRenderPass) NextGetDeviceProcAddr(device, "vkCreateRenderPass");
      this->CreateRenderPass2 = (PFN_vkCreateRenderPass2) NextGetDeviceProcAddr(device, "vkCreateRenderPass2");
      this->CreateRenderPass2KHR = (PFN_vkCreateRenderPass2KHR) NextGetDeviceProcAddr(device, "vkCreateRenderPass2KHR");
      this->CreateSampler = (PFN_vkCreateSampler) NextGetDeviceProcAddr(device, "vkCreateSampler");
      this->CreateSamplerYcbcrConversion = (PFN_vkCreateSamplerYcbcrConversion) NextGetDeviceProcAddr(device, "vkCreateSamplerYcbcrConversion");
      this->CreateSamplerYcbcrConversionKHR = (PFN_vkCreateSamplerYcbcrConversionKHR) NextGetDeviceProcAddr(device, "vkCreateSamplerYcbcrConversionKHR");
      this->CreateSemaphore = (PFN_vkCreateSemaphore) NextGetDeviceProcAddr(device, "vkCreateSemaphore");
      this->CreateShaderModule = (PFN_vkCreateShaderModule) NextGetDeviceProcAddr(device, "vkCreateShaderModule");
      this->CreateShadersEXT = (PFN_vkCreateShadersEXT) NextGetDeviceProcAddr(device, "vkCreateShadersEXT");
      this->CreateSharedSwapchainsKHR = (PFN_vkCreateSharedSwapchainsKHR) NextGetDeviceProcAddr(device, "vkCreateSharedSwapchainsKHR");
      this->CreateSwapchainKHR = (PFN_vkCreateSwapchainKHR) NextGetDeviceProcAddr(device, "vkCreateSwapchainKHR");
      this->CreateTensorARM = (PFN_vkCreateTensorARM) NextGetDeviceProcAddr(device, "vkCreateTensorARM");
      this->CreateTensorViewARM = (PFN_vkCreateTensorViewARM) NextGetDeviceProcAddr(device, "vkCreateTensorViewARM");
      this->CreateValidationCacheEXT = (PFN_vkCreateValidationCacheEXT) NextGetDeviceProcAddr(device, "vkCreateValidationCacheEXT");
      this->CreateVideoSessionKHR = (PFN_vkCreateVideoSessionKHR) NextGetDeviceProcAddr(device, "vkCreateVideoSessionKHR");
      this->CreateVideoSessionParametersKHR = (PFN_vkCreateVideoSessionParametersKHR) NextGetDeviceProcAddr(device, "vkCreateVideoSessionParametersKHR");
      this->DebugMarkerSetObjectNameEXT = (PFN_vkDebugMarkerSetObjectNameEXT) NextGetDeviceProcAddr(device, "vkDebugMarkerSetObjectNameEXT");
      this->DebugMarkerSetObjectTagEXT = (PFN_vkDebugMarkerSetObjectTagEXT) NextGetDeviceProcAddr(device, "vkDebugMarkerSetObjectTagEXT");
      this->DeferredOperationJoinKHR = (PFN_vkDeferredOperationJoinKHR) NextGetDeviceProcAddr(device, "vkDeferredOperationJoinKHR");
      this->DestroyAccelerationStructureKHR = (PFN_vkDestroyAccelerationStructureKHR) NextGetDeviceProcAddr(device, "vkDestroyAccelerationStructureKHR");
      this->DestroyAccelerationStructureNV = (PFN_vkDestroyAccelerationStructureNV) NextGetDeviceProcAddr(device, "vkDestroyAccelerationStructureNV");
      this->DestroyBuffer = (PFN_vkDestroyBuffer) NextGetDeviceProcAddr(device, "vkDestroyBuffer");
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->DestroyBufferCollectionFUCHSIA = (PFN_vkDestroyBufferCollectionFUCHSIA) NextGetDeviceProcAddr(device, "vkDestroyBufferCollectionFUCHSIA");
#endif
      this->DestroyBufferView = (PFN_vkDestroyBufferView) NextGetDeviceProcAddr(device, "vkDestroyBufferView");
      this->DestroyCommandPool = (PFN_vkDestroyCommandPool) NextGetDeviceProcAddr(device, "vkDestroyCommandPool");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->DestroyCudaFunctionNV = (PFN_vkDestroyCudaFunctionNV) NextGetDeviceProcAddr(device, "vkDestroyCudaFunctionNV");
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->DestroyCudaModuleNV = (PFN_vkDestroyCudaModuleNV) NextGetDeviceProcAddr(device, "vkDestroyCudaModuleNV");
#endif
      this->DestroyDataGraphPipelineSessionARM = (PFN_vkDestroyDataGraphPipelineSessionARM) NextGetDeviceProcAddr(device, "vkDestroyDataGraphPipelineSessionARM");
      this->DestroyDeferredOperationKHR = (PFN_vkDestroyDeferredOperationKHR) NextGetDeviceProcAddr(device, "vkDestroyDeferredOperationKHR");
      this->DestroyDescriptorPool = (PFN_vkDestroyDescriptorPool) NextGetDeviceProcAddr(device, "vkDestroyDescriptorPool");
      this->DestroyDescriptorSetLayout = (PFN_vkDestroyDescriptorSetLayout) NextGetDeviceProcAddr(device, "vkDestroyDescriptorSetLayout");
      this->DestroyDescriptorUpdateTemplate = (PFN_vkDestroyDescriptorUpdateTemplate) NextGetDeviceProcAddr(device, "vkDestroyDescriptorUpdateTemplate");
      this->DestroyDescriptorUpdateTemplateKHR = (PFN_vkDestroyDescriptorUpdateTemplateKHR) NextGetDeviceProcAddr(device, "vkDestroyDescriptorUpdateTemplateKHR");
      this->_RealDestroyDevice = (PFN_vkDestroyDevice) NextGetDeviceProcAddr(device, "vkDestroyDevice");
      this->DestroyDevice = (PFN_vkDestroyDevice) DestroyDeviceWrapper;
      this->DestroyEvent = (PFN_vkDestroyEvent) NextGetDeviceProcAddr(device, "vkDestroyEvent");
      this->DestroyExternalComputeQueueNV = (PFN_vkDestroyExternalComputeQueueNV) NextGetDeviceProcAddr(device, "vkDestroyExternalComputeQueueNV");
      this->DestroyFence = (PFN_vkDestroyFence) NextGetDeviceProcAddr(device, "vkDestroyFence");
      this->DestroyFramebuffer = (PFN_vkDestroyFramebuffer) NextGetDeviceProcAddr(device, "vkDestroyFramebuffer");
      this->DestroyImage = (PFN_vkDestroyImage) NextGetDeviceProcAddr(device, "vkDestroyImage");
      this->DestroyImageView = (PFN_vkDestroyImageView) NextGetDeviceProcAddr(device, "vkDestroyImageView");
      this->DestroyIndirectCommandsLayoutEXT = (PFN_vkDestroyIndirectCommandsLayoutEXT) NextGetDeviceProcAddr(device, "vkDestroyIndirectCommandsLayoutEXT");
      this->DestroyIndirectCommandsLayoutNV = (PFN_vkDestroyIndirectCommandsLayoutNV) NextGetDeviceProcAddr(device, "vkDestroyIndirectCommandsLayoutNV");
      this->DestroyIndirectExecutionSetEXT = (PFN_vkDestroyIndirectExecutionSetEXT) NextGetDeviceProcAddr(device, "vkDestroyIndirectExecutionSetEXT");
      this->DestroyMicromapEXT = (PFN_vkDestroyMicromapEXT) NextGetDeviceProcAddr(device, "vkDestroyMicromapEXT");
      this->DestroyOpticalFlowSessionNV = (PFN_vkDestroyOpticalFlowSessionNV) NextGetDeviceProcAddr(device, "vkDestroyOpticalFlowSessionNV");
      this->DestroyPipeline = (PFN_vkDestroyPipeline) NextGetDeviceProcAddr(device, "vkDestroyPipeline");
      this->DestroyPipelineBinaryKHR = (PFN_vkDestroyPipelineBinaryKHR) NextGetDeviceProcAddr(device, "vkDestroyPipelineBinaryKHR");
      this->DestroyPipelineCache = (PFN_vkDestroyPipelineCache) NextGetDeviceProcAddr(device, "vkDestroyPipelineCache");
      this->DestroyPipelineLayout = (PFN_vkDestroyPipelineLayout) NextGetDeviceProcAddr(device, "vkDestroyPipelineLayout");
      this->DestroyPrivateDataSlot = (PFN_vkDestroyPrivateDataSlot) NextGetDeviceProcAddr(device, "vkDestroyPrivateDataSlot");
      this->DestroyPrivateDataSlotEXT = (PFN_vkDestroyPrivateDataSlotEXT) NextGetDeviceProcAddr(device, "vkDestroyPrivateDataSlotEXT");
      this->DestroyQueryPool = (PFN_vkDestroyQueryPool) NextGetDeviceProcAddr(device, "vkDestroyQueryPool");
      this->DestroyRenderPass = (PFN_vkDestroyRenderPass) NextGetDeviceProcAddr(device, "vkDestroyRenderPass");
      this->DestroySampler = (PFN_vkDestroySampler) NextGetDeviceProcAddr(device, "vkDestroySampler");
      this->DestroySamplerYcbcrConversion = (PFN_vkDestroySamplerYcbcrConversion) NextGetDeviceProcAddr(device, "vkDestroySamplerYcbcrConversion");
      this->DestroySamplerYcbcrConversionKHR = (PFN_vkDestroySamplerYcbcrConversionKHR) NextGetDeviceProcAddr(device, "vkDestroySamplerYcbcrConversionKHR");
      this->DestroySemaphore = (PFN_vkDestroySemaphore) NextGetDeviceProcAddr(device, "vkDestroySemaphore");
      this->DestroyShaderEXT = (PFN_vkDestroyShaderEXT) NextGetDeviceProcAddr(device, "vkDestroyShaderEXT");
      this->DestroyShaderModule = (PFN_vkDestroyShaderModule) NextGetDeviceProcAddr(device, "vkDestroyShaderModule");
      this->DestroySwapchainKHR = (PFN_vkDestroySwapchainKHR) NextGetDeviceProcAddr(device, "vkDestroySwapchainKHR");
      this->DestroyTensorARM = (PFN_vkDestroyTensorARM) NextGetDeviceProcAddr(device, "vkDestroyTensorARM");
      this->DestroyTensorViewARM = (PFN_vkDestroyTensorViewARM) NextGetDeviceProcAddr(device, "vkDestroyTensorViewARM");
      this->DestroyValidationCacheEXT = (PFN_vkDestroyValidationCacheEXT) NextGetDeviceProcAddr(device, "vkDestroyValidationCacheEXT");
      this->DestroyVideoSessionKHR = (PFN_vkDestroyVideoSessionKHR) NextGetDeviceProcAddr(device, "vkDestroyVideoSessionKHR");
      this->DestroyVideoSessionParametersKHR = (PFN_vkDestroyVideoSessionParametersKHR) NextGetDeviceProcAddr(device, "vkDestroyVideoSessionParametersKHR");
      this->DeviceWaitIdle = (PFN_vkDeviceWaitIdle) NextGetDeviceProcAddr(device, "vkDeviceWaitIdle");
      this->DisplayPowerControlEXT = (PFN_vkDisplayPowerControlEXT) NextGetDeviceProcAddr(device, "vkDisplayPowerControlEXT");
      this->EndCommandBuffer = (PFN_vkEndCommandBuffer) NextGetDeviceProcAddr(device, "vkEndCommandBuffer");
#ifdef VK_USE_PLATFORM_METAL_EXT
      this->ExportMetalObjectsEXT = (PFN_vkExportMetalObjectsEXT) NextGetDeviceProcAddr(device, "vkExportMetalObjectsEXT");
#endif
      this->FlushMappedMemoryRanges = (PFN_vkFlushMappedMemoryRanges) NextGetDeviceProcAddr(device, "vkFlushMappedMemoryRanges");
      this->_RealFreeCommandBuffers = (PFN_vkFreeCommandBuffers) NextGetDeviceProcAddr(device, "vkFreeCommandBuffers");
      this->FreeCommandBuffers = (PFN_vkFreeCommandBuffers) implicit_wrap_FreeCommandBuffers;
      this->FreeDescriptorSets = (PFN_vkFreeDescriptorSets) NextGetDeviceProcAddr(device, "vkFreeDescriptorSets");
      this->FreeMemory = (PFN_vkFreeMemory) NextGetDeviceProcAddr(device, "vkFreeMemory");
      this->GetAccelerationStructureBuildSizesKHR = (PFN_vkGetAccelerationStructureBuildSizesKHR) NextGetDeviceProcAddr(device, "vkGetAccelerationStructureBuildSizesKHR");
      this->GetAccelerationStructureDeviceAddressKHR = (PFN_vkGetAccelerationStructureDeviceAddressKHR) NextGetDeviceProcAddr(device, "vkGetAccelerationStructureDeviceAddressKHR");
      this->GetAccelerationStructureHandleNV = (PFN_vkGetAccelerationStructureHandleNV) NextGetDeviceProcAddr(device, "vkGetAccelerationStructureHandleNV");
      this->GetAccelerationStructureMemoryRequirementsNV = (PFN_vkGetAccelerationStructureMemoryRequirementsNV) NextGetDeviceProcAddr(device, "vkGetAccelerationStructureMemoryRequirementsNV");
      this->GetAccelerationStructureOpaqueCaptureDescriptorDataEXT = (PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT) NextGetDeviceProcAddr(device, "vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT");
#ifdef VK_USE_PLATFORM_ANDROID_KHR
      this->GetAndroidHardwareBufferPropertiesANDROID = (PFN_vkGetAndroidHardwareBufferPropertiesANDROID) NextGetDeviceProcAddr(device, "vkGetAndroidHardwareBufferPropertiesANDROID");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->GetBufferCollectionPropertiesFUCHSIA = (PFN_vkGetBufferCollectionPropertiesFUCHSIA) NextGetDeviceProcAddr(device, "vkGetBufferCollectionPropertiesFUCHSIA");
#endif
      this->GetBufferDeviceAddress = (PFN_vkGetBufferDeviceAddress) NextGetDeviceProcAddr(device, "vkGetBufferDeviceAddress");
      this->GetBufferDeviceAddressEXT = (PFN_vkGetBufferDeviceAddressEXT) NextGetDeviceProcAddr(device, "vkGetBufferDeviceAddressEXT");
      this->GetBufferDeviceAddressKHR = (PFN_vkGetBufferDeviceAddressKHR) NextGetDeviceProcAddr(device, "vkGetBufferDeviceAddressKHR");
      this->GetBufferMemoryRequirements = (PFN_vkGetBufferMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetBufferMemoryRequirements");
      this->GetBufferMemoryRequirements2 = (PFN_vkGetBufferMemoryRequirements2) NextGetDeviceProcAddr(device, "vkGetBufferMemoryRequirements2");
      this->GetBufferMemoryRequirements2KHR = (PFN_vkGetBufferMemoryRequirements2KHR) NextGetDeviceProcAddr(device, "vkGetBufferMemoryRequirements2KHR");
      this->GetBufferOpaqueCaptureAddress = (PFN_vkGetBufferOpaqueCaptureAddress) NextGetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureAddress");
      this->GetBufferOpaqueCaptureAddressKHR = (PFN_vkGetBufferOpaqueCaptureAddressKHR) NextGetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureAddressKHR");
      this->GetBufferOpaqueCaptureDescriptorDataEXT = (PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT) NextGetDeviceProcAddr(device, "vkGetBufferOpaqueCaptureDescriptorDataEXT");
      this->GetCalibratedTimestampsEXT = (PFN_vkGetCalibratedTimestampsEXT) NextGetDeviceProcAddr(device, "vkGetCalibratedTimestampsEXT");
      this->GetCalibratedTimestampsKHR = (PFN_vkGetCalibratedTimestampsKHR) NextGetDeviceProcAddr(device, "vkGetCalibratedTimestampsKHR");
      this->GetClusterAccelerationStructureBuildSizesNV = (PFN_vkGetClusterAccelerationStructureBuildSizesNV) NextGetDeviceProcAddr(device, "vkGetClusterAccelerationStructureBuildSizesNV");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->GetCudaModuleCacheNV = (PFN_vkGetCudaModuleCacheNV) NextGetDeviceProcAddr(device, "vkGetCudaModuleCacheNV");
#endif
      this->GetDataGraphPipelineAvailablePropertiesARM = (PFN_vkGetDataGraphPipelineAvailablePropertiesARM) NextGetDeviceProcAddr(device, "vkGetDataGraphPipelineAvailablePropertiesARM");
      this->GetDataGraphPipelinePropertiesARM = (PFN_vkGetDataGraphPipelinePropertiesARM) NextGetDeviceProcAddr(device, "vkGetDataGraphPipelinePropertiesARM");
      this->GetDataGraphPipelineSessionBindPointRequirementsARM = (PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM) NextGetDeviceProcAddr(device, "vkGetDataGraphPipelineSessionBindPointRequirementsARM");
      this->GetDataGraphPipelineSessionMemoryRequirementsARM = (PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM) NextGetDeviceProcAddr(device, "vkGetDataGraphPipelineSessionMemoryRequirementsARM");
      this->GetDeferredOperationMaxConcurrencyKHR = (PFN_vkGetDeferredOperationMaxConcurrencyKHR) NextGetDeviceProcAddr(device, "vkGetDeferredOperationMaxConcurrencyKHR");
      this->GetDeferredOperationResultKHR = (PFN_vkGetDeferredOperationResultKHR) NextGetDeviceProcAddr(device, "vkGetDeferredOperationResultKHR");
      this->GetDescriptorEXT = (PFN_vkGetDescriptorEXT) NextGetDeviceProcAddr(device, "vkGetDescriptorEXT");
      this->GetDescriptorSetHostMappingVALVE = (PFN_vkGetDescriptorSetHostMappingVALVE) NextGetDeviceProcAddr(device, "vkGetDescriptorSetHostMappingVALVE");
      this->GetDescriptorSetLayoutBindingOffsetEXT = (PFN_vkGetDescriptorSetLayoutBindingOffsetEXT) NextGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutBindingOffsetEXT");
      this->GetDescriptorSetLayoutHostMappingInfoVALVE = (PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE) NextGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutHostMappingInfoVALVE");
      this->GetDescriptorSetLayoutSizeEXT = (PFN_vkGetDescriptorSetLayoutSizeEXT) NextGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSizeEXT");
      this->GetDescriptorSetLayoutSupport = (PFN_vkGetDescriptorSetLayoutSupport) NextGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSupport");
      this->GetDescriptorSetLayoutSupportKHR = (PFN_vkGetDescriptorSetLayoutSupportKHR) NextGetDeviceProcAddr(device, "vkGetDescriptorSetLayoutSupportKHR");
      this->GetDeviceAccelerationStructureCompatibilityKHR = (PFN_vkGetDeviceAccelerationStructureCompatibilityKHR) NextGetDeviceProcAddr(device, "vkGetDeviceAccelerationStructureCompatibilityKHR");
      this->GetDeviceBufferMemoryRequirements = (PFN_vkGetDeviceBufferMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetDeviceBufferMemoryRequirements");
      this->GetDeviceBufferMemoryRequirementsKHR = (PFN_vkGetDeviceBufferMemoryRequirementsKHR) NextGetDeviceProcAddr(device, "vkGetDeviceBufferMemoryRequirementsKHR");
      this->GetDeviceFaultInfoEXT = (PFN_vkGetDeviceFaultInfoEXT) NextGetDeviceProcAddr(device, "vkGetDeviceFaultInfoEXT");
      this->GetDeviceGroupPeerMemoryFeatures = (PFN_vkGetDeviceGroupPeerMemoryFeatures) NextGetDeviceProcAddr(device, "vkGetDeviceGroupPeerMemoryFeatures");
      this->GetDeviceGroupPeerMemoryFeaturesKHR = (PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR) NextGetDeviceProcAddr(device, "vkGetDeviceGroupPeerMemoryFeaturesKHR");
      this->GetDeviceGroupPresentCapabilitiesKHR = (PFN_vkGetDeviceGroupPresentCapabilitiesKHR) NextGetDeviceProcAddr(device, "vkGetDeviceGroupPresentCapabilitiesKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->GetDeviceGroupSurfacePresentModes2EXT = (PFN_vkGetDeviceGroupSurfacePresentModes2EXT) NextGetDeviceProcAddr(device, "vkGetDeviceGroupSurfacePresentModes2EXT");
#endif
      this->GetDeviceGroupSurfacePresentModesKHR = (PFN_vkGetDeviceGroupSurfacePresentModesKHR) NextGetDeviceProcAddr(device, "vkGetDeviceGroupSurfacePresentModesKHR");
      this->GetDeviceImageMemoryRequirements = (PFN_vkGetDeviceImageMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetDeviceImageMemoryRequirements");
      this->GetDeviceImageMemoryRequirementsKHR = (PFN_vkGetDeviceImageMemoryRequirementsKHR) NextGetDeviceProcAddr(device, "vkGetDeviceImageMemoryRequirementsKHR");
      this->GetDeviceImageSparseMemoryRequirements = (PFN_vkGetDeviceImageSparseMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetDeviceImageSparseMemoryRequirements");
      this->GetDeviceImageSparseMemoryRequirementsKHR = (PFN_vkGetDeviceImageSparseMemoryRequirementsKHR) NextGetDeviceProcAddr(device, "vkGetDeviceImageSparseMemoryRequirementsKHR");
      this->GetDeviceImageSubresourceLayoutKHR = (PFN_vkGetDeviceImageSubresourceLayoutKHR) NextGetDeviceProcAddr(device, "vkGetDeviceImageSubresourceLayoutKHR");
      this->GetDeviceMemoryCommitment = (PFN_vkGetDeviceMemoryCommitment) NextGetDeviceProcAddr(device, "vkGetDeviceMemoryCommitment");
      this->GetDeviceMemoryOpaqueCaptureAddress = (PFN_vkGetDeviceMemoryOpaqueCaptureAddress) NextGetDeviceProcAddr(device, "vkGetDeviceMemoryOpaqueCaptureAddress");
      this->GetDeviceMemoryOpaqueCaptureAddressKHR = (PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR) NextGetDeviceProcAddr(device, "vkGetDeviceMemoryOpaqueCaptureAddressKHR");
      this->GetDeviceMicromapCompatibilityEXT = (PFN_vkGetDeviceMicromapCompatibilityEXT) NextGetDeviceProcAddr(device, "vkGetDeviceMicromapCompatibilityEXT");
      this->GetDeviceProcAddr = NextGetDeviceProcAddr;
      this->GetDeviceQueue = (PFN_vkGetDeviceQueue) NextGetDeviceProcAddr(device, "vkGetDeviceQueue");
      this->GetDeviceQueue2 = (PFN_vkGetDeviceQueue2) NextGetDeviceProcAddr(device, "vkGetDeviceQueue2");
      this->GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = (PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI) NextGetDeviceProcAddr(device, "vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI");
      this->GetDeviceTensorMemoryRequirementsARM = (PFN_vkGetDeviceTensorMemoryRequirementsARM) NextGetDeviceProcAddr(device, "vkGetDeviceTensorMemoryRequirementsARM");
      this->GetDynamicRenderingTilePropertiesQCOM = (PFN_vkGetDynamicRenderingTilePropertiesQCOM) NextGetDeviceProcAddr(device, "vkGetDynamicRenderingTilePropertiesQCOM");
      this->GetEncodedVideoSessionParametersKHR = (PFN_vkGetEncodedVideoSessionParametersKHR) NextGetDeviceProcAddr(device, "vkGetEncodedVideoSessionParametersKHR");
      this->GetEventStatus = (PFN_vkGetEventStatus) NextGetDeviceProcAddr(device, "vkGetEventStatus");
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->GetExecutionGraphPipelineNodeIndexAMDX = (PFN_vkGetExecutionGraphPipelineNodeIndexAMDX) NextGetDeviceProcAddr(device, "vkGetExecutionGraphPipelineNodeIndexAMDX");
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
      this->GetExecutionGraphPipelineScratchSizeAMDX = (PFN_vkGetExecutionGraphPipelineScratchSizeAMDX) NextGetDeviceProcAddr(device, "vkGetExecutionGraphPipelineScratchSizeAMDX");
#endif
      this->GetExternalComputeQueueDataNV = (PFN_vkGetExternalComputeQueueDataNV) NextGetDeviceProcAddr(device, "vkGetExternalComputeQueueDataNV");
      this->GetFenceFdKHR = (PFN_vkGetFenceFdKHR) NextGetDeviceProcAddr(device, "vkGetFenceFdKHR");
      this->GetFenceStatus = (PFN_vkGetFenceStatus) NextGetDeviceProcAddr(device, "vkGetFenceStatus");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->GetFenceWin32HandleKHR = (PFN_vkGetFenceWin32HandleKHR) NextGetDeviceProcAddr(device, "vkGetFenceWin32HandleKHR");
#endif
      this->GetFramebufferTilePropertiesQCOM = (PFN_vkGetFramebufferTilePropertiesQCOM) NextGetDeviceProcAddr(device, "vkGetFramebufferTilePropertiesQCOM");
      this->GetGeneratedCommandsMemoryRequirementsEXT = (PFN_vkGetGeneratedCommandsMemoryRequirementsEXT) NextGetDeviceProcAddr(device, "vkGetGeneratedCommandsMemoryRequirementsEXT");
      this->GetGeneratedCommandsMemoryRequirementsNV = (PFN_vkGetGeneratedCommandsMemoryRequirementsNV) NextGetDeviceProcAddr(device, "vkGetGeneratedCommandsMemoryRequirementsNV");
      this->GetImageDrmFormatModifierPropertiesEXT = (PFN_vkGetImageDrmFormatModifierPropertiesEXT) NextGetDeviceProcAddr(device, "vkGetImageDrmFormatModifierPropertiesEXT");
      this->GetImageMemoryRequirements = (PFN_vkGetImageMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetImageMemoryRequirements");
      this->GetImageMemoryRequirements2 = (PFN_vkGetImageMemoryRequirements2) NextGetDeviceProcAddr(device, "vkGetImageMemoryRequirements2");
      this->GetImageMemoryRequirements2KHR = (PFN_vkGetImageMemoryRequirements2KHR) NextGetDeviceProcAddr(device, "vkGetImageMemoryRequirements2KHR");
      this->GetImageOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageOpaqueCaptureDescriptorDataEXT) NextGetDeviceProcAddr(device, "vkGetImageOpaqueCaptureDescriptorDataEXT");
      this->GetImageSparseMemoryRequirements = (PFN_vkGetImageSparseMemoryRequirements) NextGetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements");
      this->GetImageSparseMemoryRequirements2 = (PFN_vkGetImageSparseMemoryRequirements2) NextGetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements2");
      this->GetImageSparseMemoryRequirements2KHR = (PFN_vkGetImageSparseMemoryRequirements2KHR) NextGetDeviceProcAddr(device, "vkGetImageSparseMemoryRequirements2KHR");
      this->GetImageSubresourceLayout = (PFN_vkGetImageSubresourceLayout) NextGetDeviceProcAddr(device, "vkGetImageSubresourceLayout");
      this->GetImageSubresourceLayout2EXT = (PFN_vkGetImageSubresourceLayout2EXT) NextGetDeviceProcAddr(device, "vkGetImageSubresourceLayout2EXT");
      this->GetImageSubresourceLayout2KHR = (PFN_vkGetImageSubresourceLayout2KHR) NextGetDeviceProcAddr(device, "vkGetImageSubresourceLayout2KHR");
      this->GetImageViewOpaqueCaptureDescriptorDataEXT = (PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT) NextGetDeviceProcAddr(device, "vkGetImageViewOpaqueCaptureDescriptorDataEXT");
      this->GetLatencyTimingsNV = (PFN_vkGetLatencyTimingsNV) NextGetDeviceProcAddr(device, "vkGetLatencyTimingsNV");
#ifdef VK_USE_PLATFORM_ANDROID_KHR
      this->GetMemoryAndroidHardwareBufferANDROID = (PFN_vkGetMemoryAndroidHardwareBufferANDROID) NextGetDeviceProcAddr(device, "vkGetMemoryAndroidHardwareBufferANDROID");
#endif
      this->GetMemoryFdKHR = (PFN_vkGetMemoryFdKHR) NextGetDeviceProcAddr(device, "vkGetMemoryFdKHR");
      this->GetMemoryFdPropertiesKHR = (PFN_vkGetMemoryFdPropertiesKHR) NextGetDeviceProcAddr(device, "vkGetMemoryFdPropertiesKHR");
      this->GetMemoryHostPointerPropertiesEXT = (PFN_vkGetMemoryHostPointerPropertiesEXT) NextGetDeviceProcAddr(device, "vkGetMemoryHostPointerPropertiesEXT");
#ifdef VK_USE_PLATFORM_METAL_EXT
      this->GetMemoryMetalHandleEXT = (PFN_vkGetMemoryMetalHandleEXT) NextGetDeviceProcAddr(device, "vkGetMemoryMetalHandleEXT");
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
      this->GetMemoryMetalHandlePropertiesEXT = (PFN_vkGetMemoryMetalHandlePropertiesEXT) NextGetDeviceProcAddr(device, "vkGetMemoryMetalHandlePropertiesEXT");
#endif
      this->GetMemoryRemoteAddressNV = (PFN_vkGetMemoryRemoteAddressNV) NextGetDeviceProcAddr(device, "vkGetMemoryRemoteAddressNV");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->GetMemoryWin32HandleKHR = (PFN_vkGetMemoryWin32HandleKHR) NextGetDeviceProcAddr(device, "vkGetMemoryWin32HandleKHR");
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->GetMemoryWin32HandleNV = (PFN_vkGetMemoryWin32HandleNV) NextGetDeviceProcAddr(device, "vkGetMemoryWin32HandleNV");
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->GetMemoryWin32HandlePropertiesKHR = (PFN_vkGetMemoryWin32HandlePropertiesKHR) NextGetDeviceProcAddr(device, "vkGetMemoryWin32HandlePropertiesKHR");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->GetMemoryZirconHandleFUCHSIA = (PFN_vkGetMemoryZirconHandleFUCHSIA) NextGetDeviceProcAddr(device, "vkGetMemoryZirconHandleFUCHSIA");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->GetMemoryZirconHandlePropertiesFUCHSIA = (PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA) NextGetDeviceProcAddr(device, "vkGetMemoryZirconHandlePropertiesFUCHSIA");
#endif
      this->GetMicromapBuildSizesEXT = (PFN_vkGetMicromapBuildSizesEXT) NextGetDeviceProcAddr(device, "vkGetMicromapBuildSizesEXT");
      this->GetPartitionedAccelerationStructuresBuildSizesNV = (PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV) NextGetDeviceProcAddr(device, "vkGetPartitionedAccelerationStructuresBuildSizesNV");
      this->GetPastPresentationTimingGOOGLE = (PFN_vkGetPastPresentationTimingGOOGLE) NextGetDeviceProcAddr(device, "vkGetPastPresentationTimingGOOGLE");
      this->GetPerformanceParameterINTEL = (PFN_vkGetPerformanceParameterINTEL) NextGetDeviceProcAddr(device, "vkGetPerformanceParameterINTEL");
      this->GetPipelineBinaryDataKHR = (PFN_vkGetPipelineBinaryDataKHR) NextGetDeviceProcAddr(device, "vkGetPipelineBinaryDataKHR");
      this->GetPipelineCacheData = (PFN_vkGetPipelineCacheData) NextGetDeviceProcAddr(device, "vkGetPipelineCacheData");
      this->GetPipelineExecutableInternalRepresentationsKHR = (PFN_vkGetPipelineExecutableInternalRepresentationsKHR) NextGetDeviceProcAddr(device, "vkGetPipelineExecutableInternalRepresentationsKHR");
      this->GetPipelineExecutablePropertiesKHR = (PFN_vkGetPipelineExecutablePropertiesKHR) NextGetDeviceProcAddr(device, "vkGetPipelineExecutablePropertiesKHR");
      this->GetPipelineExecutableStatisticsKHR = (PFN_vkGetPipelineExecutableStatisticsKHR) NextGetDeviceProcAddr(device, "vkGetPipelineExecutableStatisticsKHR");
      this->GetPipelineIndirectDeviceAddressNV = (PFN_vkGetPipelineIndirectDeviceAddressNV) NextGetDeviceProcAddr(device, "vkGetPipelineIndirectDeviceAddressNV");
      this->GetPipelineIndirectMemoryRequirementsNV = (PFN_vkGetPipelineIndirectMemoryRequirementsNV) NextGetDeviceProcAddr(device, "vkGetPipelineIndirectMemoryRequirementsNV");
      this->GetPipelineKeyKHR = (PFN_vkGetPipelineKeyKHR) NextGetDeviceProcAddr(device, "vkGetPipelineKeyKHR");
      this->GetPipelinePropertiesEXT = (PFN_vkGetPipelinePropertiesEXT) NextGetDeviceProcAddr(device, "vkGetPipelinePropertiesEXT");
      this->GetPrivateData = (PFN_vkGetPrivateData) NextGetDeviceProcAddr(device, "vkGetPrivateData");
      this->GetPrivateDataEXT = (PFN_vkGetPrivateDataEXT) NextGetDeviceProcAddr(device, "vkGetPrivateDataEXT");
      this->GetQueryPoolResults = (PFN_vkGetQueryPoolResults) NextGetDeviceProcAddr(device, "vkGetQueryPoolResults");
      this->GetQueueCheckpointData2NV = (PFN_vkGetQueueCheckpointData2NV) NextGetDeviceProcAddr(device, "vkGetQueueCheckpointData2NV");
      this->GetQueueCheckpointDataNV = (PFN_vkGetQueueCheckpointDataNV) NextGetDeviceProcAddr(device, "vkGetQueueCheckpointDataNV");
      this->GetRayTracingCaptureReplayShaderGroupHandlesKHR = (PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR) NextGetDeviceProcAddr(device, "vkGetRayTracingCaptureReplayShaderGroupHandlesKHR");
      this->GetRayTracingShaderGroupHandlesKHR = (PFN_vkGetRayTracingShaderGroupHandlesKHR) NextGetDeviceProcAddr(device, "vkGetRayTracingShaderGroupHandlesKHR");
      this->GetRayTracingShaderGroupHandlesNV = (PFN_vkGetRayTracingShaderGroupHandlesNV) NextGetDeviceProcAddr(device, "vkGetRayTracingShaderGroupHandlesNV");
      this->GetRayTracingShaderGroupStackSizeKHR = (PFN_vkGetRayTracingShaderGroupStackSizeKHR) NextGetDeviceProcAddr(device, "vkGetRayTracingShaderGroupStackSizeKHR");
      this->GetRefreshCycleDurationGOOGLE = (PFN_vkGetRefreshCycleDurationGOOGLE) NextGetDeviceProcAddr(device, "vkGetRefreshCycleDurationGOOGLE");
      this->GetRenderAreaGranularity = (PFN_vkGetRenderAreaGranularity) NextGetDeviceProcAddr(device, "vkGetRenderAreaGranularity");
      this->GetRenderingAreaGranularityKHR = (PFN_vkGetRenderingAreaGranularityKHR) NextGetDeviceProcAddr(device, "vkGetRenderingAreaGranularityKHR");
      this->GetSamplerOpaqueCaptureDescriptorDataEXT = (PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT) NextGetDeviceProcAddr(device, "vkGetSamplerOpaqueCaptureDescriptorDataEXT");
#ifdef VK_USE_PLATFORM_SCREEN_QNX
      this->GetScreenBufferPropertiesQNX = (PFN_vkGetScreenBufferPropertiesQNX) NextGetDeviceProcAddr(device, "vkGetScreenBufferPropertiesQNX");
#endif
      this->GetSemaphoreCounterValue = (PFN_vkGetSemaphoreCounterValue) NextGetDeviceProcAddr(device, "vkGetSemaphoreCounterValue");
      this->GetSemaphoreCounterValueKHR = (PFN_vkGetSemaphoreCounterValueKHR) NextGetDeviceProcAddr(device, "vkGetSemaphoreCounterValueKHR");
      this->GetSemaphoreFdKHR = (PFN_vkGetSemaphoreFdKHR) NextGetDeviceProcAddr(device, "vkGetSemaphoreFdKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->GetSemaphoreWin32HandleKHR = (PFN_vkGetSemaphoreWin32HandleKHR) NextGetDeviceProcAddr(device, "vkGetSemaphoreWin32HandleKHR");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->GetSemaphoreZirconHandleFUCHSIA = (PFN_vkGetSemaphoreZirconHandleFUCHSIA) NextGetDeviceProcAddr(device, "vkGetSemaphoreZirconHandleFUCHSIA");
#endif
      this->GetShaderBinaryDataEXT = (PFN_vkGetShaderBinaryDataEXT) NextGetDeviceProcAddr(device, "vkGetShaderBinaryDataEXT");
      this->GetShaderInfoAMD = (PFN_vkGetShaderInfoAMD) NextGetDeviceProcAddr(device, "vkGetShaderInfoAMD");
      this->GetShaderModuleCreateInfoIdentifierEXT = (PFN_vkGetShaderModuleCreateInfoIdentifierEXT) NextGetDeviceProcAddr(device, "vkGetShaderModuleCreateInfoIdentifierEXT");
      this->GetShaderModuleIdentifierEXT = (PFN_vkGetShaderModuleIdentifierEXT) NextGetDeviceProcAddr(device, "vkGetShaderModuleIdentifierEXT");
      this->GetSwapchainCounterEXT = (PFN_vkGetSwapchainCounterEXT) NextGetDeviceProcAddr(device, "vkGetSwapchainCounterEXT");
      this->GetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR) NextGetDeviceProcAddr(device, "vkGetSwapchainImagesKHR");
      this->GetSwapchainStatusKHR = (PFN_vkGetSwapchainStatusKHR) NextGetDeviceProcAddr(device, "vkGetSwapchainStatusKHR");
      this->GetTensorMemoryRequirementsARM = (PFN_vkGetTensorMemoryRequirementsARM) NextGetDeviceProcAddr(device, "vkGetTensorMemoryRequirementsARM");
      this->GetTensorOpaqueCaptureDescriptorDataARM = (PFN_vkGetTensorOpaqueCaptureDescriptorDataARM) NextGetDeviceProcAddr(device, "vkGetTensorOpaqueCaptureDescriptorDataARM");
      this->GetTensorViewOpaqueCaptureDescriptorDataARM = (PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM) NextGetDeviceProcAddr(device, "vkGetTensorViewOpaqueCaptureDescriptorDataARM");
      this->GetValidationCacheDataEXT = (PFN_vkGetValidationCacheDataEXT) NextGetDeviceProcAddr(device, "vkGetValidationCacheDataEXT");
      this->GetVideoSessionMemoryRequirementsKHR = (PFN_vkGetVideoSessionMemoryRequirementsKHR) NextGetDeviceProcAddr(device, "vkGetVideoSessionMemoryRequirementsKHR");
      this->ImportFenceFdKHR = (PFN_vkImportFenceFdKHR) NextGetDeviceProcAddr(device, "vkImportFenceFdKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->ImportFenceWin32HandleKHR = (PFN_vkImportFenceWin32HandleKHR) NextGetDeviceProcAddr(device, "vkImportFenceWin32HandleKHR");
#endif
      this->ImportSemaphoreFdKHR = (PFN_vkImportSemaphoreFdKHR) NextGetDeviceProcAddr(device, "vkImportSemaphoreFdKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->ImportSemaphoreWin32HandleKHR = (PFN_vkImportSemaphoreWin32HandleKHR) NextGetDeviceProcAddr(device, "vkImportSemaphoreWin32HandleKHR");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->ImportSemaphoreZirconHandleFUCHSIA = (PFN_vkImportSemaphoreZirconHandleFUCHSIA) NextGetDeviceProcAddr(device, "vkImportSemaphoreZirconHandleFUCHSIA");
#endif
      this->InitializePerformanceApiINTEL = (PFN_vkInitializePerformanceApiINTEL) NextGetDeviceProcAddr(device, "vkInitializePerformanceApiINTEL");
      this->InvalidateMappedMemoryRanges = (PFN_vkInvalidateMappedMemoryRanges) NextGetDeviceProcAddr(device, "vkInvalidateMappedMemoryRanges");
      this->LatencySleepNV = (PFN_vkLatencySleepNV) NextGetDeviceProcAddr(device, "vkLatencySleepNV");
      this->MapMemory = (PFN_vkMapMemory) NextGetDeviceProcAddr(device, "vkMapMemory");
      this->MapMemory2KHR = (PFN_vkMapMemory2KHR) NextGetDeviceProcAddr(device, "vkMapMemory2KHR");
      this->MergePipelineCaches = (PFN_vkMergePipelineCaches) NextGetDeviceProcAddr(device, "vkMergePipelineCaches");
      this->MergeValidationCachesEXT = (PFN_vkMergeValidationCachesEXT) NextGetDeviceProcAddr(device, "vkMergeValidationCachesEXT");
      this->QueueBeginDebugUtilsLabelEXT = (PFN_vkQueueBeginDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkQueueBeginDebugUtilsLabelEXT");
      this->QueueBindSparse = (PFN_vkQueueBindSparse) NextGetDeviceProcAddr(device, "vkQueueBindSparse");
      this->QueueEndDebugUtilsLabelEXT = (PFN_vkQueueEndDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkQueueEndDebugUtilsLabelEXT");
      this->QueueInsertDebugUtilsLabelEXT = (PFN_vkQueueInsertDebugUtilsLabelEXT) NextGetDeviceProcAddr(device, "vkQueueInsertDebugUtilsLabelEXT");
      this->QueueNotifyOutOfBandNV = (PFN_vkQueueNotifyOutOfBandNV) NextGetDeviceProcAddr(device, "vkQueueNotifyOutOfBandNV");
      this->QueuePresentKHR = (PFN_vkQueuePresentKHR) NextGetDeviceProcAddr(device, "vkQueuePresentKHR");
      this->QueueSetPerformanceConfigurationINTEL = (PFN_vkQueueSetPerformanceConfigurationINTEL) NextGetDeviceProcAddr(device, "vkQueueSetPerformanceConfigurationINTEL");
      this->QueueSubmit = (PFN_vkQueueSubmit) NextGetDeviceProcAddr(device, "vkQueueSubmit");
      this->QueueSubmit2 = (PFN_vkQueueSubmit2) NextGetDeviceProcAddr(device, "vkQueueSubmit2");
      this->QueueSubmit2KHR = (PFN_vkQueueSubmit2KHR) NextGetDeviceProcAddr(device, "vkQueueSubmit2KHR");
      this->QueueWaitIdle = (PFN_vkQueueWaitIdle) NextGetDeviceProcAddr(device, "vkQueueWaitIdle");
      this->RegisterDeviceEventEXT = (PFN_vkRegisterDeviceEventEXT) NextGetDeviceProcAddr(device, "vkRegisterDeviceEventEXT");
      this->RegisterDisplayEventEXT = (PFN_vkRegisterDisplayEventEXT) NextGetDeviceProcAddr(device, "vkRegisterDisplayEventEXT");
      this->ReleaseCapturedPipelineDataKHR = (PFN_vkReleaseCapturedPipelineDataKHR) NextGetDeviceProcAddr(device, "vkReleaseCapturedPipelineDataKHR");
#ifdef VK_USE_PLATFORM_WIN32_KHR
      this->ReleaseFullScreenExclusiveModeEXT = (PFN_vkReleaseFullScreenExclusiveModeEXT) NextGetDeviceProcAddr(device, "vkReleaseFullScreenExclusiveModeEXT");
#endif
      this->ReleasePerformanceConfigurationINTEL = (PFN_vkReleasePerformanceConfigurationINTEL) NextGetDeviceProcAddr(device, "vkReleasePerformanceConfigurationINTEL");
      this->ReleaseProfilingLockKHR = (PFN_vkReleaseProfilingLockKHR) NextGetDeviceProcAddr(device, "vkReleaseProfilingLockKHR");
      this->ReleaseSwapchainImagesEXT = (PFN_vkReleaseSwapchainImagesEXT) NextGetDeviceProcAddr(device, "vkReleaseSwapchainImagesEXT");
      this->ReleaseSwapchainImagesKHR = (PFN_vkReleaseSwapchainImagesKHR) NextGetDeviceProcAddr(device, "vkReleaseSwapchainImagesKHR");
      this->ResetCommandBuffer = (PFN_vkResetCommandBuffer) NextGetDeviceProcAddr(device, "vkResetCommandBuffer");
      this->ResetCommandPool = (PFN_vkResetCommandPool) NextGetDeviceProcAddr(device, "vkResetCommandPool");
      this->ResetDescriptorPool = (PFN_vkResetDescriptorPool) NextGetDeviceProcAddr(device, "vkResetDescriptorPool");
      this->ResetEvent = (PFN_vkResetEvent) NextGetDeviceProcAddr(device, "vkResetEvent");
      this->ResetFences = (PFN_vkResetFences) NextGetDeviceProcAddr(device, "vkResetFences");
      this->ResetQueryPool = (PFN_vkResetQueryPool) NextGetDeviceProcAddr(device, "vkResetQueryPool");
      this->ResetQueryPoolEXT = (PFN_vkResetQueryPoolEXT) NextGetDeviceProcAddr(device, "vkResetQueryPoolEXT");
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->SetBufferCollectionBufferConstraintsFUCHSIA = (PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA) NextGetDeviceProcAddr(device, "vkSetBufferCollectionBufferConstraintsFUCHSIA");
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
      this->SetBufferCollectionImageConstraintsFUCHSIA = (PFN_vkSetBufferCollectionImageConstraintsFUCHSIA) NextGetDeviceProcAddr(device, "vkSetBufferCollectionImageConstraintsFUCHSIA");
#endif
      this->SetDebugUtilsObjectNameEXT = (PFN_vkSetDebugUtilsObjectNameEXT) NextGetDeviceProcAddr(device, "vkSetDebugUtilsObjectNameEXT");
      this->SetDebugUtilsObjectTagEXT = (PFN_vkSetDebugUtilsObjectTagEXT) NextGetDeviceProcAddr(device, "vkSetDebugUtilsObjectTagEXT");
      this->SetDeviceMemoryPriorityEXT = (PFN_vkSetDeviceMemoryPriorityEXT) NextGetDeviceProcAddr(device, "vkSetDeviceMemoryPriorityEXT");
      this->SetEvent = (PFN_vkSetEvent) NextGetDeviceProcAddr(device, "vkSetEvent");
      this->SetHdrMetadataEXT = (PFN_vkSetHdrMetadataEXT) NextGetDeviceProcAddr(device, "vkSetHdrMetadataEXT");
      this->SetLatencyMarkerNV = (PFN_vkSetLatencyMarkerNV) NextGetDeviceProcAddr(device, "vkSetLatencyMarkerNV");
      this->SetLatencySleepModeNV = (PFN_vkSetLatencySleepModeNV) NextGetDeviceProcAddr(device, "vkSetLatencySleepModeNV");
      this->SetLocalDimmingAMD = (PFN_vkSetLocalDimmingAMD) NextGetDeviceProcAddr(device, "vkSetLocalDimmingAMD");
      this->SetPrivateData = (PFN_vkSetPrivateData) NextGetDeviceProcAddr(device, "vkSetPrivateData");
      this->SetPrivateDataEXT = (PFN_vkSetPrivateDataEXT) NextGetDeviceProcAddr(device, "vkSetPrivateDataEXT");
      this->SignalSemaphore = (PFN_vkSignalSemaphore) NextGetDeviceProcAddr(device, "vkSignalSemaphore");
      this->SignalSemaphoreKHR = (PFN_vkSignalSemaphoreKHR) NextGetDeviceProcAddr(device, "vkSignalSemaphoreKHR");
      this->TransitionImageLayoutEXT = (PFN_vkTransitionImageLayoutEXT) NextGetDeviceProcAddr(device, "vkTransitionImageLayoutEXT");
      this->TrimCommandPool = (PFN_vkTrimCommandPool) NextGetDeviceProcAddr(device, "vkTrimCommandPool");
      this->TrimCommandPoolKHR = (PFN_vkTrimCommandPoolKHR) NextGetDeviceProcAddr(device, "vkTrimCommandPoolKHR");
      this->UninitializePerformanceApiINTEL = (PFN_vkUninitializePerformanceApiINTEL) NextGetDeviceProcAddr(device, "vkUninitializePerformanceApiINTEL");
      this->UnmapMemory = (PFN_vkUnmapMemory) NextGetDeviceProcAddr(device, "vkUnmapMemory");
      this->UnmapMemory2KHR = (PFN_vkUnmapMemory2KHR) NextGetDeviceProcAddr(device, "vkUnmapMemory2KHR");
      this->UpdateDescriptorSetWithTemplate = (PFN_vkUpdateDescriptorSetWithTemplate) NextGetDeviceProcAddr(device, "vkUpdateDescriptorSetWithTemplate");
      this->UpdateDescriptorSetWithTemplateKHR = (PFN_vkUpdateDescriptorSetWithTemplateKHR) NextGetDeviceProcAddr(device, "vkUpdateDescriptorSetWithTemplateKHR");
      this->UpdateDescriptorSets = (PFN_vkUpdateDescriptorSets) NextGetDeviceProcAddr(device, "vkUpdateDescriptorSets");
      this->UpdateIndirectExecutionSetPipelineEXT = (PFN_vkUpdateIndirectExecutionSetPipelineEXT) NextGetDeviceProcAddr(device, "vkUpdateIndirectExecutionSetPipelineEXT");
      this->UpdateIndirectExecutionSetShaderEXT = (PFN_vkUpdateIndirectExecutionSetShaderEXT) NextGetDeviceProcAddr(device, "vkUpdateIndirectExecutionSetShaderEXT");
      this->UpdateVideoSessionParametersKHR = (PFN_vkUpdateVideoSessionParametersKHR) NextGetDeviceProcAddr(device, "vkUpdateVideoSessionParametersKHR");
      this->WaitForFences = (PFN_vkWaitForFences) NextGetDeviceProcAddr(device, "vkWaitForFences");
      this->WaitForPresent2KHR = (PFN_vkWaitForPresent2KHR) NextGetDeviceProcAddr(device, "vkWaitForPresent2KHR");
      this->WaitForPresentKHR = (PFN_vkWaitForPresentKHR) NextGetDeviceProcAddr(device, "vkWaitForPresentKHR");
      this->WaitSemaphores = (PFN_vkWaitSemaphores) NextGetDeviceProcAddr(device, "vkWaitSemaphores");
      this->WaitSemaphoresKHR = (PFN_vkWaitSemaphoresKHR) NextGetDeviceProcAddr(device, "vkWaitSemaphoresKHR");
      this->WriteAccelerationStructuresPropertiesKHR = (PFN_vkWriteAccelerationStructuresPropertiesKHR) NextGetDeviceProcAddr(device, "vkWriteAccelerationStructuresPropertiesKHR");
      this->WriteMicromapsPropertiesEXT = (PFN_vkWriteMicromapsPropertiesEXT) NextGetDeviceProcAddr(device, "vkWriteMicromapsPropertiesEXT");
    }

    mutable uint64_t UserData = 0;
    VkDevice Device;
    VkPhysicalDevice PhysicalDevice;
    const VkPhysicalDeviceDispatch* pPhysicalDeviceDispatch;
    std::vector<VkDeviceQueueCreateInfo> DeviceQueueInfos;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkAcquireFullScreenExclusiveModeEXT AcquireFullScreenExclusiveModeEXT;
#endif
    PFN_vkAcquireNextImage2KHR AcquireNextImage2KHR;
    PFN_vkAcquireNextImageKHR AcquireNextImageKHR;
    PFN_vkAcquirePerformanceConfigurationINTEL AcquirePerformanceConfigurationINTEL;
    PFN_vkAcquireProfilingLockKHR AcquireProfilingLockKHR;
    PFN_vkAllocateCommandBuffers _RealAllocateCommandBuffers;
    PFN_vkAllocateCommandBuffers AllocateCommandBuffers;
    PFN_vkAllocateDescriptorSets AllocateDescriptorSets;
    PFN_vkAllocateMemory AllocateMemory;
    PFN_vkAntiLagUpdateAMD AntiLagUpdateAMD;
    PFN_vkBeginCommandBuffer BeginCommandBuffer;
    PFN_vkBindAccelerationStructureMemoryNV BindAccelerationStructureMemoryNV;
    PFN_vkBindBufferMemory BindBufferMemory;
    PFN_vkBindBufferMemory2 BindBufferMemory2;
    PFN_vkBindBufferMemory2KHR BindBufferMemory2KHR;
    PFN_vkBindDataGraphPipelineSessionMemoryARM BindDataGraphPipelineSessionMemoryARM;
    PFN_vkBindImageMemory BindImageMemory;
    PFN_vkBindImageMemory2 BindImageMemory2;
    PFN_vkBindImageMemory2KHR BindImageMemory2KHR;
    PFN_vkBindOpticalFlowSessionImageNV BindOpticalFlowSessionImageNV;
    PFN_vkBindTensorMemoryARM BindTensorMemoryARM;
    PFN_vkBindVideoSessionMemoryKHR BindVideoSessionMemoryKHR;
    PFN_vkBuildAccelerationStructuresKHR BuildAccelerationStructuresKHR;
    PFN_vkBuildMicromapsEXT BuildMicromapsEXT;
    PFN_vkCmdBeginConditionalRenderingEXT CmdBeginConditionalRenderingEXT;
    PFN_vkCmdBeginDebugUtilsLabelEXT CmdBeginDebugUtilsLabelEXT;
    PFN_vkCmdBeginPerTileExecutionQCOM CmdBeginPerTileExecutionQCOM;
    PFN_vkCmdBeginQuery CmdBeginQuery;
    PFN_vkCmdBeginQueryIndexedEXT CmdBeginQueryIndexedEXT;
    PFN_vkCmdBeginRenderPass CmdBeginRenderPass;
    PFN_vkCmdBeginRenderPass2 CmdBeginRenderPass2;
    PFN_vkCmdBeginRenderPass2KHR CmdBeginRenderPass2KHR;
    PFN_vkCmdBeginRendering CmdBeginRendering;
    PFN_vkCmdBeginRenderingKHR CmdBeginRenderingKHR;
    PFN_vkCmdBeginTransformFeedbackEXT CmdBeginTransformFeedbackEXT;
    PFN_vkCmdBeginVideoCodingKHR CmdBeginVideoCodingKHR;
    PFN_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT CmdBindDescriptorBufferEmbeddedSamplers2EXT;
    PFN_vkCmdBindDescriptorBufferEmbeddedSamplersEXT CmdBindDescriptorBufferEmbeddedSamplersEXT;
    PFN_vkCmdBindDescriptorBuffersEXT CmdBindDescriptorBuffersEXT;
    PFN_vkCmdBindDescriptorSets CmdBindDescriptorSets;
    PFN_vkCmdBindDescriptorSets2KHR CmdBindDescriptorSets2KHR;
    PFN_vkCmdBindIndexBuffer CmdBindIndexBuffer;
    PFN_vkCmdBindIndexBuffer2KHR CmdBindIndexBuffer2KHR;
    PFN_vkCmdBindInvocationMaskHUAWEI CmdBindInvocationMaskHUAWEI;
    PFN_vkCmdBindPipeline CmdBindPipeline;
    PFN_vkCmdBindPipelineShaderGroupNV CmdBindPipelineShaderGroupNV;
    PFN_vkCmdBindShadersEXT CmdBindShadersEXT;
    PFN_vkCmdBindShadingRateImageNV CmdBindShadingRateImageNV;
    PFN_vkCmdBindTileMemoryQCOM CmdBindTileMemoryQCOM;
    PFN_vkCmdBindTransformFeedbackBuffersEXT CmdBindTransformFeedbackBuffersEXT;
    PFN_vkCmdBindVertexBuffers CmdBindVertexBuffers;
    PFN_vkCmdBindVertexBuffers2 CmdBindVertexBuffers2;
    PFN_vkCmdBindVertexBuffers2EXT CmdBindVertexBuffers2EXT;
    PFN_vkCmdBlitImage CmdBlitImage;
    PFN_vkCmdBlitImage2 CmdBlitImage2;
    PFN_vkCmdBlitImage2KHR CmdBlitImage2KHR;
    PFN_vkCmdBuildAccelerationStructureNV CmdBuildAccelerationStructureNV;
    PFN_vkCmdBuildAccelerationStructuresIndirectKHR CmdBuildAccelerationStructuresIndirectKHR;
    PFN_vkCmdBuildAccelerationStructuresKHR CmdBuildAccelerationStructuresKHR;
    PFN_vkCmdBuildClusterAccelerationStructureIndirectNV CmdBuildClusterAccelerationStructureIndirectNV;
    PFN_vkCmdBuildMicromapsEXT CmdBuildMicromapsEXT;
    PFN_vkCmdBuildPartitionedAccelerationStructuresNV CmdBuildPartitionedAccelerationStructuresNV;
    PFN_vkCmdClearAttachments CmdClearAttachments;
    PFN_vkCmdClearColorImage CmdClearColorImage;
    PFN_vkCmdClearDepthStencilImage CmdClearDepthStencilImage;
    PFN_vkCmdControlVideoCodingKHR CmdControlVideoCodingKHR;
    PFN_vkCmdConvertCooperativeVectorMatrixNV CmdConvertCooperativeVectorMatrixNV;
    PFN_vkCmdCopyAccelerationStructureKHR CmdCopyAccelerationStructureKHR;
    PFN_vkCmdCopyAccelerationStructureNV CmdCopyAccelerationStructureNV;
    PFN_vkCmdCopyAccelerationStructureToMemoryKHR CmdCopyAccelerationStructureToMemoryKHR;
    PFN_vkCmdCopyBuffer CmdCopyBuffer;
    PFN_vkCmdCopyBuffer2 CmdCopyBuffer2;
    PFN_vkCmdCopyBuffer2KHR CmdCopyBuffer2KHR;
    PFN_vkCmdCopyBufferToImage CmdCopyBufferToImage;
    PFN_vkCmdCopyBufferToImage2 CmdCopyBufferToImage2;
    PFN_vkCmdCopyBufferToImage2KHR CmdCopyBufferToImage2KHR;
    PFN_vkCmdCopyImage CmdCopyImage;
    PFN_vkCmdCopyImage2 CmdCopyImage2;
    PFN_vkCmdCopyImage2KHR CmdCopyImage2KHR;
    PFN_vkCmdCopyImageToBuffer CmdCopyImageToBuffer;
    PFN_vkCmdCopyImageToBuffer2 CmdCopyImageToBuffer2;
    PFN_vkCmdCopyImageToBuffer2KHR CmdCopyImageToBuffer2KHR;
    PFN_vkCmdCopyMemoryIndirectNV CmdCopyMemoryIndirectNV;
    PFN_vkCmdCopyMemoryToAccelerationStructureKHR CmdCopyMemoryToAccelerationStructureKHR;
    PFN_vkCmdCopyMemoryToImageIndirectNV CmdCopyMemoryToImageIndirectNV;
    PFN_vkCmdCopyMemoryToMicromapEXT CmdCopyMemoryToMicromapEXT;
    PFN_vkCmdCopyMicromapEXT CmdCopyMicromapEXT;
    PFN_vkCmdCopyMicromapToMemoryEXT CmdCopyMicromapToMemoryEXT;
    PFN_vkCmdCopyQueryPoolResults CmdCopyQueryPoolResults;
    PFN_vkCmdCopyTensorARM CmdCopyTensorARM;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCmdCudaLaunchKernelNV CmdCudaLaunchKernelNV;
#endif
    PFN_vkCmdDebugMarkerBeginEXT CmdDebugMarkerBeginEXT;
    PFN_vkCmdDebugMarkerEndEXT CmdDebugMarkerEndEXT;
    PFN_vkCmdDebugMarkerInsertEXT CmdDebugMarkerInsertEXT;
    PFN_vkCmdDecodeVideoKHR CmdDecodeVideoKHR;
    PFN_vkCmdDecompressMemoryIndirectCountNV CmdDecompressMemoryIndirectCountNV;
    PFN_vkCmdDecompressMemoryNV CmdDecompressMemoryNV;
    PFN_vkCmdDispatch CmdDispatch;
    PFN_vkCmdDispatchBase CmdDispatchBase;
    PFN_vkCmdDispatchBaseKHR CmdDispatchBaseKHR;
    PFN_vkCmdDispatchDataGraphARM CmdDispatchDataGraphARM;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCmdDispatchGraphAMDX CmdDispatchGraphAMDX;
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCmdDispatchGraphIndirectAMDX CmdDispatchGraphIndirectAMDX;
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCmdDispatchGraphIndirectCountAMDX CmdDispatchGraphIndirectCountAMDX;
#endif
    PFN_vkCmdDispatchIndirect CmdDispatchIndirect;
    PFN_vkCmdDispatchTileQCOM CmdDispatchTileQCOM;
    PFN_vkCmdDraw CmdDraw;
    PFN_vkCmdDrawClusterHUAWEI CmdDrawClusterHUAWEI;
    PFN_vkCmdDrawClusterIndirectHUAWEI CmdDrawClusterIndirectHUAWEI;
    PFN_vkCmdDrawIndexed CmdDrawIndexed;
    PFN_vkCmdDrawIndexedIndirect CmdDrawIndexedIndirect;
    PFN_vkCmdDrawIndexedIndirectCount CmdDrawIndexedIndirectCount;
    PFN_vkCmdDrawIndexedIndirectCountAMD CmdDrawIndexedIndirectCountAMD;
    PFN_vkCmdDrawIndexedIndirectCountKHR CmdDrawIndexedIndirectCountKHR;
    PFN_vkCmdDrawIndirect CmdDrawIndirect;
    PFN_vkCmdDrawIndirectByteCountEXT CmdDrawIndirectByteCountEXT;
    PFN_vkCmdDrawIndirectCount CmdDrawIndirectCount;
    PFN_vkCmdDrawIndirectCountAMD CmdDrawIndirectCountAMD;
    PFN_vkCmdDrawIndirectCountKHR CmdDrawIndirectCountKHR;
    PFN_vkCmdDrawMeshTasksEXT CmdDrawMeshTasksEXT;
    PFN_vkCmdDrawMeshTasksIndirectCountEXT CmdDrawMeshTasksIndirectCountEXT;
    PFN_vkCmdDrawMeshTasksIndirectCountNV CmdDrawMeshTasksIndirectCountNV;
    PFN_vkCmdDrawMeshTasksIndirectEXT CmdDrawMeshTasksIndirectEXT;
    PFN_vkCmdDrawMeshTasksIndirectNV CmdDrawMeshTasksIndirectNV;
    PFN_vkCmdDrawMeshTasksNV CmdDrawMeshTasksNV;
    PFN_vkCmdDrawMultiEXT CmdDrawMultiEXT;
    PFN_vkCmdDrawMultiIndexedEXT CmdDrawMultiIndexedEXT;
    PFN_vkCmdEncodeVideoKHR CmdEncodeVideoKHR;
    PFN_vkCmdEndConditionalRenderingEXT CmdEndConditionalRenderingEXT;
    PFN_vkCmdEndDebugUtilsLabelEXT CmdEndDebugUtilsLabelEXT;
    PFN_vkCmdEndPerTileExecutionQCOM CmdEndPerTileExecutionQCOM;
    PFN_vkCmdEndQuery CmdEndQuery;
    PFN_vkCmdEndQueryIndexedEXT CmdEndQueryIndexedEXT;
    PFN_vkCmdEndRenderPass CmdEndRenderPass;
    PFN_vkCmdEndRenderPass2 CmdEndRenderPass2;
    PFN_vkCmdEndRenderPass2KHR CmdEndRenderPass2KHR;
    PFN_vkCmdEndRendering CmdEndRendering;
    PFN_vkCmdEndRendering2EXT CmdEndRendering2EXT;
    PFN_vkCmdEndRenderingKHR CmdEndRenderingKHR;
    PFN_vkCmdEndTransformFeedbackEXT CmdEndTransformFeedbackEXT;
    PFN_vkCmdEndVideoCodingKHR CmdEndVideoCodingKHR;
    PFN_vkCmdExecuteCommands CmdExecuteCommands;
    PFN_vkCmdExecuteGeneratedCommandsEXT CmdExecuteGeneratedCommandsEXT;
    PFN_vkCmdExecuteGeneratedCommandsNV CmdExecuteGeneratedCommandsNV;
    PFN_vkCmdFillBuffer CmdFillBuffer;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCmdInitializeGraphScratchMemoryAMDX CmdInitializeGraphScratchMemoryAMDX;
#endif
    PFN_vkCmdInsertDebugUtilsLabelEXT CmdInsertDebugUtilsLabelEXT;
    PFN_vkCmdNextSubpass CmdNextSubpass;
    PFN_vkCmdNextSubpass2 CmdNextSubpass2;
    PFN_vkCmdNextSubpass2KHR CmdNextSubpass2KHR;
    PFN_vkCmdOpticalFlowExecuteNV CmdOpticalFlowExecuteNV;
    PFN_vkCmdPipelineBarrier CmdPipelineBarrier;
    PFN_vkCmdPipelineBarrier2 CmdPipelineBarrier2;
    PFN_vkCmdPipelineBarrier2KHR CmdPipelineBarrier2KHR;
    PFN_vkCmdPreprocessGeneratedCommandsEXT CmdPreprocessGeneratedCommandsEXT;
    PFN_vkCmdPreprocessGeneratedCommandsNV CmdPreprocessGeneratedCommandsNV;
    PFN_vkCmdPushConstants CmdPushConstants;
    PFN_vkCmdPushConstants2KHR CmdPushConstants2KHR;
    PFN_vkCmdPushDescriptorSet2KHR CmdPushDescriptorSet2KHR;
    PFN_vkCmdPushDescriptorSetKHR CmdPushDescriptorSetKHR;
    PFN_vkCmdPushDescriptorSetWithTemplate2KHR CmdPushDescriptorSetWithTemplate2KHR;
    PFN_vkCmdPushDescriptorSetWithTemplateKHR CmdPushDescriptorSetWithTemplateKHR;
    PFN_vkCmdResetEvent CmdResetEvent;
    PFN_vkCmdResetEvent2 CmdResetEvent2;
    PFN_vkCmdResetEvent2KHR CmdResetEvent2KHR;
    PFN_vkCmdResetQueryPool CmdResetQueryPool;
    PFN_vkCmdResolveImage CmdResolveImage;
    PFN_vkCmdResolveImage2 CmdResolveImage2;
    PFN_vkCmdResolveImage2KHR CmdResolveImage2KHR;
    PFN_vkCmdSetAlphaToCoverageEnableEXT CmdSetAlphaToCoverageEnableEXT;
    PFN_vkCmdSetAlphaToOneEnableEXT CmdSetAlphaToOneEnableEXT;
    PFN_vkCmdSetAttachmentFeedbackLoopEnableEXT CmdSetAttachmentFeedbackLoopEnableEXT;
    PFN_vkCmdSetBlendConstants CmdSetBlendConstants;
    PFN_vkCmdSetCheckpointNV CmdSetCheckpointNV;
    PFN_vkCmdSetCoarseSampleOrderNV CmdSetCoarseSampleOrderNV;
    PFN_vkCmdSetColorBlendAdvancedEXT CmdSetColorBlendAdvancedEXT;
    PFN_vkCmdSetColorBlendEnableEXT CmdSetColorBlendEnableEXT;
    PFN_vkCmdSetColorBlendEquationEXT CmdSetColorBlendEquationEXT;
    PFN_vkCmdSetColorWriteEnableEXT CmdSetColorWriteEnableEXT;
    PFN_vkCmdSetColorWriteMaskEXT CmdSetColorWriteMaskEXT;
    PFN_vkCmdSetConservativeRasterizationModeEXT CmdSetConservativeRasterizationModeEXT;
    PFN_vkCmdSetCoverageModulationModeNV CmdSetCoverageModulationModeNV;
    PFN_vkCmdSetCoverageModulationTableEnableNV CmdSetCoverageModulationTableEnableNV;
    PFN_vkCmdSetCoverageModulationTableNV CmdSetCoverageModulationTableNV;
    PFN_vkCmdSetCoverageReductionModeNV CmdSetCoverageReductionModeNV;
    PFN_vkCmdSetCoverageToColorEnableNV CmdSetCoverageToColorEnableNV;
    PFN_vkCmdSetCoverageToColorLocationNV CmdSetCoverageToColorLocationNV;
    PFN_vkCmdSetCullMode CmdSetCullMode;
    PFN_vkCmdSetCullModeEXT CmdSetCullModeEXT;
    PFN_vkCmdSetDepthBias CmdSetDepthBias;
    PFN_vkCmdSetDepthBias2EXT CmdSetDepthBias2EXT;
    PFN_vkCmdSetDepthBiasEnable CmdSetDepthBiasEnable;
    PFN_vkCmdSetDepthBiasEnableEXT CmdSetDepthBiasEnableEXT;
    PFN_vkCmdSetDepthBounds CmdSetDepthBounds;
    PFN_vkCmdSetDepthBoundsTestEnable CmdSetDepthBoundsTestEnable;
    PFN_vkCmdSetDepthBoundsTestEnableEXT CmdSetDepthBoundsTestEnableEXT;
    PFN_vkCmdSetDepthClampEnableEXT CmdSetDepthClampEnableEXT;
    PFN_vkCmdSetDepthClampRangeEXT CmdSetDepthClampRangeEXT;
    PFN_vkCmdSetDepthClipEnableEXT CmdSetDepthClipEnableEXT;
    PFN_vkCmdSetDepthClipNegativeOneToOneEXT CmdSetDepthClipNegativeOneToOneEXT;
    PFN_vkCmdSetDepthCompareOp CmdSetDepthCompareOp;
    PFN_vkCmdSetDepthCompareOpEXT CmdSetDepthCompareOpEXT;
    PFN_vkCmdSetDepthTestEnable CmdSetDepthTestEnable;
    PFN_vkCmdSetDepthTestEnableEXT CmdSetDepthTestEnableEXT;
    PFN_vkCmdSetDepthWriteEnable CmdSetDepthWriteEnable;
    PFN_vkCmdSetDepthWriteEnableEXT CmdSetDepthWriteEnableEXT;
    PFN_vkCmdSetDescriptorBufferOffsets2EXT CmdSetDescriptorBufferOffsets2EXT;
    PFN_vkCmdSetDescriptorBufferOffsetsEXT CmdSetDescriptorBufferOffsetsEXT;
    PFN_vkCmdSetDeviceMask CmdSetDeviceMask;
    PFN_vkCmdSetDeviceMaskKHR CmdSetDeviceMaskKHR;
    PFN_vkCmdSetDiscardRectangleEXT CmdSetDiscardRectangleEXT;
    PFN_vkCmdSetDiscardRectangleEnableEXT CmdSetDiscardRectangleEnableEXT;
    PFN_vkCmdSetDiscardRectangleModeEXT CmdSetDiscardRectangleModeEXT;
    PFN_vkCmdSetEvent CmdSetEvent;
    PFN_vkCmdSetEvent2 CmdSetEvent2;
    PFN_vkCmdSetEvent2KHR CmdSetEvent2KHR;
    PFN_vkCmdSetExclusiveScissorEnableNV CmdSetExclusiveScissorEnableNV;
    PFN_vkCmdSetExclusiveScissorNV CmdSetExclusiveScissorNV;
    PFN_vkCmdSetExtraPrimitiveOverestimationSizeEXT CmdSetExtraPrimitiveOverestimationSizeEXT;
    PFN_vkCmdSetFragmentShadingRateEnumNV CmdSetFragmentShadingRateEnumNV;
    PFN_vkCmdSetFragmentShadingRateKHR CmdSetFragmentShadingRateKHR;
    PFN_vkCmdSetFrontFace CmdSetFrontFace;
    PFN_vkCmdSetFrontFaceEXT CmdSetFrontFaceEXT;
    PFN_vkCmdSetLineRasterizationModeEXT CmdSetLineRasterizationModeEXT;
    PFN_vkCmdSetLineStippleEXT CmdSetLineStippleEXT;
    PFN_vkCmdSetLineStippleEnableEXT CmdSetLineStippleEnableEXT;
    PFN_vkCmdSetLineStippleKHR CmdSetLineStippleKHR;
    PFN_vkCmdSetLineWidth CmdSetLineWidth;
    PFN_vkCmdSetLogicOpEXT CmdSetLogicOpEXT;
    PFN_vkCmdSetLogicOpEnableEXT CmdSetLogicOpEnableEXT;
    PFN_vkCmdSetPatchControlPointsEXT CmdSetPatchControlPointsEXT;
    PFN_vkCmdSetPerformanceMarkerINTEL CmdSetPerformanceMarkerINTEL;
    PFN_vkCmdSetPerformanceOverrideINTEL CmdSetPerformanceOverrideINTEL;
    PFN_vkCmdSetPerformanceStreamMarkerINTEL CmdSetPerformanceStreamMarkerINTEL;
    PFN_vkCmdSetPolygonModeEXT CmdSetPolygonModeEXT;
    PFN_vkCmdSetPrimitiveRestartEnable CmdSetPrimitiveRestartEnable;
    PFN_vkCmdSetPrimitiveRestartEnableEXT CmdSetPrimitiveRestartEnableEXT;
    PFN_vkCmdSetPrimitiveTopology CmdSetPrimitiveTopology;
    PFN_vkCmdSetPrimitiveTopologyEXT CmdSetPrimitiveTopologyEXT;
    PFN_vkCmdSetProvokingVertexModeEXT CmdSetProvokingVertexModeEXT;
    PFN_vkCmdSetRasterizationSamplesEXT CmdSetRasterizationSamplesEXT;
    PFN_vkCmdSetRasterizationStreamEXT CmdSetRasterizationStreamEXT;
    PFN_vkCmdSetRasterizerDiscardEnable CmdSetRasterizerDiscardEnable;
    PFN_vkCmdSetRasterizerDiscardEnableEXT CmdSetRasterizerDiscardEnableEXT;
    PFN_vkCmdSetRayTracingPipelineStackSizeKHR CmdSetRayTracingPipelineStackSizeKHR;
    PFN_vkCmdSetRenderingAttachmentLocationsKHR CmdSetRenderingAttachmentLocationsKHR;
    PFN_vkCmdSetRenderingInputAttachmentIndicesKHR CmdSetRenderingInputAttachmentIndicesKHR;
    PFN_vkCmdSetRepresentativeFragmentTestEnableNV CmdSetRepresentativeFragmentTestEnableNV;
    PFN_vkCmdSetSampleLocationsEXT CmdSetSampleLocationsEXT;
    PFN_vkCmdSetSampleLocationsEnableEXT CmdSetSampleLocationsEnableEXT;
    PFN_vkCmdSetSampleMaskEXT CmdSetSampleMaskEXT;
    PFN_vkCmdSetScissor CmdSetScissor;
    PFN_vkCmdSetScissorWithCount CmdSetScissorWithCount;
    PFN_vkCmdSetScissorWithCountEXT CmdSetScissorWithCountEXT;
    PFN_vkCmdSetShadingRateImageEnableNV CmdSetShadingRateImageEnableNV;
    PFN_vkCmdSetStencilCompareMask CmdSetStencilCompareMask;
    PFN_vkCmdSetStencilOp CmdSetStencilOp;
    PFN_vkCmdSetStencilOpEXT CmdSetStencilOpEXT;
    PFN_vkCmdSetStencilReference CmdSetStencilReference;
    PFN_vkCmdSetStencilTestEnable CmdSetStencilTestEnable;
    PFN_vkCmdSetStencilTestEnableEXT CmdSetStencilTestEnableEXT;
    PFN_vkCmdSetStencilWriteMask CmdSetStencilWriteMask;
    PFN_vkCmdSetTessellationDomainOriginEXT CmdSetTessellationDomainOriginEXT;
    PFN_vkCmdSetVertexInputEXT CmdSetVertexInputEXT;
    PFN_vkCmdSetViewport CmdSetViewport;
    PFN_vkCmdSetViewportShadingRatePaletteNV CmdSetViewportShadingRatePaletteNV;
    PFN_vkCmdSetViewportSwizzleNV CmdSetViewportSwizzleNV;
    PFN_vkCmdSetViewportWScalingEnableNV CmdSetViewportWScalingEnableNV;
    PFN_vkCmdSetViewportWScalingNV CmdSetViewportWScalingNV;
    PFN_vkCmdSetViewportWithCount CmdSetViewportWithCount;
    PFN_vkCmdSetViewportWithCountEXT CmdSetViewportWithCountEXT;
    PFN_vkCmdSubpassShadingHUAWEI CmdSubpassShadingHUAWEI;
    PFN_vkCmdTraceRaysIndirect2KHR CmdTraceRaysIndirect2KHR;
    PFN_vkCmdTraceRaysIndirectKHR CmdTraceRaysIndirectKHR;
    PFN_vkCmdTraceRaysKHR CmdTraceRaysKHR;
    PFN_vkCmdTraceRaysNV CmdTraceRaysNV;
    PFN_vkCmdUpdateBuffer CmdUpdateBuffer;
    PFN_vkCmdUpdatePipelineIndirectBufferNV CmdUpdatePipelineIndirectBufferNV;
    PFN_vkCmdWaitEvents CmdWaitEvents;
    PFN_vkCmdWaitEvents2 CmdWaitEvents2;
    PFN_vkCmdWaitEvents2KHR CmdWaitEvents2KHR;
    PFN_vkCmdWriteAccelerationStructuresPropertiesKHR CmdWriteAccelerationStructuresPropertiesKHR;
    PFN_vkCmdWriteAccelerationStructuresPropertiesNV CmdWriteAccelerationStructuresPropertiesNV;
    PFN_vkCmdWriteBufferMarker2AMD CmdWriteBufferMarker2AMD;
    PFN_vkCmdWriteBufferMarkerAMD CmdWriteBufferMarkerAMD;
    PFN_vkCmdWriteMicromapsPropertiesEXT CmdWriteMicromapsPropertiesEXT;
    PFN_vkCmdWriteTimestamp CmdWriteTimestamp;
    PFN_vkCmdWriteTimestamp2 CmdWriteTimestamp2;
    PFN_vkCmdWriteTimestamp2KHR CmdWriteTimestamp2KHR;
    PFN_vkCompileDeferredNV CompileDeferredNV;
    PFN_vkConvertCooperativeVectorMatrixNV ConvertCooperativeVectorMatrixNV;
    PFN_vkCopyAccelerationStructureKHR CopyAccelerationStructureKHR;
    PFN_vkCopyAccelerationStructureToMemoryKHR CopyAccelerationStructureToMemoryKHR;
    PFN_vkCopyImageToImageEXT CopyImageToImageEXT;
    PFN_vkCopyImageToMemoryEXT CopyImageToMemoryEXT;
    PFN_vkCopyMemoryToAccelerationStructureKHR CopyMemoryToAccelerationStructureKHR;
    PFN_vkCopyMemoryToImageEXT CopyMemoryToImageEXT;
    PFN_vkCopyMemoryToMicromapEXT CopyMemoryToMicromapEXT;
    PFN_vkCopyMicromapEXT CopyMicromapEXT;
    PFN_vkCopyMicromapToMemoryEXT CopyMicromapToMemoryEXT;
    PFN_vkCreateAccelerationStructureKHR CreateAccelerationStructureKHR;
    PFN_vkCreateAccelerationStructureNV CreateAccelerationStructureNV;
    PFN_vkCreateBuffer CreateBuffer;
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkCreateBufferCollectionFUCHSIA CreateBufferCollectionFUCHSIA;
#endif
    PFN_vkCreateBufferView CreateBufferView;
    PFN_vkCreateCommandPool CreateCommandPool;
    PFN_vkCreateComputePipelines CreateComputePipelines;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCreateCudaFunctionNV CreateCudaFunctionNV;
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCreateCudaModuleNV CreateCudaModuleNV;
#endif
    PFN_vkCreateDataGraphPipelineSessionARM CreateDataGraphPipelineSessionARM;
    PFN_vkCreateDataGraphPipelinesARM CreateDataGraphPipelinesARM;
    PFN_vkCreateDeferredOperationKHR CreateDeferredOperationKHR;
    PFN_vkCreateDescriptorPool CreateDescriptorPool;
    PFN_vkCreateDescriptorSetLayout CreateDescriptorSetLayout;
    PFN_vkCreateDescriptorUpdateTemplate CreateDescriptorUpdateTemplate;
    PFN_vkCreateDescriptorUpdateTemplateKHR CreateDescriptorUpdateTemplateKHR;
    PFN_vkCreateEvent CreateEvent;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkCreateExecutionGraphPipelinesAMDX CreateExecutionGraphPipelinesAMDX;
#endif
    PFN_vkCreateExternalComputeQueueNV CreateExternalComputeQueueNV;
    PFN_vkCreateFence CreateFence;
    PFN_vkCreateFramebuffer CreateFramebuffer;
    PFN_vkCreateGraphicsPipelines CreateGraphicsPipelines;
    PFN_vkCreateImage CreateImage;
    PFN_vkCreateImageView CreateImageView;
    PFN_vkCreateIndirectCommandsLayoutEXT CreateIndirectCommandsLayoutEXT;
    PFN_vkCreateIndirectCommandsLayoutNV CreateIndirectCommandsLayoutNV;
    PFN_vkCreateIndirectExecutionSetEXT CreateIndirectExecutionSetEXT;
    PFN_vkCreateMicromapEXT CreateMicromapEXT;
    PFN_vkCreateOpticalFlowSessionNV CreateOpticalFlowSessionNV;
    PFN_vkCreatePipelineBinariesKHR CreatePipelineBinariesKHR;
    PFN_vkCreatePipelineCache CreatePipelineCache;
    PFN_vkCreatePipelineLayout CreatePipelineLayout;
    PFN_vkCreatePrivateDataSlot CreatePrivateDataSlot;
    PFN_vkCreatePrivateDataSlotEXT CreatePrivateDataSlotEXT;
    PFN_vkCreateQueryPool CreateQueryPool;
    PFN_vkCreateRayTracingPipelinesKHR CreateRayTracingPipelinesKHR;
    PFN_vkCreateRayTracingPipelinesNV CreateRayTracingPipelinesNV;
    PFN_vkCreateRenderPass CreateRenderPass;
    PFN_vkCreateRenderPass2 CreateRenderPass2;
    PFN_vkCreateRenderPass2KHR CreateRenderPass2KHR;
    PFN_vkCreateSampler CreateSampler;
    PFN_vkCreateSamplerYcbcrConversion CreateSamplerYcbcrConversion;
    PFN_vkCreateSamplerYcbcrConversionKHR CreateSamplerYcbcrConversionKHR;
    PFN_vkCreateSemaphore CreateSemaphore;
    PFN_vkCreateShaderModule CreateShaderModule;
    PFN_vkCreateShadersEXT CreateShadersEXT;
    PFN_vkCreateSharedSwapchainsKHR CreateSharedSwapchainsKHR;
    PFN_vkCreateSwapchainKHR CreateSwapchainKHR;
    PFN_vkCreateTensorARM CreateTensorARM;
    PFN_vkCreateTensorViewARM CreateTensorViewARM;
    PFN_vkCreateValidationCacheEXT CreateValidationCacheEXT;
    PFN_vkCreateVideoSessionKHR CreateVideoSessionKHR;
    PFN_vkCreateVideoSessionParametersKHR CreateVideoSessionParametersKHR;
    PFN_vkDebugMarkerSetObjectNameEXT DebugMarkerSetObjectNameEXT;
    PFN_vkDebugMarkerSetObjectTagEXT DebugMarkerSetObjectTagEXT;
    PFN_vkDeferredOperationJoinKHR DeferredOperationJoinKHR;
    PFN_vkDestroyAccelerationStructureKHR DestroyAccelerationStructureKHR;
    PFN_vkDestroyAccelerationStructureNV DestroyAccelerationStructureNV;
    PFN_vkDestroyBuffer DestroyBuffer;
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkDestroyBufferCollectionFUCHSIA DestroyBufferCollectionFUCHSIA;
#endif
    PFN_vkDestroyBufferView DestroyBufferView;
    PFN_vkDestroyCommandPool DestroyCommandPool;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkDestroyCudaFunctionNV DestroyCudaFunctionNV;
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkDestroyCudaModuleNV DestroyCudaModuleNV;
#endif
    PFN_vkDestroyDataGraphPipelineSessionARM DestroyDataGraphPipelineSessionARM;
    PFN_vkDestroyDeferredOperationKHR DestroyDeferredOperationKHR;
    PFN_vkDestroyDescriptorPool DestroyDescriptorPool;
    PFN_vkDestroyDescriptorSetLayout DestroyDescriptorSetLayout;
    PFN_vkDestroyDescriptorUpdateTemplate DestroyDescriptorUpdateTemplate;
    PFN_vkDestroyDescriptorUpdateTemplateKHR DestroyDescriptorUpdateTemplateKHR;
    PFN_vkDestroyDevice DestroyDevice;
    PFN_vkDestroyEvent DestroyEvent;
    PFN_vkDestroyExternalComputeQueueNV DestroyExternalComputeQueueNV;
    PFN_vkDestroyFence DestroyFence;
    PFN_vkDestroyFramebuffer DestroyFramebuffer;
    PFN_vkDestroyImage DestroyImage;
    PFN_vkDestroyImageView DestroyImageView;
    PFN_vkDestroyIndirectCommandsLayoutEXT DestroyIndirectCommandsLayoutEXT;
    PFN_vkDestroyIndirectCommandsLayoutNV DestroyIndirectCommandsLayoutNV;
    PFN_vkDestroyIndirectExecutionSetEXT DestroyIndirectExecutionSetEXT;
    PFN_vkDestroyMicromapEXT DestroyMicromapEXT;
    PFN_vkDestroyOpticalFlowSessionNV DestroyOpticalFlowSessionNV;
    PFN_vkDestroyPipeline DestroyPipeline;
    PFN_vkDestroyPipelineBinaryKHR DestroyPipelineBinaryKHR;
    PFN_vkDestroyPipelineCache DestroyPipelineCache;
    PFN_vkDestroyPipelineLayout DestroyPipelineLayout;
    PFN_vkDestroyPrivateDataSlot DestroyPrivateDataSlot;
    PFN_vkDestroyPrivateDataSlotEXT DestroyPrivateDataSlotEXT;
    PFN_vkDestroyQueryPool DestroyQueryPool;
    PFN_vkDestroyRenderPass DestroyRenderPass;
    PFN_vkDestroySampler DestroySampler;
    PFN_vkDestroySamplerYcbcrConversion DestroySamplerYcbcrConversion;
    PFN_vkDestroySamplerYcbcrConversionKHR DestroySamplerYcbcrConversionKHR;
    PFN_vkDestroySemaphore DestroySemaphore;
    PFN_vkDestroyShaderEXT DestroyShaderEXT;
    PFN_vkDestroyShaderModule DestroyShaderModule;
    PFN_vkDestroySwapchainKHR DestroySwapchainKHR;
    PFN_vkDestroyTensorARM DestroyTensorARM;
    PFN_vkDestroyTensorViewARM DestroyTensorViewARM;
    PFN_vkDestroyValidationCacheEXT DestroyValidationCacheEXT;
    PFN_vkDestroyVideoSessionKHR DestroyVideoSessionKHR;
    PFN_vkDestroyVideoSessionParametersKHR DestroyVideoSessionParametersKHR;
    PFN_vkDeviceWaitIdle DeviceWaitIdle;
    PFN_vkDisplayPowerControlEXT DisplayPowerControlEXT;
    PFN_vkEndCommandBuffer EndCommandBuffer;
#ifdef VK_USE_PLATFORM_METAL_EXT
    PFN_vkExportMetalObjectsEXT ExportMetalObjectsEXT;
#endif
    PFN_vkFlushMappedMemoryRanges FlushMappedMemoryRanges;
    PFN_vkFreeCommandBuffers _RealFreeCommandBuffers;
    PFN_vkFreeCommandBuffers FreeCommandBuffers;
    PFN_vkFreeDescriptorSets FreeDescriptorSets;
    PFN_vkFreeMemory FreeMemory;
    PFN_vkGetAccelerationStructureBuildSizesKHR GetAccelerationStructureBuildSizesKHR;
    PFN_vkGetAccelerationStructureDeviceAddressKHR GetAccelerationStructureDeviceAddressKHR;
    PFN_vkGetAccelerationStructureHandleNV GetAccelerationStructureHandleNV;
    PFN_vkGetAccelerationStructureMemoryRequirementsNV GetAccelerationStructureMemoryRequirementsNV;
    PFN_vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT GetAccelerationStructureOpaqueCaptureDescriptorDataEXT;
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    PFN_vkGetAndroidHardwareBufferPropertiesANDROID GetAndroidHardwareBufferPropertiesANDROID;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkGetBufferCollectionPropertiesFUCHSIA GetBufferCollectionPropertiesFUCHSIA;
#endif
    PFN_vkGetBufferDeviceAddress GetBufferDeviceAddress;
    PFN_vkGetBufferDeviceAddressEXT GetBufferDeviceAddressEXT;
    PFN_vkGetBufferDeviceAddressKHR GetBufferDeviceAddressKHR;
    PFN_vkGetBufferMemoryRequirements GetBufferMemoryRequirements;
    PFN_vkGetBufferMemoryRequirements2 GetBufferMemoryRequirements2;
    PFN_vkGetBufferMemoryRequirements2KHR GetBufferMemoryRequirements2KHR;
    PFN_vkGetBufferOpaqueCaptureAddress GetBufferOpaqueCaptureAddress;
    PFN_vkGetBufferOpaqueCaptureAddressKHR GetBufferOpaqueCaptureAddressKHR;
    PFN_vkGetBufferOpaqueCaptureDescriptorDataEXT GetBufferOpaqueCaptureDescriptorDataEXT;
    PFN_vkGetCalibratedTimestampsEXT GetCalibratedTimestampsEXT;
    PFN_vkGetCalibratedTimestampsKHR GetCalibratedTimestampsKHR;
    PFN_vkGetClusterAccelerationStructureBuildSizesNV GetClusterAccelerationStructureBuildSizesNV;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkGetCudaModuleCacheNV GetCudaModuleCacheNV;
#endif
    PFN_vkGetDataGraphPipelineAvailablePropertiesARM GetDataGraphPipelineAvailablePropertiesARM;
    PFN_vkGetDataGraphPipelinePropertiesARM GetDataGraphPipelinePropertiesARM;
    PFN_vkGetDataGraphPipelineSessionBindPointRequirementsARM GetDataGraphPipelineSessionBindPointRequirementsARM;
    PFN_vkGetDataGraphPipelineSessionMemoryRequirementsARM GetDataGraphPipelineSessionMemoryRequirementsARM;
    PFN_vkGetDeferredOperationMaxConcurrencyKHR GetDeferredOperationMaxConcurrencyKHR;
    PFN_vkGetDeferredOperationResultKHR GetDeferredOperationResultKHR;
    PFN_vkGetDescriptorEXT GetDescriptorEXT;
    PFN_vkGetDescriptorSetHostMappingVALVE GetDescriptorSetHostMappingVALVE;
    PFN_vkGetDescriptorSetLayoutBindingOffsetEXT GetDescriptorSetLayoutBindingOffsetEXT;
    PFN_vkGetDescriptorSetLayoutHostMappingInfoVALVE GetDescriptorSetLayoutHostMappingInfoVALVE;
    PFN_vkGetDescriptorSetLayoutSizeEXT GetDescriptorSetLayoutSizeEXT;
    PFN_vkGetDescriptorSetLayoutSupport GetDescriptorSetLayoutSupport;
    PFN_vkGetDescriptorSetLayoutSupportKHR GetDescriptorSetLayoutSupportKHR;
    PFN_vkGetDeviceAccelerationStructureCompatibilityKHR GetDeviceAccelerationStructureCompatibilityKHR;
    PFN_vkGetDeviceBufferMemoryRequirements GetDeviceBufferMemoryRequirements;
    PFN_vkGetDeviceBufferMemoryRequirementsKHR GetDeviceBufferMemoryRequirementsKHR;
    PFN_vkGetDeviceFaultInfoEXT GetDeviceFaultInfoEXT;
    PFN_vkGetDeviceGroupPeerMemoryFeatures GetDeviceGroupPeerMemoryFeatures;
    PFN_vkGetDeviceGroupPeerMemoryFeaturesKHR GetDeviceGroupPeerMemoryFeaturesKHR;
    PFN_vkGetDeviceGroupPresentCapabilitiesKHR GetDeviceGroupPresentCapabilitiesKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetDeviceGroupSurfacePresentModes2EXT GetDeviceGroupSurfacePresentModes2EXT;
#endif
    PFN_vkGetDeviceGroupSurfacePresentModesKHR GetDeviceGroupSurfacePresentModesKHR;
    PFN_vkGetDeviceImageMemoryRequirements GetDeviceImageMemoryRequirements;
    PFN_vkGetDeviceImageMemoryRequirementsKHR GetDeviceImageMemoryRequirementsKHR;
    PFN_vkGetDeviceImageSparseMemoryRequirements GetDeviceImageSparseMemoryRequirements;
    PFN_vkGetDeviceImageSparseMemoryRequirementsKHR GetDeviceImageSparseMemoryRequirementsKHR;
    PFN_vkGetDeviceImageSubresourceLayoutKHR GetDeviceImageSubresourceLayoutKHR;
    PFN_vkGetDeviceMemoryCommitment GetDeviceMemoryCommitment;
    PFN_vkGetDeviceMemoryOpaqueCaptureAddress GetDeviceMemoryOpaqueCaptureAddress;
    PFN_vkGetDeviceMemoryOpaqueCaptureAddressKHR GetDeviceMemoryOpaqueCaptureAddressKHR;
    PFN_vkGetDeviceMicromapCompatibilityEXT GetDeviceMicromapCompatibilityEXT;
    PFN_vkGetDeviceProcAddr GetDeviceProcAddr;
    PFN_vkGetDeviceQueue GetDeviceQueue;
    PFN_vkGetDeviceQueue2 GetDeviceQueue2;
    PFN_vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI;
    PFN_vkGetDeviceTensorMemoryRequirementsARM GetDeviceTensorMemoryRequirementsARM;
    PFN_vkGetDynamicRenderingTilePropertiesQCOM GetDynamicRenderingTilePropertiesQCOM;
    PFN_vkGetEncodedVideoSessionParametersKHR GetEncodedVideoSessionParametersKHR;
    PFN_vkGetEventStatus GetEventStatus;
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkGetExecutionGraphPipelineNodeIndexAMDX GetExecutionGraphPipelineNodeIndexAMDX;
#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
    PFN_vkGetExecutionGraphPipelineScratchSizeAMDX GetExecutionGraphPipelineScratchSizeAMDX;
#endif
    PFN_vkGetExternalComputeQueueDataNV GetExternalComputeQueueDataNV;
    PFN_vkGetFenceFdKHR GetFenceFdKHR;
    PFN_vkGetFenceStatus GetFenceStatus;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetFenceWin32HandleKHR GetFenceWin32HandleKHR;
#endif
    PFN_vkGetFramebufferTilePropertiesQCOM GetFramebufferTilePropertiesQCOM;
    PFN_vkGetGeneratedCommandsMemoryRequirementsEXT GetGeneratedCommandsMemoryRequirementsEXT;
    PFN_vkGetGeneratedCommandsMemoryRequirementsNV GetGeneratedCommandsMemoryRequirementsNV;
    PFN_vkGetImageDrmFormatModifierPropertiesEXT GetImageDrmFormatModifierPropertiesEXT;
    PFN_vkGetImageMemoryRequirements GetImageMemoryRequirements;
    PFN_vkGetImageMemoryRequirements2 GetImageMemoryRequirements2;
    PFN_vkGetImageMemoryRequirements2KHR GetImageMemoryRequirements2KHR;
    PFN_vkGetImageOpaqueCaptureDescriptorDataEXT GetImageOpaqueCaptureDescriptorDataEXT;
    PFN_vkGetImageSparseMemoryRequirements GetImageSparseMemoryRequirements;
    PFN_vkGetImageSparseMemoryRequirements2 GetImageSparseMemoryRequirements2;
    PFN_vkGetImageSparseMemoryRequirements2KHR GetImageSparseMemoryRequirements2KHR;
    PFN_vkGetImageSubresourceLayout GetImageSubresourceLayout;
    PFN_vkGetImageSubresourceLayout2EXT GetImageSubresourceLayout2EXT;
    PFN_vkGetImageSubresourceLayout2KHR GetImageSubresourceLayout2KHR;
    PFN_vkGetImageViewOpaqueCaptureDescriptorDataEXT GetImageViewOpaqueCaptureDescriptorDataEXT;
    PFN_vkGetLatencyTimingsNV GetLatencyTimingsNV;
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    PFN_vkGetMemoryAndroidHardwareBufferANDROID GetMemoryAndroidHardwareBufferANDROID;
#endif
    PFN_vkGetMemoryFdKHR GetMemoryFdKHR;
    PFN_vkGetMemoryFdPropertiesKHR GetMemoryFdPropertiesKHR;
    PFN_vkGetMemoryHostPointerPropertiesEXT GetMemoryHostPointerPropertiesEXT;
#ifdef VK_USE_PLATFORM_METAL_EXT
    PFN_vkGetMemoryMetalHandleEXT GetMemoryMetalHandleEXT;
#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
    PFN_vkGetMemoryMetalHandlePropertiesEXT GetMemoryMetalHandlePropertiesEXT;
#endif
    PFN_vkGetMemoryRemoteAddressNV GetMemoryRemoteAddressNV;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetMemoryWin32HandleKHR GetMemoryWin32HandleKHR;
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetMemoryWin32HandleNV GetMemoryWin32HandleNV;
#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetMemoryWin32HandlePropertiesKHR GetMemoryWin32HandlePropertiesKHR;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkGetMemoryZirconHandleFUCHSIA GetMemoryZirconHandleFUCHSIA;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkGetMemoryZirconHandlePropertiesFUCHSIA GetMemoryZirconHandlePropertiesFUCHSIA;
#endif
    PFN_vkGetMicromapBuildSizesEXT GetMicromapBuildSizesEXT;
    PFN_vkGetPartitionedAccelerationStructuresBuildSizesNV GetPartitionedAccelerationStructuresBuildSizesNV;
    PFN_vkGetPastPresentationTimingGOOGLE GetPastPresentationTimingGOOGLE;
    PFN_vkGetPerformanceParameterINTEL GetPerformanceParameterINTEL;
    PFN_vkGetPipelineBinaryDataKHR GetPipelineBinaryDataKHR;
    PFN_vkGetPipelineCacheData GetPipelineCacheData;
    PFN_vkGetPipelineExecutableInternalRepresentationsKHR GetPipelineExecutableInternalRepresentationsKHR;
    PFN_vkGetPipelineExecutablePropertiesKHR GetPipelineExecutablePropertiesKHR;
    PFN_vkGetPipelineExecutableStatisticsKHR GetPipelineExecutableStatisticsKHR;
    PFN_vkGetPipelineIndirectDeviceAddressNV GetPipelineIndirectDeviceAddressNV;
    PFN_vkGetPipelineIndirectMemoryRequirementsNV GetPipelineIndirectMemoryRequirementsNV;
    PFN_vkGetPipelineKeyKHR GetPipelineKeyKHR;
    PFN_vkGetPipelinePropertiesEXT GetPipelinePropertiesEXT;
    PFN_vkGetPrivateData GetPrivateData;
    PFN_vkGetPrivateDataEXT GetPrivateDataEXT;
    PFN_vkGetQueryPoolResults GetQueryPoolResults;
    PFN_vkGetQueueCheckpointData2NV GetQueueCheckpointData2NV;
    PFN_vkGetQueueCheckpointDataNV GetQueueCheckpointDataNV;
    PFN_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR GetRayTracingCaptureReplayShaderGroupHandlesKHR;
    PFN_vkGetRayTracingShaderGroupHandlesKHR GetRayTracingShaderGroupHandlesKHR;
    PFN_vkGetRayTracingShaderGroupHandlesNV GetRayTracingShaderGroupHandlesNV;
    PFN_vkGetRayTracingShaderGroupStackSizeKHR GetRayTracingShaderGroupStackSizeKHR;
    PFN_vkGetRefreshCycleDurationGOOGLE GetRefreshCycleDurationGOOGLE;
    PFN_vkGetRenderAreaGranularity GetRenderAreaGranularity;
    PFN_vkGetRenderingAreaGranularityKHR GetRenderingAreaGranularityKHR;
    PFN_vkGetSamplerOpaqueCaptureDescriptorDataEXT GetSamplerOpaqueCaptureDescriptorDataEXT;
#ifdef VK_USE_PLATFORM_SCREEN_QNX
    PFN_vkGetScreenBufferPropertiesQNX GetScreenBufferPropertiesQNX;
#endif
    PFN_vkGetSemaphoreCounterValue GetSemaphoreCounterValue;
    PFN_vkGetSemaphoreCounterValueKHR GetSemaphoreCounterValueKHR;
    PFN_vkGetSemaphoreFdKHR GetSemaphoreFdKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkGetSemaphoreWin32HandleKHR GetSemaphoreWin32HandleKHR;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkGetSemaphoreZirconHandleFUCHSIA GetSemaphoreZirconHandleFUCHSIA;
#endif
    PFN_vkGetShaderBinaryDataEXT GetShaderBinaryDataEXT;
    PFN_vkGetShaderInfoAMD GetShaderInfoAMD;
    PFN_vkGetShaderModuleCreateInfoIdentifierEXT GetShaderModuleCreateInfoIdentifierEXT;
    PFN_vkGetShaderModuleIdentifierEXT GetShaderModuleIdentifierEXT;
    PFN_vkGetSwapchainCounterEXT GetSwapchainCounterEXT;
    PFN_vkGetSwapchainImagesKHR GetSwapchainImagesKHR;
    PFN_vkGetSwapchainStatusKHR GetSwapchainStatusKHR;
    PFN_vkGetTensorMemoryRequirementsARM GetTensorMemoryRequirementsARM;
    PFN_vkGetTensorOpaqueCaptureDescriptorDataARM GetTensorOpaqueCaptureDescriptorDataARM;
    PFN_vkGetTensorViewOpaqueCaptureDescriptorDataARM GetTensorViewOpaqueCaptureDescriptorDataARM;
    PFN_vkGetValidationCacheDataEXT GetValidationCacheDataEXT;
    PFN_vkGetVideoSessionMemoryRequirementsKHR GetVideoSessionMemoryRequirementsKHR;
    PFN_vkImportFenceFdKHR ImportFenceFdKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkImportFenceWin32HandleKHR ImportFenceWin32HandleKHR;
#endif
    PFN_vkImportSemaphoreFdKHR ImportSemaphoreFdKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkImportSemaphoreWin32HandleKHR ImportSemaphoreWin32HandleKHR;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkImportSemaphoreZirconHandleFUCHSIA ImportSemaphoreZirconHandleFUCHSIA;
#endif
    PFN_vkInitializePerformanceApiINTEL InitializePerformanceApiINTEL;
    PFN_vkInvalidateMappedMemoryRanges InvalidateMappedMemoryRanges;
    PFN_vkLatencySleepNV LatencySleepNV;
    PFN_vkMapMemory MapMemory;
    PFN_vkMapMemory2KHR MapMemory2KHR;
    PFN_vkMergePipelineCaches MergePipelineCaches;
    PFN_vkMergeValidationCachesEXT MergeValidationCachesEXT;
    PFN_vkQueueBeginDebugUtilsLabelEXT QueueBeginDebugUtilsLabelEXT;
    PFN_vkQueueBindSparse QueueBindSparse;
    PFN_vkQueueEndDebugUtilsLabelEXT QueueEndDebugUtilsLabelEXT;
    PFN_vkQueueInsertDebugUtilsLabelEXT QueueInsertDebugUtilsLabelEXT;
    PFN_vkQueueNotifyOutOfBandNV QueueNotifyOutOfBandNV;
    PFN_vkQueuePresentKHR QueuePresentKHR;
    PFN_vkQueueSetPerformanceConfigurationINTEL QueueSetPerformanceConfigurationINTEL;
    PFN_vkQueueSubmit QueueSubmit;
    PFN_vkQueueSubmit2 QueueSubmit2;
    PFN_vkQueueSubmit2KHR QueueSubmit2KHR;
    PFN_vkQueueWaitIdle QueueWaitIdle;
    PFN_vkRegisterDeviceEventEXT RegisterDeviceEventEXT;
    PFN_vkRegisterDisplayEventEXT RegisterDisplayEventEXT;
    PFN_vkReleaseCapturedPipelineDataKHR ReleaseCapturedPipelineDataKHR;
#ifdef VK_USE_PLATFORM_WIN32_KHR
    PFN_vkReleaseFullScreenExclusiveModeEXT ReleaseFullScreenExclusiveModeEXT;
#endif
    PFN_vkReleasePerformanceConfigurationINTEL ReleasePerformanceConfigurationINTEL;
    PFN_vkReleaseProfilingLockKHR ReleaseProfilingLockKHR;
    PFN_vkReleaseSwapchainImagesEXT ReleaseSwapchainImagesEXT;
    PFN_vkReleaseSwapchainImagesKHR ReleaseSwapchainImagesKHR;
    PFN_vkResetCommandBuffer ResetCommandBuffer;
    PFN_vkResetCommandPool ResetCommandPool;
    PFN_vkResetDescriptorPool ResetDescriptorPool;
    PFN_vkResetEvent ResetEvent;
    PFN_vkResetFences ResetFences;
    PFN_vkResetQueryPool ResetQueryPool;
    PFN_vkResetQueryPoolEXT ResetQueryPoolEXT;
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkSetBufferCollectionBufferConstraintsFUCHSIA SetBufferCollectionBufferConstraintsFUCHSIA;
#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
    PFN_vkSetBufferCollectionImageConstraintsFUCHSIA SetBufferCollectionImageConstraintsFUCHSIA;
#endif
    PFN_vkSetDebugUtilsObjectNameEXT SetDebugUtilsObjectNameEXT;
    PFN_vkSetDebugUtilsObjectTagEXT SetDebugUtilsObjectTagEXT;
    PFN_vkSetDeviceMemoryPriorityEXT SetDeviceMemoryPriorityEXT;
    PFN_vkSetEvent SetEvent;
    PFN_vkSetHdrMetadataEXT SetHdrMetadataEXT;
    PFN_vkSetLatencyMarkerNV SetLatencyMarkerNV;
    PFN_vkSetLatencySleepModeNV SetLatencySleepModeNV;
    PFN_vkSetLocalDimmingAMD SetLocalDimmingAMD;
    PFN_vkSetPrivateData SetPrivateData;
    PFN_vkSetPrivateDataEXT SetPrivateDataEXT;
    PFN_vkSignalSemaphore SignalSemaphore;
    PFN_vkSignalSemaphoreKHR SignalSemaphoreKHR;
    PFN_vkTransitionImageLayoutEXT TransitionImageLayoutEXT;
    PFN_vkTrimCommandPool TrimCommandPool;
    PFN_vkTrimCommandPoolKHR TrimCommandPoolKHR;
    PFN_vkUninitializePerformanceApiINTEL UninitializePerformanceApiINTEL;
    PFN_vkUnmapMemory UnmapMemory;
    PFN_vkUnmapMemory2KHR UnmapMemory2KHR;
    PFN_vkUpdateDescriptorSetWithTemplate UpdateDescriptorSetWithTemplate;
    PFN_vkUpdateDescriptorSetWithTemplateKHR UpdateDescriptorSetWithTemplateKHR;
    PFN_vkUpdateDescriptorSets UpdateDescriptorSets;
    PFN_vkUpdateIndirectExecutionSetPipelineEXT UpdateIndirectExecutionSetPipelineEXT;
    PFN_vkUpdateIndirectExecutionSetShaderEXT UpdateIndirectExecutionSetShaderEXT;
    PFN_vkUpdateVideoSessionParametersKHR UpdateVideoSessionParametersKHR;
    PFN_vkWaitForFences WaitForFences;
    PFN_vkWaitForPresent2KHR WaitForPresent2KHR;
    PFN_vkWaitForPresentKHR WaitForPresentKHR;
    PFN_vkWaitSemaphores WaitSemaphores;
    PFN_vkWaitSemaphoresKHR WaitSemaphoresKHR;
    PFN_vkWriteAccelerationStructuresPropertiesKHR WriteAccelerationStructuresPropertiesKHR;
    PFN_vkWriteMicromapsPropertiesEXT WriteMicromapsPropertiesEXT;
  private:
    PFN_vkDestroyDevice _RealDestroyDevice;
    static void DestroyDeviceWrapper(VkDevice object, const VkAllocationCallbacks* pAllocator) {
      auto dispatch = vkroots::tables::LookupDeviceDispatch(object);
      auto destroyFunc = dispatch->_RealDestroyDevice;
      vkroots::tables::DestroyDispatchTable(object);
      destroyFunc(object, pAllocator);
    }
  };

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateAndroidSurfaceKHR(VkInstance instance, const VkAndroidSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateAndroidSurfaceKHR(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDebugReportCallbackEXT(VkInstance instance, const VkDebugReportCallbackCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugReportCallbackEXT *pCallback) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateDebugReportCallbackEXT(dispatch, instance, pCreateInfo, pAllocator, pCallback);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDebugUtilsMessengerEXT(VkInstance instance, const VkDebugUtilsMessengerCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDebugUtilsMessengerEXT *pMessenger) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateDebugUtilsMessengerEXT(dispatch, instance, pCreateInfo, pAllocator, pMessenger);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDevice(VkPhysicalDevice physicalDevice, const VkDeviceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDevice *pDevice) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::CreateDevice(dispatch, physicalDevice, pCreateInfo, pAllocator, pDevice);
    return ret;
  }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDirectFBSurfaceEXT(VkInstance instance, const VkDirectFBSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateDirectFBSurfaceEXT(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDisplayModeKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, const VkDisplayModeCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDisplayModeKHR *pMode) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::CreateDisplayModeKHR(dispatch, physicalDevice, display, pCreateInfo, pAllocator, pMode);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDisplayPlaneSurfaceKHR(VkInstance instance, const VkDisplaySurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateDisplayPlaneSurfaceKHR(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateHeadlessSurfaceEXT(VkInstance instance, const VkHeadlessSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateHeadlessSurfaceEXT(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#ifdef VK_USE_PLATFORM_IOS_MVK
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateIOSSurfaceMVK(VkInstance instance, const VkIOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateIOSSurfaceMVK(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateImagePipeSurfaceFUCHSIA(VkInstance instance, const VkImagePipeSurfaceCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateImagePipeSurfaceFUCHSIA(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateInstance(const VkInstanceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkInstance *pInstance) {
    VkResult ret = InstanceOverrides::CreateInstance(implicit_wrap_CreateInstance, pCreateInfo, pAllocator, pInstance);
    return ret;
  }

#ifdef VK_USE_PLATFORM_MACOS_MVK
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateMacOSSurfaceMVK(VkInstance instance, const VkMacOSSurfaceCreateInfoMVK *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateMacOSSurfaceMVK(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateMetalSurfaceEXT(VkInstance instance, const VkMetalSurfaceCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateMetalSurfaceEXT(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateScreenSurfaceQNX(VkInstance instance, const VkScreenSurfaceCreateInfoQNX *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateScreenSurfaceQNX(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_GGP
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateStreamDescriptorSurfaceGGP(VkInstance instance, const VkStreamDescriptorSurfaceCreateInfoGGP *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateStreamDescriptorSurfaceGGP(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_OHOS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSurfaceOHOS(VkInstance instance, const VkSurfaceCreateInfoOHOS *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateSurfaceOHOS(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_VI_NN
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateViSurfaceNN(VkInstance instance, const VkViSurfaceCreateInfoNN *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateViSurfaceNN(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateWaylandSurfaceKHR(VkInstance instance, const VkWaylandSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateWaylandSurfaceKHR(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateWin32SurfaceKHR(VkInstance instance, const VkWin32SurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateWin32SurfaceKHR(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateXcbSurfaceKHR(VkInstance instance, const VkXcbSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateXcbSurfaceKHR(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateXlibSurfaceKHR(VkInstance instance, const VkXlibSurfaceCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSurfaceKHR *pSurface) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::CreateXlibSurfaceKHR(dispatch, instance, pCreateInfo, pAllocator, pSurface);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DebugReportMessageEXT(VkInstance instance, VkDebugReportFlagsEXT flags, VkDebugReportObjectTypeEXT objectType, uint64_t object, size_t location, int32_t messageCode, const char *pLayerPrefix, const char *pMessage) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    InstanceOverrides::DebugReportMessageEXT(dispatch, instance, flags, objectType, object, location, messageCode, pLayerPrefix, pMessage);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDebugReportCallbackEXT(VkInstance instance, VkDebugReportCallbackEXT callback, const VkAllocationCallbacks *pAllocator) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    InstanceOverrides::DestroyDebugReportCallbackEXT(dispatch, instance, callback, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDebugUtilsMessengerEXT(VkInstance instance, VkDebugUtilsMessengerEXT messenger, const VkAllocationCallbacks *pAllocator) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    InstanceOverrides::DestroyDebugUtilsMessengerEXT(dispatch, instance, messenger, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyInstance(VkInstance instance, const VkAllocationCallbacks *pAllocator) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    InstanceOverrides::DestroyInstance(dispatch, instance, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface, const VkAllocationCallbacks *pAllocator) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    InstanceOverrides::DestroySurfaceKHR(dispatch, instance, surface, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumerateDeviceExtensionProperties(VkPhysicalDevice physicalDevice, const char *pLayerName, uint32_t *pPropertyCount, VkExtensionProperties *pProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::EnumerateDeviceExtensionProperties(dispatch, physicalDevice, pLayerName, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumerateDeviceLayerProperties(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkLayerProperties *pProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::EnumerateDeviceLayerProperties(dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumeratePhysicalDeviceGroups(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::EnumeratePhysicalDeviceGroups(dispatch, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumeratePhysicalDeviceGroupsKHR(VkInstance instance, uint32_t *pPhysicalDeviceGroupCount, VkPhysicalDeviceGroupProperties *pPhysicalDeviceGroupProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::EnumeratePhysicalDeviceGroupsKHR(dispatch, instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumeratePhysicalDevices(VkInstance instance, uint32_t *pPhysicalDeviceCount, VkPhysicalDevice *pPhysicalDevices) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    VkResult ret = InstanceOverrides::EnumeratePhysicalDevices(dispatch, instance, pPhysicalDeviceCount, pPhysicalDevices);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDisplayModePropertiesKHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModePropertiesKHR *pProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetDisplayModePropertiesKHR(dispatch, physicalDevice, display, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDisplayPlaneCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkDisplayModeKHR mode, uint32_t planeIndex, VkDisplayPlaneCapabilitiesKHR *pCapabilities) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetDisplayPlaneCapabilitiesKHR(dispatch, physicalDevice, mode, planeIndex, pCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDisplayPlaneSupportedDisplaysKHR(VkPhysicalDevice physicalDevice, uint32_t planeIndex, uint32_t *pDisplayCount, VkDisplayKHR *pDisplays) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetDisplayPlaneSupportedDisplaysKHR(dispatch, physicalDevice, planeIndex, pDisplayCount, pDisplays);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static PFN_vkVoidFunction wrap_GetInstanceProcAddr(VkInstance instance, const char *pName) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    PFN_vkVoidFunction ret = InstanceOverrides::GetInstanceProcAddr(dispatch, instance, pName);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceDisplayPlanePropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlanePropertiesKHR *pProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceDisplayPlanePropertiesKHR(dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceDisplayPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPropertiesKHR *pProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceDisplayPropertiesKHR(dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalBufferProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceExternalBufferProperties(dispatch, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalFenceProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceExternalFenceProperties(dispatch, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalSemaphoreProperties(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceExternalSemaphoreProperties(dispatch, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFeatures(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures *pFeatures) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceFeatures(dispatch, physicalDevice, pFeatures);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFeatures2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceFeatures2(dispatch, physicalDevice, pFeatures);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties *pFormatProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceFormatProperties(dispatch, physicalDevice, format, pFormatProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFormatProperties2(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceFormatProperties2(dispatch, physicalDevice, format, pFormatProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkImageFormatProperties *pImageFormatProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceImageFormatProperties(dispatch, physicalDevice, format, type, tiling, usage, flags, pImageFormatProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceImageFormatProperties2(dispatch, physicalDevice, pImageFormatInfo, pImageFormatProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties *pMemoryProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceMemoryProperties(dispatch, physicalDevice, pMemoryProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceMemoryProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceMemoryProperties2(dispatch, physicalDevice, pMemoryProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDevicePresentRectanglesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pRectCount, VkRect2D *pRects) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDevicePresentRectanglesKHR(dispatch, physicalDevice, surface, pRectCount, pRects);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties *pProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceProperties(dispatch, physicalDevice, pProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceProperties2(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceProperties2(dispatch, physicalDevice, pProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties *pQueueFamilyProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties(dispatch, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceQueueFamilyProperties2(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties2(dispatch, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceSparseImageFormatProperties(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkSampleCountFlagBits samples, VkImageUsageFlags usage, VkImageTiling tiling, uint32_t *pPropertyCount, VkSparseImageFormatProperties *pProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties(dispatch, physicalDevice, format, type, samples, usage, tiling, pPropertyCount, pProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceSparseImageFormatProperties2(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties2(dispatch, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkSurfaceCapabilities2KHR *pSurfaceCapabilities) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceCapabilities2KHR(dispatch, physicalDevice, pSurfaceInfo, pSurfaceCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilitiesKHR *pSurfaceCapabilities) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceCapabilitiesKHR(dispatch, physicalDevice, surface, pSurfaceCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pSurfaceFormatCount, VkSurfaceFormat2KHR *pSurfaceFormats) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceFormats2KHR(dispatch, physicalDevice, pSurfaceInfo, pSurfaceFormatCount, pSurfaceFormats);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pSurfaceFormatCount, VkSurfaceFormatKHR *pSurfaceFormats) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceFormatsKHR(dispatch, physicalDevice, surface, pSurfaceFormatCount, pSurfaceFormats);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfacePresentModesKHR(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfacePresentModesKHR(dispatch, physicalDevice, surface, pPresentModeCount, pPresentModes);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, VkSurfaceKHR surface, VkBool32 *pSupported) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceSurfaceSupportKHR(dispatch, physicalDevice, queueFamilyIndex, surface, pSupported);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceToolProperties(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkResult ret = InstanceOverrides::GetPhysicalDeviceToolProperties(dispatch, physicalDevice, pToolCount, pToolProperties);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceWaylandPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct wl_display *display) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkBool32 ret = InstanceOverrides::GetPhysicalDeviceWaylandPresentationSupportKHR(dispatch, physicalDevice, queueFamilyIndex, display);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceWin32PresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkBool32 ret = InstanceOverrides::GetPhysicalDeviceWin32PresentationSupportKHR(dispatch, physicalDevice, queueFamilyIndex);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XCB_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceXcbPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, xcb_connection_t *connection, xcb_visualid_t visual_id) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkBool32 ret = InstanceOverrides::GetPhysicalDeviceXcbPresentationSupportKHR(dispatch, physicalDevice, queueFamilyIndex, connection, visual_id);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XLIB_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceXlibPresentationSupportKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, Display *dpy, VisualID visualID) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    VkBool32 ret = InstanceOverrides::GetPhysicalDeviceXlibPresentationSupportKHR(dispatch, physicalDevice, queueFamilyIndex, dpy, visualID);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_SubmitDebugUtilsMessageEXT(VkInstance instance, VkDebugUtilsMessageSeverityFlagBitsEXT messageSeverity, VkDebugUtilsMessageTypeFlagsEXT messageTypes, const VkDebugUtilsMessengerCallbackDataEXT *pCallbackData) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    InstanceOverrides::SubmitDebugUtilsMessageEXT(dispatch, instance, messageSeverity, messageTypes, pCallbackData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, VkDisplayKHR display) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::AcquireDrmDisplayEXT(dispatch, physicalDevice, drmFd, display);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireWinrtDisplayNV(VkPhysicalDevice physicalDevice, VkDisplayKHR display) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::AcquireWinrtDisplayNV(dispatch, physicalDevice, display);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireXlibDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, VkDisplayKHR display) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::AcquireXlibDisplayEXT(dispatch, physicalDevice, dpy, display);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pCounterCount, VkPerformanceCounterKHR *pCounters, VkPerformanceCounterDescriptionKHR *pCounterDescriptions) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(dispatch, physicalDevice, queueFamilyIndex, pCounterCount, pCounters, pCounterDescriptions);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDisplayModeProperties2KHR(VkPhysicalDevice physicalDevice, VkDisplayKHR display, uint32_t *pPropertyCount, VkDisplayModeProperties2KHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetDisplayModeProperties2KHR(dispatch, physicalDevice, display, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDisplayPlaneCapabilities2KHR(VkPhysicalDevice physicalDevice, const VkDisplayPlaneInfo2KHR *pDisplayPlaneInfo, VkDisplayPlaneCapabilities2KHR *pCapabilities) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetDisplayPlaneCapabilities2KHR(dispatch, physicalDevice, pDisplayPlaneInfo, pCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDrmDisplayEXT(VkPhysicalDevice physicalDevice, int32_t drmFd, uint32_t connectorId, VkDisplayKHR *display) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetDrmDisplayEXT(dispatch, physicalDevice, drmFd, connectorId, display);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCalibrateableTimeDomainsEXT(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceCalibrateableTimeDomainsEXT(dispatch, physicalDevice, pTimeDomainCount, pTimeDomains);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCalibrateableTimeDomainsKHR(VkPhysicalDevice physicalDevice, uint32_t *pTimeDomainCount, VkTimeDomainKHR *pTimeDomains) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceCalibrateableTimeDomainsKHR(dispatch, physicalDevice, pTimeDomainCount, pTimeDomains);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixFlexibleDimensionsPropertiesNV *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV(dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCooperativeMatrixPropertiesKHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesKHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceCooperativeMatrixPropertiesKHR(dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCooperativeMatrixPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeMatrixPropertiesNV *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceCooperativeMatrixPropertiesNV(dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceCooperativeVectorPropertiesNV(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkCooperativeVectorPropertiesNV *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceCooperativeVectorPropertiesNV(dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceDirectFBPresentationSupportEXT(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, IDirectFB *dfb) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkBool32 ret = PhysicalDeviceOverrides::GetPhysicalDeviceDirectFBPresentationSupportEXT(dispatch, physicalDevice, queueFamilyIndex, dfb);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceDisplayPlaneProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayPlaneProperties2KHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceDisplayPlaneProperties2KHR(dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceDisplayProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pPropertyCount, VkDisplayProperties2KHR *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceDisplayProperties2KHR(dispatch, physicalDevice, pPropertyCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalBufferPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalBufferInfo *pExternalBufferInfo, VkExternalBufferProperties *pExternalBufferProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceExternalBufferPropertiesKHR(dispatch, physicalDevice, pExternalBufferInfo, pExternalBufferProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalFencePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalFenceInfo *pExternalFenceInfo, VkExternalFenceProperties *pExternalFenceProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceExternalFencePropertiesKHR(dispatch, physicalDevice, pExternalFenceInfo, pExternalFenceProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceExternalImageFormatPropertiesNV(VkPhysicalDevice physicalDevice, VkFormat format, VkImageType type, VkImageTiling tiling, VkImageUsageFlags usage, VkImageCreateFlags flags, VkExternalMemoryHandleTypeFlagsNV externalHandleType, VkExternalImageFormatPropertiesNV *pExternalImageFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceExternalImageFormatPropertiesNV(dispatch, physicalDevice, format, type, tiling, usage, flags, externalHandleType, pExternalImageFormatProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalSemaphorePropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalSemaphoreInfo *pExternalSemaphoreInfo, VkExternalSemaphoreProperties *pExternalSemaphoreProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceExternalSemaphorePropertiesKHR(dispatch, physicalDevice, pExternalSemaphoreInfo, pExternalSemaphoreProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceExternalTensorPropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceExternalTensorInfoARM *pExternalTensorInfo, VkExternalTensorPropertiesARM *pExternalTensorProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceExternalTensorPropertiesARM(dispatch, physicalDevice, pExternalTensorInfo, pExternalTensorProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFeatures2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceFeatures2 *pFeatures) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceFeatures2KHR(dispatch, physicalDevice, pFeatures);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceFormatProperties2KHR(VkPhysicalDevice physicalDevice, VkFormat format, VkFormatProperties2 *pFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceFormatProperties2KHR(dispatch, physicalDevice, format, pFormatProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceFragmentShadingRatesKHR(VkPhysicalDevice physicalDevice, uint32_t *pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR *pFragmentShadingRates) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceFragmentShadingRatesKHR(dispatch, physicalDevice, pFragmentShadingRateCount, pFragmentShadingRates);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceImageFormatInfo2 *pImageFormatInfo, VkImageFormatProperties2 *pImageFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceImageFormatProperties2KHR(dispatch, physicalDevice, pImageFormatInfo, pImageFormatProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceMemoryProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceMemoryProperties2 *pMemoryProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceMemoryProperties2KHR(dispatch, physicalDevice, pMemoryProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceMultisamplePropertiesEXT(VkPhysicalDevice physicalDevice, VkSampleCountFlagBits samples, VkMultisamplePropertiesEXT *pMultisampleProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceMultisamplePropertiesEXT(dispatch, physicalDevice, samples, pMultisampleProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceOpticalFlowImageFormatsNV(VkPhysicalDevice physicalDevice, const VkOpticalFlowImageFormatInfoNV *pOpticalFlowImageFormatInfo, uint32_t *pFormatCount, VkOpticalFlowImageFormatPropertiesNV *pImageFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceOpticalFlowImageFormatsNV(dispatch, physicalDevice, pOpticalFlowImageFormatInfo, pFormatCount, pImageFormatProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceProperties2KHR(VkPhysicalDevice physicalDevice, VkPhysicalDeviceProperties2 *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceProperties2KHR(dispatch, physicalDevice, pProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM *pQueueFamilyDataGraphProcessingEngineInfo, VkQueueFamilyDataGraphProcessingEnginePropertiesARM *pQueueFamilyDataGraphProcessingEngineProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM(dispatch, physicalDevice, pQueueFamilyDataGraphProcessingEngineInfo, pQueueFamilyDataGraphProcessingEngineProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, uint32_t *pQueueFamilyDataGraphPropertyCount, VkQueueFamilyDataGraphPropertiesARM *pQueueFamilyDataGraphProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM(dispatch, physicalDevice, queueFamilyIndex, pQueueFamilyDataGraphPropertyCount, pQueueFamilyDataGraphProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(VkPhysicalDevice physicalDevice, const VkQueryPoolPerformanceCreateInfoKHR *pPerformanceQueryCreateInfo, uint32_t *pNumPasses) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(dispatch, physicalDevice, pPerformanceQueryCreateInfo, pNumPasses);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceQueueFamilyProperties2KHR(VkPhysicalDevice physicalDevice, uint32_t *pQueueFamilyPropertyCount, VkQueueFamilyProperties2 *pQueueFamilyProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceQueueFamilyProperties2KHR(dispatch, physicalDevice, pQueueFamilyPropertyCount, pQueueFamilyProperties);
  }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkBool32 wrap_GetPhysicalDeviceScreenPresentationSupportQNX(VkPhysicalDevice physicalDevice, uint32_t queueFamilyIndex, struct _screen_window *window) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkBool32 ret = PhysicalDeviceOverrides::GetPhysicalDeviceScreenPresentationSupportQNX(dispatch, physicalDevice, queueFamilyIndex, window);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPhysicalDeviceSparseImageFormatProperties2KHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSparseImageFormatInfo2 *pFormatInfo, uint32_t *pPropertyCount, VkSparseImageFormatProperties2 *pProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    PhysicalDeviceOverrides::GetPhysicalDeviceSparseImageFormatProperties2KHR(dispatch, physicalDevice, pFormatInfo, pPropertyCount, pProperties);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(VkPhysicalDevice physicalDevice, uint32_t *pCombinationCount, VkFramebufferMixedSamplesCombinationNV *pCombinations) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(dispatch, physicalDevice, pCombinationCount, pCombinations);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfaceCapabilities2EXT(VkPhysicalDevice physicalDevice, VkSurfaceKHR surface, VkSurfaceCapabilities2EXT *pSurfaceCapabilities) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceSurfaceCapabilities2EXT(dispatch, physicalDevice, surface, pSurfaceCapabilities);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceSurfacePresentModes2EXT(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, uint32_t *pPresentModeCount, VkPresentModeKHR *pPresentModes) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceSurfacePresentModes2EXT(dispatch, physicalDevice, pSurfaceInfo, pPresentModeCount, pPresentModes);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceToolPropertiesEXT(VkPhysicalDevice physicalDevice, uint32_t *pToolCount, VkPhysicalDeviceToolProperties *pToolProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceToolPropertiesEXT(dispatch, physicalDevice, pToolCount, pToolProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceVideoCapabilitiesKHR(VkPhysicalDevice physicalDevice, const VkVideoProfileInfoKHR *pVideoProfile, VkVideoCapabilitiesKHR *pCapabilities) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceVideoCapabilitiesKHR(dispatch, physicalDevice, pVideoProfile, pCapabilities);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR *pQualityLevelInfo, VkVideoEncodeQualityLevelPropertiesKHR *pQualityLevelProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(dispatch, physicalDevice, pQualityLevelInfo, pQualityLevelProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPhysicalDeviceVideoFormatPropertiesKHR(VkPhysicalDevice physicalDevice, const VkPhysicalDeviceVideoFormatInfoKHR *pVideoFormatInfo, uint32_t *pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR *pVideoFormatProperties) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetPhysicalDeviceVideoFormatPropertiesKHR(dispatch, physicalDevice, pVideoFormatInfo, pVideoFormatPropertyCount, pVideoFormatProperties);
    return ret;
  }

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetRandROutputDisplayEXT(VkPhysicalDevice physicalDevice, Display *dpy, RROutput rrOutput, VkDisplayKHR *pDisplay) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetRandROutputDisplayEXT(dispatch, physicalDevice, dpy, rrOutput, pDisplay);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetWinrtDisplayNV(VkPhysicalDevice physicalDevice, uint32_t deviceRelativeId, VkDisplayKHR *pDisplay) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::GetWinrtDisplayNV(dispatch, physicalDevice, deviceRelativeId, pDisplay);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleaseDisplayEXT(VkPhysicalDevice physicalDevice, VkDisplayKHR display) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(physicalDevice);
    VkResult ret = PhysicalDeviceOverrides::ReleaseDisplayEXT(dispatch, physicalDevice, display);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::AcquireFullScreenExclusiveModeEXT(dispatch, device, swapchain);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireNextImage2KHR(VkDevice device, const VkAcquireNextImageInfoKHR *pAcquireInfo, uint32_t *pImageIndex) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::AcquireNextImage2KHR(dispatch, device, pAcquireInfo, pImageIndex);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireNextImageKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore, VkFence fence, uint32_t *pImageIndex) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::AcquireNextImageKHR(dispatch, device, swapchain, timeout, semaphore, fence, pImageIndex);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquirePerformanceConfigurationINTEL(VkDevice device, const VkPerformanceConfigurationAcquireInfoINTEL *pAcquireInfo, VkPerformanceConfigurationINTEL *pConfiguration) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::AcquirePerformanceConfigurationINTEL(dispatch, device, pAcquireInfo, pConfiguration);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AcquireProfilingLockKHR(VkDevice device, const VkAcquireProfilingLockInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::AcquireProfilingLockKHR(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::AllocateCommandBuffers(dispatch, device, pAllocateInfo, pCommandBuffers);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AllocateDescriptorSets(VkDevice device, const VkDescriptorSetAllocateInfo *pAllocateInfo, VkDescriptorSet *pDescriptorSets) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::AllocateDescriptorSets(dispatch, device, pAllocateInfo, pDescriptorSets);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_AllocateMemory(VkDevice device, const VkMemoryAllocateInfo *pAllocateInfo, const VkAllocationCallbacks *pAllocator, VkDeviceMemory *pMemory) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::AllocateMemory(dispatch, device, pAllocateInfo, pAllocator, pMemory);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_AntiLagUpdateAMD(VkDevice device, const VkAntiLagDataAMD *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::AntiLagUpdateAMD(dispatch, device, pData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BeginCommandBuffer(VkCommandBuffer commandBuffer, const VkCommandBufferBeginInfo *pBeginInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::BeginCommandBuffer(dispatch, commandBuffer, pBeginInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindAccelerationStructureMemoryNV(VkDevice device, uint32_t bindInfoCount, const VkBindAccelerationStructureMemoryInfoNV *pBindInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindAccelerationStructureMemoryNV(dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindBufferMemory(VkDevice device, VkBuffer buffer, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindBufferMemory(dispatch, device, buffer, memory, memoryOffset);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindBufferMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindBufferMemory2(dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindBufferMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindBufferMemoryInfo *pBindInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindBufferMemory2KHR(dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindDataGraphPipelineSessionMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindDataGraphPipelineSessionMemoryInfoARM *pBindInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindDataGraphPipelineSessionMemoryARM(dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindImageMemory(VkDevice device, VkImage image, VkDeviceMemory memory, VkDeviceSize memoryOffset) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindImageMemory(dispatch, device, image, memory, memoryOffset);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindImageMemory2(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindImageMemory2(dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindImageMemory2KHR(VkDevice device, uint32_t bindInfoCount, const VkBindImageMemoryInfo *pBindInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindImageMemory2KHR(dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindOpticalFlowSessionImageNV(VkDevice device, VkOpticalFlowSessionNV session, VkOpticalFlowSessionBindingPointNV bindingPoint, VkImageView view, VkImageLayout layout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindOpticalFlowSessionImageNV(dispatch, device, session, bindingPoint, view, layout);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindTensorMemoryARM(VkDevice device, uint32_t bindInfoCount, const VkBindTensorMemoryInfoARM *pBindInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindTensorMemoryARM(dispatch, device, bindInfoCount, pBindInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BindVideoSessionMemoryKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t bindSessionMemoryInfoCount, const VkBindVideoSessionMemoryInfoKHR *pBindSessionMemoryInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BindVideoSessionMemoryKHR(dispatch, device, videoSession, bindSessionMemoryInfoCount, pBindSessionMemoryInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BuildAccelerationStructuresKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BuildAccelerationStructuresKHR(dispatch, device, deferredOperation, infoCount, pInfos, ppBuildRangeInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_BuildMicromapsEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::BuildMicromapsEXT(dispatch, device, deferredOperation, infoCount, pInfos);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginConditionalRenderingEXT(VkCommandBuffer commandBuffer, const VkConditionalRenderingBeginInfoEXT *pConditionalRenderingBegin) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginConditionalRenderingEXT(dispatch, commandBuffer, pConditionalRenderingBegin);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginDebugUtilsLabelEXT(dispatch, commandBuffer, pLabelInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileBeginInfoQCOM *pPerTileBeginInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginPerTileExecutionQCOM(dispatch, commandBuffer, pPerTileBeginInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginQuery(dispatch, commandBuffer, queryPool, query, flags);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, VkQueryControlFlags flags, uint32_t index) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginQueryIndexedEXT(dispatch, commandBuffer, queryPool, query, flags, index);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginRenderPass(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, VkSubpassContents contents) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginRenderPass(dispatch, commandBuffer, pRenderPassBegin, contents);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginRenderPass2(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginRenderPass2(dispatch, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginRenderPass2KHR(VkCommandBuffer commandBuffer, const VkRenderPassBeginInfo *pRenderPassBegin, const VkSubpassBeginInfo *pSubpassBeginInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginRenderPass2KHR(dispatch, commandBuffer, pRenderPassBegin, pSubpassBeginInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginRendering(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginRendering(dispatch, commandBuffer, pRenderingInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginRenderingKHR(VkCommandBuffer commandBuffer, const VkRenderingInfo *pRenderingInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginRenderingKHR(dispatch, commandBuffer, pRenderingInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginTransformFeedbackEXT(dispatch, commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBeginVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoBeginCodingInfoKHR *pBeginInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBeginVideoCodingKHR(dispatch, commandBuffer, pBeginInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindDescriptorBufferEmbeddedSamplers2EXT(VkCommandBuffer commandBuffer, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT *pBindDescriptorBufferEmbeddedSamplersInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplers2EXT(dispatch, commandBuffer, pBindDescriptorBufferEmbeddedSamplersInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindDescriptorBufferEmbeddedSamplersEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplersEXT(dispatch, commandBuffer, pipelineBindPoint, layout, set);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindDescriptorBuffersEXT(VkCommandBuffer commandBuffer, uint32_t bufferCount, const VkDescriptorBufferBindingInfoEXT *pBindingInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindDescriptorBuffersEXT(dispatch, commandBuffer, bufferCount, pBindingInfos);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindDescriptorSets(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets, uint32_t dynamicOffsetCount, const uint32_t *pDynamicOffsets) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindDescriptorSets(dispatch, commandBuffer, pipelineBindPoint, layout, firstSet, descriptorSetCount, pDescriptorSets, dynamicOffsetCount, pDynamicOffsets);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindDescriptorSets2KHR(VkCommandBuffer commandBuffer, const VkBindDescriptorSetsInfo *pBindDescriptorSetsInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindDescriptorSets2KHR(dispatch, commandBuffer, pBindDescriptorSetsInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindIndexBuffer(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkIndexType indexType) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindIndexBuffer(dispatch, commandBuffer, buffer, offset, indexType);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindIndexBuffer2KHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkDeviceSize size, VkIndexType indexType) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindIndexBuffer2KHR(dispatch, commandBuffer, buffer, offset, size, indexType);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindInvocationMaskHUAWEI(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindInvocationMaskHUAWEI(dispatch, commandBuffer, imageView, imageLayout);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindPipeline(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindPipeline(dispatch, commandBuffer, pipelineBindPoint, pipeline);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindPipelineShaderGroupNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline, uint32_t groupIndex) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindPipelineShaderGroupNV(dispatch, commandBuffer, pipelineBindPoint, pipeline, groupIndex);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindShadersEXT(VkCommandBuffer commandBuffer, uint32_t stageCount, const VkShaderStageFlagBits *pStages, const VkShaderEXT *pShaders) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindShadersEXT(dispatch, commandBuffer, stageCount, pStages, pShaders);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindShadingRateImageNV(VkCommandBuffer commandBuffer, VkImageView imageView, VkImageLayout imageLayout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindShadingRateImageNV(dispatch, commandBuffer, imageView, imageLayout);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindTileMemoryQCOM(VkCommandBuffer commandBuffer, const VkTileMemoryBindInfoQCOM *pTileMemoryBindInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindTileMemoryQCOM(dispatch, commandBuffer, pTileMemoryBindInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindTransformFeedbackBuffersEXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindTransformFeedbackBuffersEXT(dispatch, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindVertexBuffers(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindVertexBuffers(dispatch, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindVertexBuffers2(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindVertexBuffers2(dispatch, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBindVertexBuffers2EXT(VkCommandBuffer commandBuffer, uint32_t firstBinding, uint32_t bindingCount, const VkBuffer *pBuffers, const VkDeviceSize *pOffsets, const VkDeviceSize *pSizes, const VkDeviceSize *pStrides) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBindVertexBuffers2EXT(dispatch, commandBuffer, firstBinding, bindingCount, pBuffers, pOffsets, pSizes, pStrides);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBlitImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageBlit *pRegions, VkFilter filter) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBlitImage(dispatch, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions, filter);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBlitImage2(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBlitImage2(dispatch, commandBuffer, pBlitImageInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBlitImage2KHR(VkCommandBuffer commandBuffer, const VkBlitImageInfo2 *pBlitImageInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBlitImage2KHR(dispatch, commandBuffer, pBlitImageInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildAccelerationStructureNV(VkCommandBuffer commandBuffer, const VkAccelerationStructureInfoNV *pInfo, VkBuffer instanceData, VkDeviceSize instanceOffset, VkBool32 update, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkBuffer scratch, VkDeviceSize scratchOffset) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBuildAccelerationStructureNV(dispatch, commandBuffer, pInfo, instanceData, instanceOffset, update, dst, src, scratch, scratchOffset);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildAccelerationStructuresIndirectKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkDeviceAddress *pIndirectDeviceAddresses, const uint32_t *pIndirectStrides, const uint32_t * const*ppMaxPrimitiveCounts) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBuildAccelerationStructuresIndirectKHR(dispatch, commandBuffer, infoCount, pInfos, pIndirectDeviceAddresses, pIndirectStrides, ppMaxPrimitiveCounts);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildAccelerationStructuresKHR(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkAccelerationStructureBuildGeometryInfoKHR *pInfos, const VkAccelerationStructureBuildRangeInfoKHR * const*ppBuildRangeInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBuildAccelerationStructuresKHR(dispatch, commandBuffer, infoCount, pInfos, ppBuildRangeInfos);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildClusterAccelerationStructureIndirectNV(VkCommandBuffer commandBuffer, const VkClusterAccelerationStructureCommandsInfoNV *pCommandInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBuildClusterAccelerationStructureIndirectNV(dispatch, commandBuffer, pCommandInfos);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildMicromapsEXT(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkMicromapBuildInfoEXT *pInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBuildMicromapsEXT(dispatch, commandBuffer, infoCount, pInfos);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdBuildPartitionedAccelerationStructuresNV(VkCommandBuffer commandBuffer, const VkBuildPartitionedAccelerationStructureInfoNV *pBuildInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdBuildPartitionedAccelerationStructuresNV(dispatch, commandBuffer, pBuildInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdClearAttachments(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkClearAttachment *pAttachments, uint32_t rectCount, const VkClearRect *pRects) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdClearAttachments(dispatch, commandBuffer, attachmentCount, pAttachments, rectCount, pRects);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdClearColorImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearColorValue *pColor, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdClearColorImage(dispatch, commandBuffer, image, imageLayout, pColor, rangeCount, pRanges);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdClearDepthStencilImage(VkCommandBuffer commandBuffer, VkImage image, VkImageLayout imageLayout, const VkClearDepthStencilValue *pDepthStencil, uint32_t rangeCount, const VkImageSubresourceRange *pRanges) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdClearDepthStencilImage(dispatch, commandBuffer, image, imageLayout, pDepthStencil, rangeCount, pRanges);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdControlVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoCodingControlInfoKHR *pCodingControlInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdControlVideoCodingKHR(dispatch, commandBuffer, pCodingControlInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdConvertCooperativeVectorMatrixNV(VkCommandBuffer commandBuffer, uint32_t infoCount, const VkConvertCooperativeVectorMatrixInfoNV *pInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdConvertCooperativeVectorMatrixNV(dispatch, commandBuffer, infoCount, pInfos);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyAccelerationStructureKHR(dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyAccelerationStructureNV(VkCommandBuffer commandBuffer, VkAccelerationStructureNV dst, VkAccelerationStructureNV src, VkCopyAccelerationStructureModeKHR mode) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyAccelerationStructureNV(dispatch, commandBuffer, dst, src, mode);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyAccelerationStructureToMemoryKHR(VkCommandBuffer commandBuffer, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyAccelerationStructureToMemoryKHR(dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBuffer(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferCopy *pRegions) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBuffer(dispatch, commandBuffer, srcBuffer, dstBuffer, regionCount, pRegions);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBuffer2(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBuffer2(dispatch, commandBuffer, pCopyBufferInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferInfo2 *pCopyBufferInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBuffer2KHR(dispatch, commandBuffer, pCopyBufferInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBufferToImage(VkCommandBuffer commandBuffer, VkBuffer srcBuffer, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkBufferImageCopy *pRegions) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBufferToImage(dispatch, commandBuffer, srcBuffer, dstImage, dstImageLayout, regionCount, pRegions);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBufferToImage2(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBufferToImage2(dispatch, commandBuffer, pCopyBufferToImageInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyBufferToImage2KHR(VkCommandBuffer commandBuffer, const VkCopyBufferToImageInfo2 *pCopyBufferToImageInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyBufferToImage2KHR(dispatch, commandBuffer, pCopyBufferToImageInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageCopy *pRegions) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImage(dispatch, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImage2(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImage2(dispatch, commandBuffer, pCopyImageInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImage2KHR(VkCommandBuffer commandBuffer, const VkCopyImageInfo2 *pCopyImageInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImage2KHR(dispatch, commandBuffer, pCopyImageInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImageToBuffer(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkBuffer dstBuffer, uint32_t regionCount, const VkBufferImageCopy *pRegions) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImageToBuffer(dispatch, commandBuffer, srcImage, srcImageLayout, dstBuffer, regionCount, pRegions);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImageToBuffer2(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImageToBuffer2(dispatch, commandBuffer, pCopyImageToBufferInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyImageToBuffer2KHR(VkCommandBuffer commandBuffer, const VkCopyImageToBufferInfo2 *pCopyImageToBufferInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyImageToBuffer2KHR(dispatch, commandBuffer, pCopyImageToBufferInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMemoryIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMemoryIndirectNV(dispatch, commandBuffer, copyBufferAddress, copyCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMemoryToAccelerationStructureKHR(VkCommandBuffer commandBuffer, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMemoryToAccelerationStructureKHR(dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMemoryToImageIndirectNV(VkCommandBuffer commandBuffer, VkDeviceAddress copyBufferAddress, uint32_t copyCount, uint32_t stride, VkImage dstImage, VkImageLayout dstImageLayout, const VkImageSubresourceLayers *pImageSubresources) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMemoryToImageIndirectNV(dispatch, commandBuffer, copyBufferAddress, copyCount, stride, dstImage, dstImageLayout, pImageSubresources);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMemoryToMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMemoryToMicromapInfoEXT *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMemoryToMicromapEXT(dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMicromapEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapInfoEXT *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMicromapEXT(dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyMicromapToMemoryEXT(VkCommandBuffer commandBuffer, const VkCopyMicromapToMemoryInfoEXT *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyMicromapToMemoryEXT(dispatch, commandBuffer, pInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyQueryPoolResults(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize stride, VkQueryResultFlags flags) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyQueryPoolResults(dispatch, commandBuffer, queryPool, firstQuery, queryCount, dstBuffer, dstOffset, stride, flags);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCopyTensorARM(VkCommandBuffer commandBuffer, const VkCopyTensorInfoARM *pCopyTensorInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCopyTensorARM(dispatch, commandBuffer, pCopyTensorInfo);
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdCudaLaunchKernelNV(VkCommandBuffer commandBuffer, const VkCudaLaunchInfoNV *pLaunchInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdCudaLaunchKernelNV(dispatch, commandBuffer, pLaunchInfo);
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDebugMarkerBeginEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDebugMarkerBeginEXT(dispatch, commandBuffer, pMarkerInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDebugMarkerEndEXT(VkCommandBuffer commandBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDebugMarkerEndEXT(dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDebugMarkerInsertEXT(VkCommandBuffer commandBuffer, const VkDebugMarkerMarkerInfoEXT *pMarkerInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDebugMarkerInsertEXT(dispatch, commandBuffer, pMarkerInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDecodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoDecodeInfoKHR *pDecodeInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDecodeVideoKHR(dispatch, commandBuffer, pDecodeInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDecompressMemoryIndirectCountNV(VkCommandBuffer commandBuffer, VkDeviceAddress indirectCommandsAddress, VkDeviceAddress indirectCommandsCountAddress, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDecompressMemoryIndirectCountNV(dispatch, commandBuffer, indirectCommandsAddress, indirectCommandsCountAddress, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDecompressMemoryNV(VkCommandBuffer commandBuffer, uint32_t decompressRegionCount, const VkDecompressMemoryRegionNV *pDecompressMemoryRegions) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDecompressMemoryNV(dispatch, commandBuffer, decompressRegionCount, pDecompressMemoryRegions);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatch(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDispatch(dispatch, commandBuffer, groupCountX, groupCountY, groupCountZ);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchBase(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchBase(dispatch, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchBaseKHR(VkCommandBuffer commandBuffer, uint32_t baseGroupX, uint32_t baseGroupY, uint32_t baseGroupZ, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchBaseKHR(dispatch, commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchDataGraphARM(VkCommandBuffer commandBuffer, VkDataGraphPipelineSessionARM session, const VkDataGraphPipelineDispatchInfoARM *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchDataGraphARM(dispatch, commandBuffer, session, pInfo);
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchGraphAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchGraphAMDX(dispatch, commandBuffer, scratch, scratchSize, pCountInfo);
  }

#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchGraphIndirectAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, const VkDispatchGraphCountInfoAMDX *pCountInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchGraphIndirectAMDX(dispatch, commandBuffer, scratch, scratchSize, pCountInfo);
  }

#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchGraphIndirectCountAMDX(VkCommandBuffer commandBuffer, VkDeviceAddress scratch, VkDeviceSize scratchSize, VkDeviceAddress countInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchGraphIndirectCountAMDX(dispatch, commandBuffer, scratch, scratchSize, countInfo);
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchIndirect(dispatch, commandBuffer, buffer, offset);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDispatchTileQCOM(VkCommandBuffer commandBuffer, const VkDispatchTileInfoQCOM *pDispatchTileInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDispatchTileQCOM(dispatch, commandBuffer, pDispatchTileInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDraw(VkCommandBuffer commandBuffer, uint32_t vertexCount, uint32_t instanceCount, uint32_t firstVertex, uint32_t firstInstance) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDraw(dispatch, commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawClusterHUAWEI(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawClusterHUAWEI(dispatch, commandBuffer, groupCountX, groupCountY, groupCountZ);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawClusterIndirectHUAWEI(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawClusterIndirectHUAWEI(dispatch, commandBuffer, buffer, offset);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndexed(VkCommandBuffer commandBuffer, uint32_t indexCount, uint32_t instanceCount, uint32_t firstIndex, int32_t vertexOffset, uint32_t firstInstance) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndexed(dispatch, commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndexedIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndexedIndirect(dispatch, commandBuffer, buffer, offset, drawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndexedIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndexedIndirectCount(dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndexedIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndexedIndirectCountAMD(dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndexedIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndexedIndirectCountKHR(dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndirect(dispatch, commandBuffer, buffer, offset, drawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndirectByteCountEXT(VkCommandBuffer commandBuffer, uint32_t instanceCount, uint32_t firstInstance, VkBuffer counterBuffer, VkDeviceSize counterBufferOffset, uint32_t counterOffset, uint32_t vertexStride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndirectByteCountEXT(dispatch, commandBuffer, instanceCount, firstInstance, counterBuffer, counterBufferOffset, counterOffset, vertexStride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndirectCount(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndirectCount(dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndirectCountAMD(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndirectCountAMD(dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawIndirectCountKHR(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawIndirectCountKHR(dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksEXT(VkCommandBuffer commandBuffer, uint32_t groupCountX, uint32_t groupCountY, uint32_t groupCountZ) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksEXT(dispatch, commandBuffer, groupCountX, groupCountY, groupCountZ);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksIndirectCountEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksIndirectCountEXT(dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksIndirectCountNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, VkBuffer countBuffer, VkDeviceSize countBufferOffset, uint32_t maxDrawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksIndirectCountNV(dispatch, commandBuffer, buffer, offset, countBuffer, countBufferOffset, maxDrawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksIndirectEXT(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksIndirectEXT(dispatch, commandBuffer, buffer, offset, drawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksIndirectNV(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset, uint32_t drawCount, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksIndirectNV(dispatch, commandBuffer, buffer, offset, drawCount, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMeshTasksNV(VkCommandBuffer commandBuffer, uint32_t taskCount, uint32_t firstTask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMeshTasksNV(dispatch, commandBuffer, taskCount, firstTask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMultiEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawInfoEXT *pVertexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMultiEXT(dispatch, commandBuffer, drawCount, pVertexInfo, instanceCount, firstInstance, stride);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdDrawMultiIndexedEXT(VkCommandBuffer commandBuffer, uint32_t drawCount, const VkMultiDrawIndexedInfoEXT *pIndexInfo, uint32_t instanceCount, uint32_t firstInstance, uint32_t stride, const int32_t *pVertexOffset) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdDrawMultiIndexedEXT(dispatch, commandBuffer, drawCount, pIndexInfo, instanceCount, firstInstance, stride, pVertexOffset);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEncodeVideoKHR(VkCommandBuffer commandBuffer, const VkVideoEncodeInfoKHR *pEncodeInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEncodeVideoKHR(dispatch, commandBuffer, pEncodeInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndConditionalRenderingEXT(VkCommandBuffer commandBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndConditionalRenderingEXT(dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndDebugUtilsLabelEXT(VkCommandBuffer commandBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndDebugUtilsLabelEXT(dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndPerTileExecutionQCOM(VkCommandBuffer commandBuffer, const VkPerTileEndInfoQCOM *pPerTileEndInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndPerTileExecutionQCOM(dispatch, commandBuffer, pPerTileEndInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndQuery(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndQuery(dispatch, commandBuffer, queryPool, query);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndQueryIndexedEXT(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t query, uint32_t index) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndQueryIndexedEXT(dispatch, commandBuffer, queryPool, query, index);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRenderPass(VkCommandBuffer commandBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndRenderPass(dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRenderPass2(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndRenderPass2(dispatch, commandBuffer, pSubpassEndInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRenderPass2KHR(VkCommandBuffer commandBuffer, const VkSubpassEndInfo *pSubpassEndInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndRenderPass2KHR(dispatch, commandBuffer, pSubpassEndInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRendering(VkCommandBuffer commandBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndRendering(dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRendering2EXT(VkCommandBuffer commandBuffer, const VkRenderingEndInfoEXT *pRenderingEndInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndRendering2EXT(dispatch, commandBuffer, pRenderingEndInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndRenderingKHR(VkCommandBuffer commandBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndRenderingKHR(dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndTransformFeedbackEXT(VkCommandBuffer commandBuffer, uint32_t firstCounterBuffer, uint32_t counterBufferCount, const VkBuffer *pCounterBuffers, const VkDeviceSize *pCounterBufferOffsets) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndTransformFeedbackEXT(dispatch, commandBuffer, firstCounterBuffer, counterBufferCount, pCounterBuffers, pCounterBufferOffsets);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdEndVideoCodingKHR(VkCommandBuffer commandBuffer, const VkVideoEndCodingInfoKHR *pEndCodingInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdEndVideoCodingKHR(dispatch, commandBuffer, pEndCodingInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdExecuteCommands(VkCommandBuffer commandBuffer, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdExecuteCommands(dispatch, commandBuffer, commandBufferCount, pCommandBuffers);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdExecuteGeneratedCommandsEXT(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdExecuteGeneratedCommandsEXT(dispatch, commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdExecuteGeneratedCommandsNV(VkCommandBuffer commandBuffer, VkBool32 isPreprocessed, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdExecuteGeneratedCommandsNV(dispatch, commandBuffer, isPreprocessed, pGeneratedCommandsInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdFillBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize size, uint32_t data) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdFillBuffer(dispatch, commandBuffer, dstBuffer, dstOffset, size, data);
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdInitializeGraphScratchMemoryAMDX(VkCommandBuffer commandBuffer, VkPipeline executionGraph, VkDeviceAddress scratch, VkDeviceSize scratchSize) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdInitializeGraphScratchMemoryAMDX(dispatch, commandBuffer, executionGraph, scratch, scratchSize);
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdInsertDebugUtilsLabelEXT(VkCommandBuffer commandBuffer, const VkDebugUtilsLabelEXT *pLabelInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdInsertDebugUtilsLabelEXT(dispatch, commandBuffer, pLabelInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdNextSubpass(VkCommandBuffer commandBuffer, VkSubpassContents contents) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdNextSubpass(dispatch, commandBuffer, contents);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdNextSubpass2(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdNextSubpass2(dispatch, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdNextSubpass2KHR(VkCommandBuffer commandBuffer, const VkSubpassBeginInfo *pSubpassBeginInfo, const VkSubpassEndInfo *pSubpassEndInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdNextSubpass2KHR(dispatch, commandBuffer, pSubpassBeginInfo, pSubpassEndInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdOpticalFlowExecuteNV(VkCommandBuffer commandBuffer, VkOpticalFlowSessionNV session, const VkOpticalFlowExecuteInfoNV *pExecuteInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdOpticalFlowExecuteNV(dispatch, commandBuffer, session, pExecuteInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPipelineBarrier(VkCommandBuffer commandBuffer, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, VkDependencyFlags dependencyFlags, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPipelineBarrier(dispatch, commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPipelineBarrier2(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPipelineBarrier2(dispatch, commandBuffer, pDependencyInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPipelineBarrier2KHR(VkCommandBuffer commandBuffer, const VkDependencyInfo *pDependencyInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPipelineBarrier2KHR(dispatch, commandBuffer, pDependencyInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPreprocessGeneratedCommandsEXT(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoEXT *pGeneratedCommandsInfo, VkCommandBuffer stateCommandBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPreprocessGeneratedCommandsEXT(dispatch, commandBuffer, pGeneratedCommandsInfo, stateCommandBuffer);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPreprocessGeneratedCommandsNV(VkCommandBuffer commandBuffer, const VkGeneratedCommandsInfoNV *pGeneratedCommandsInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPreprocessGeneratedCommandsNV(dispatch, commandBuffer, pGeneratedCommandsInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushConstants(VkCommandBuffer commandBuffer, VkPipelineLayout layout, VkShaderStageFlags stageFlags, uint32_t offset, uint32_t size, const void *pValues) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPushConstants(dispatch, commandBuffer, layout, stageFlags, offset, size, pValues);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushConstants2KHR(VkCommandBuffer commandBuffer, const VkPushConstantsInfo *pPushConstantsInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPushConstants2KHR(dispatch, commandBuffer, pPushConstantsInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushDescriptorSet2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetInfo *pPushDescriptorSetInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPushDescriptorSet2KHR(dispatch, commandBuffer, pPushDescriptorSetInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushDescriptorSetKHR(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t set, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPushDescriptorSetKHR(dispatch, commandBuffer, pipelineBindPoint, layout, set, descriptorWriteCount, pDescriptorWrites);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushDescriptorSetWithTemplate2KHR(VkCommandBuffer commandBuffer, const VkPushDescriptorSetWithTemplateInfo *pPushDescriptorSetWithTemplateInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPushDescriptorSetWithTemplate2KHR(dispatch, commandBuffer, pPushDescriptorSetWithTemplateInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdPushDescriptorSetWithTemplateKHR(VkCommandBuffer commandBuffer, VkDescriptorUpdateTemplate descriptorUpdateTemplate, VkPipelineLayout layout, uint32_t set, const void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdPushDescriptorSetWithTemplateKHR(dispatch, commandBuffer, descriptorUpdateTemplate, layout, set, pData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdResetEvent(dispatch, commandBuffer, event, stageMask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdResetEvent2(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdResetEvent2(dispatch, commandBuffer, event, stageMask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdResetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags2 stageMask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdResetEvent2KHR(dispatch, commandBuffer, event, stageMask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdResetQueryPool(VkCommandBuffer commandBuffer, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdResetQueryPool(dispatch, commandBuffer, queryPool, firstQuery, queryCount);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdResolveImage(VkCommandBuffer commandBuffer, VkImage srcImage, VkImageLayout srcImageLayout, VkImage dstImage, VkImageLayout dstImageLayout, uint32_t regionCount, const VkImageResolve *pRegions) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdResolveImage(dispatch, commandBuffer, srcImage, srcImageLayout, dstImage, dstImageLayout, regionCount, pRegions);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdResolveImage2(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdResolveImage2(dispatch, commandBuffer, pResolveImageInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdResolveImage2KHR(VkCommandBuffer commandBuffer, const VkResolveImageInfo2 *pResolveImageInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdResolveImage2KHR(dispatch, commandBuffer, pResolveImageInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetAlphaToCoverageEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToCoverageEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetAlphaToCoverageEnableEXT(dispatch, commandBuffer, alphaToCoverageEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetAlphaToOneEnableEXT(VkCommandBuffer commandBuffer, VkBool32 alphaToOneEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetAlphaToOneEnableEXT(dispatch, commandBuffer, alphaToOneEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetAttachmentFeedbackLoopEnableEXT(VkCommandBuffer commandBuffer, VkImageAspectFlags aspectMask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetAttachmentFeedbackLoopEnableEXT(dispatch, commandBuffer, aspectMask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetBlendConstants(VkCommandBuffer commandBuffer, const float blendConstants[4]) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetBlendConstants(dispatch, commandBuffer, blendConstants);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCheckpointNV(VkCommandBuffer commandBuffer, const void *pCheckpointMarker) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetCheckpointNV(dispatch, commandBuffer, pCheckpointMarker);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoarseSampleOrderNV(VkCommandBuffer commandBuffer, VkCoarseSampleOrderTypeNV sampleOrderType, uint32_t customSampleOrderCount, const VkCoarseSampleOrderCustomNV *pCustomSampleOrders) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoarseSampleOrderNV(dispatch, commandBuffer, sampleOrderType, customSampleOrderCount, pCustomSampleOrders);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetColorBlendAdvancedEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendAdvancedEXT *pColorBlendAdvanced) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetColorBlendAdvancedEXT(dispatch, commandBuffer, firstAttachment, attachmentCount, pColorBlendAdvanced);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetColorBlendEnableEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkBool32 *pColorBlendEnables) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetColorBlendEnableEXT(dispatch, commandBuffer, firstAttachment, attachmentCount, pColorBlendEnables);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetColorBlendEquationEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorBlendEquationEXT *pColorBlendEquations) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetColorBlendEquationEXT(dispatch, commandBuffer, firstAttachment, attachmentCount, pColorBlendEquations);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetColorWriteEnableEXT(VkCommandBuffer commandBuffer, uint32_t attachmentCount, const VkBool32 *pColorWriteEnables) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetColorWriteEnableEXT(dispatch, commandBuffer, attachmentCount, pColorWriteEnables);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetColorWriteMaskEXT(VkCommandBuffer commandBuffer, uint32_t firstAttachment, uint32_t attachmentCount, const VkColorComponentFlags *pColorWriteMasks) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetColorWriteMaskEXT(dispatch, commandBuffer, firstAttachment, attachmentCount, pColorWriteMasks);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetConservativeRasterizationModeEXT(VkCommandBuffer commandBuffer, VkConservativeRasterizationModeEXT conservativeRasterizationMode) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetConservativeRasterizationModeEXT(dispatch, commandBuffer, conservativeRasterizationMode);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageModulationModeNV(VkCommandBuffer commandBuffer, VkCoverageModulationModeNV coverageModulationMode) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageModulationModeNV(dispatch, commandBuffer, coverageModulationMode);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageModulationTableEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageModulationTableEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageModulationTableEnableNV(dispatch, commandBuffer, coverageModulationTableEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageModulationTableNV(VkCommandBuffer commandBuffer, uint32_t coverageModulationTableCount, const float *pCoverageModulationTable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageModulationTableNV(dispatch, commandBuffer, coverageModulationTableCount, pCoverageModulationTable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageReductionModeNV(VkCommandBuffer commandBuffer, VkCoverageReductionModeNV coverageReductionMode) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageReductionModeNV(dispatch, commandBuffer, coverageReductionMode);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageToColorEnableNV(VkCommandBuffer commandBuffer, VkBool32 coverageToColorEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageToColorEnableNV(dispatch, commandBuffer, coverageToColorEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCoverageToColorLocationNV(VkCommandBuffer commandBuffer, uint32_t coverageToColorLocation) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetCoverageToColorLocationNV(dispatch, commandBuffer, coverageToColorLocation);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCullMode(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetCullMode(dispatch, commandBuffer, cullMode);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetCullModeEXT(VkCommandBuffer commandBuffer, VkCullModeFlags cullMode) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetCullModeEXT(dispatch, commandBuffer, cullMode);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBias(VkCommandBuffer commandBuffer, float depthBiasConstantFactor, float depthBiasClamp, float depthBiasSlopeFactor) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBias(dispatch, commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBias2EXT(VkCommandBuffer commandBuffer, const VkDepthBiasInfoEXT *pDepthBiasInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBias2EXT(dispatch, commandBuffer, pDepthBiasInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBiasEnable(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBiasEnable(dispatch, commandBuffer, depthBiasEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBiasEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBiasEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBiasEnableEXT(dispatch, commandBuffer, depthBiasEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBounds(VkCommandBuffer commandBuffer, float minDepthBounds, float maxDepthBounds) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBounds(dispatch, commandBuffer, minDepthBounds, maxDepthBounds);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBoundsTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBoundsTestEnable(dispatch, commandBuffer, depthBoundsTestEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthBoundsTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthBoundsTestEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthBoundsTestEnableEXT(dispatch, commandBuffer, depthBoundsTestEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthClampEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClampEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthClampEnableEXT(dispatch, commandBuffer, depthClampEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthClampRangeEXT(VkCommandBuffer commandBuffer, VkDepthClampModeEXT depthClampMode, const VkDepthClampRangeEXT *pDepthClampRange) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthClampRangeEXT(dispatch, commandBuffer, depthClampMode, pDepthClampRange);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthClipEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthClipEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthClipEnableEXT(dispatch, commandBuffer, depthClipEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthClipNegativeOneToOneEXT(VkCommandBuffer commandBuffer, VkBool32 negativeOneToOne) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthClipNegativeOneToOneEXT(dispatch, commandBuffer, negativeOneToOne);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthCompareOp(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthCompareOp(dispatch, commandBuffer, depthCompareOp);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthCompareOpEXT(VkCommandBuffer commandBuffer, VkCompareOp depthCompareOp) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthCompareOpEXT(dispatch, commandBuffer, depthCompareOp);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthTestEnable(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthTestEnable(dispatch, commandBuffer, depthTestEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthTestEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthTestEnableEXT(dispatch, commandBuffer, depthTestEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthWriteEnable(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthWriteEnable(dispatch, commandBuffer, depthWriteEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDepthWriteEnableEXT(VkCommandBuffer commandBuffer, VkBool32 depthWriteEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDepthWriteEnableEXT(dispatch, commandBuffer, depthWriteEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDescriptorBufferOffsets2EXT(VkCommandBuffer commandBuffer, const VkSetDescriptorBufferOffsetsInfoEXT *pSetDescriptorBufferOffsetsInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDescriptorBufferOffsets2EXT(dispatch, commandBuffer, pSetDescriptorBufferOffsetsInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDescriptorBufferOffsetsEXT(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipelineLayout layout, uint32_t firstSet, uint32_t setCount, const uint32_t *pBufferIndices, const VkDeviceSize *pOffsets) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDescriptorBufferOffsetsEXT(dispatch, commandBuffer, pipelineBindPoint, layout, firstSet, setCount, pBufferIndices, pOffsets);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDeviceMask(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDeviceMask(dispatch, commandBuffer, deviceMask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDeviceMaskKHR(VkCommandBuffer commandBuffer, uint32_t deviceMask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDeviceMaskKHR(dispatch, commandBuffer, deviceMask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDiscardRectangleEXT(VkCommandBuffer commandBuffer, uint32_t firstDiscardRectangle, uint32_t discardRectangleCount, const VkRect2D *pDiscardRectangles) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDiscardRectangleEXT(dispatch, commandBuffer, firstDiscardRectangle, discardRectangleCount, pDiscardRectangles);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDiscardRectangleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 discardRectangleEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDiscardRectangleEnableEXT(dispatch, commandBuffer, discardRectangleEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetDiscardRectangleModeEXT(VkCommandBuffer commandBuffer, VkDiscardRectangleModeEXT discardRectangleMode) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetDiscardRectangleModeEXT(dispatch, commandBuffer, discardRectangleMode);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetEvent(dispatch, commandBuffer, event, stageMask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetEvent2(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetEvent2(dispatch, commandBuffer, event, pDependencyInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetEvent2KHR(VkCommandBuffer commandBuffer, VkEvent event, const VkDependencyInfo *pDependencyInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetEvent2KHR(dispatch, commandBuffer, event, pDependencyInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetExclusiveScissorEnableNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkBool32 *pExclusiveScissorEnables) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetExclusiveScissorEnableNV(dispatch, commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissorEnables);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetExclusiveScissorNV(VkCommandBuffer commandBuffer, uint32_t firstExclusiveScissor, uint32_t exclusiveScissorCount, const VkRect2D *pExclusiveScissors) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetExclusiveScissorNV(dispatch, commandBuffer, firstExclusiveScissor, exclusiveScissorCount, pExclusiveScissors);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetExtraPrimitiveOverestimationSizeEXT(VkCommandBuffer commandBuffer, float extraPrimitiveOverestimationSize) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetExtraPrimitiveOverestimationSizeEXT(dispatch, commandBuffer, extraPrimitiveOverestimationSize);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetFragmentShadingRateEnumNV(VkCommandBuffer commandBuffer, VkFragmentShadingRateNV shadingRate, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetFragmentShadingRateEnumNV(dispatch, commandBuffer, shadingRate, combinerOps);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetFragmentShadingRateKHR(VkCommandBuffer commandBuffer, const VkExtent2D *pFragmentSize, const VkFragmentShadingRateCombinerOpKHR combinerOps[2]) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetFragmentShadingRateKHR(dispatch, commandBuffer, pFragmentSize, combinerOps);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetFrontFace(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetFrontFace(dispatch, commandBuffer, frontFace);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetFrontFaceEXT(VkCommandBuffer commandBuffer, VkFrontFace frontFace) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetFrontFaceEXT(dispatch, commandBuffer, frontFace);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLineRasterizationModeEXT(VkCommandBuffer commandBuffer, VkLineRasterizationModeEXT lineRasterizationMode) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetLineRasterizationModeEXT(dispatch, commandBuffer, lineRasterizationMode);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLineStippleEXT(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetLineStippleEXT(dispatch, commandBuffer, lineStippleFactor, lineStipplePattern);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLineStippleEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stippledLineEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetLineStippleEnableEXT(dispatch, commandBuffer, stippledLineEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLineStippleKHR(VkCommandBuffer commandBuffer, uint32_t lineStippleFactor, uint16_t lineStipplePattern) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetLineStippleKHR(dispatch, commandBuffer, lineStippleFactor, lineStipplePattern);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLineWidth(VkCommandBuffer commandBuffer, float lineWidth) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetLineWidth(dispatch, commandBuffer, lineWidth);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLogicOpEXT(VkCommandBuffer commandBuffer, VkLogicOp logicOp) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetLogicOpEXT(dispatch, commandBuffer, logicOp);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetLogicOpEnableEXT(VkCommandBuffer commandBuffer, VkBool32 logicOpEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetLogicOpEnableEXT(dispatch, commandBuffer, logicOpEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPatchControlPointsEXT(VkCommandBuffer commandBuffer, uint32_t patchControlPoints) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetPatchControlPointsEXT(dispatch, commandBuffer, patchControlPoints);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CmdSetPerformanceMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceMarkerInfoINTEL *pMarkerInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::CmdSetPerformanceMarkerINTEL(dispatch, commandBuffer, pMarkerInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CmdSetPerformanceOverrideINTEL(VkCommandBuffer commandBuffer, const VkPerformanceOverrideInfoINTEL *pOverrideInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::CmdSetPerformanceOverrideINTEL(dispatch, commandBuffer, pOverrideInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CmdSetPerformanceStreamMarkerINTEL(VkCommandBuffer commandBuffer, const VkPerformanceStreamMarkerInfoINTEL *pMarkerInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::CmdSetPerformanceStreamMarkerINTEL(dispatch, commandBuffer, pMarkerInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPolygonModeEXT(VkCommandBuffer commandBuffer, VkPolygonMode polygonMode) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetPolygonModeEXT(dispatch, commandBuffer, polygonMode);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPrimitiveRestartEnable(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetPrimitiveRestartEnable(dispatch, commandBuffer, primitiveRestartEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPrimitiveRestartEnableEXT(VkCommandBuffer commandBuffer, VkBool32 primitiveRestartEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetPrimitiveRestartEnableEXT(dispatch, commandBuffer, primitiveRestartEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPrimitiveTopology(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetPrimitiveTopology(dispatch, commandBuffer, primitiveTopology);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetPrimitiveTopologyEXT(VkCommandBuffer commandBuffer, VkPrimitiveTopology primitiveTopology) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetPrimitiveTopologyEXT(dispatch, commandBuffer, primitiveTopology);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetProvokingVertexModeEXT(VkCommandBuffer commandBuffer, VkProvokingVertexModeEXT provokingVertexMode) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetProvokingVertexModeEXT(dispatch, commandBuffer, provokingVertexMode);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRasterizationSamplesEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits rasterizationSamples) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetRasterizationSamplesEXT(dispatch, commandBuffer, rasterizationSamples);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRasterizationStreamEXT(VkCommandBuffer commandBuffer, uint32_t rasterizationStream) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetRasterizationStreamEXT(dispatch, commandBuffer, rasterizationStream);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRasterizerDiscardEnable(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetRasterizerDiscardEnable(dispatch, commandBuffer, rasterizerDiscardEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRasterizerDiscardEnableEXT(VkCommandBuffer commandBuffer, VkBool32 rasterizerDiscardEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetRasterizerDiscardEnableEXT(dispatch, commandBuffer, rasterizerDiscardEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRayTracingPipelineStackSizeKHR(VkCommandBuffer commandBuffer, uint32_t pipelineStackSize) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetRayTracingPipelineStackSizeKHR(dispatch, commandBuffer, pipelineStackSize);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRenderingAttachmentLocationsKHR(VkCommandBuffer commandBuffer, const VkRenderingAttachmentLocationInfo *pLocationInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetRenderingAttachmentLocationsKHR(dispatch, commandBuffer, pLocationInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRenderingInputAttachmentIndicesKHR(VkCommandBuffer commandBuffer, const VkRenderingInputAttachmentIndexInfo *pInputAttachmentIndexInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetRenderingInputAttachmentIndicesKHR(dispatch, commandBuffer, pInputAttachmentIndexInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetRepresentativeFragmentTestEnableNV(VkCommandBuffer commandBuffer, VkBool32 representativeFragmentTestEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetRepresentativeFragmentTestEnableNV(dispatch, commandBuffer, representativeFragmentTestEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetSampleLocationsEXT(VkCommandBuffer commandBuffer, const VkSampleLocationsInfoEXT *pSampleLocationsInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetSampleLocationsEXT(dispatch, commandBuffer, pSampleLocationsInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetSampleLocationsEnableEXT(VkCommandBuffer commandBuffer, VkBool32 sampleLocationsEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetSampleLocationsEnableEXT(dispatch, commandBuffer, sampleLocationsEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetSampleMaskEXT(VkCommandBuffer commandBuffer, VkSampleCountFlagBits samples, const VkSampleMask *pSampleMask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetSampleMaskEXT(dispatch, commandBuffer, samples, pSampleMask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetScissor(VkCommandBuffer commandBuffer, uint32_t firstScissor, uint32_t scissorCount, const VkRect2D *pScissors) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetScissor(dispatch, commandBuffer, firstScissor, scissorCount, pScissors);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetScissorWithCount(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetScissorWithCount(dispatch, commandBuffer, scissorCount, pScissors);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetScissorWithCountEXT(VkCommandBuffer commandBuffer, uint32_t scissorCount, const VkRect2D *pScissors) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetScissorWithCountEXT(dispatch, commandBuffer, scissorCount, pScissors);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetShadingRateImageEnableNV(VkCommandBuffer commandBuffer, VkBool32 shadingRateImageEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetShadingRateImageEnableNV(dispatch, commandBuffer, shadingRateImageEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilCompareMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t compareMask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilCompareMask(dispatch, commandBuffer, faceMask, compareMask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilOp(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilOp(dispatch, commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilOpEXT(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, VkStencilOp failOp, VkStencilOp passOp, VkStencilOp depthFailOp, VkCompareOp compareOp) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilOpEXT(dispatch, commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilReference(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t reference) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilReference(dispatch, commandBuffer, faceMask, reference);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilTestEnable(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilTestEnable(dispatch, commandBuffer, stencilTestEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilTestEnableEXT(VkCommandBuffer commandBuffer, VkBool32 stencilTestEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilTestEnableEXT(dispatch, commandBuffer, stencilTestEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetStencilWriteMask(VkCommandBuffer commandBuffer, VkStencilFaceFlags faceMask, uint32_t writeMask) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetStencilWriteMask(dispatch, commandBuffer, faceMask, writeMask);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetTessellationDomainOriginEXT(VkCommandBuffer commandBuffer, VkTessellationDomainOrigin domainOrigin) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetTessellationDomainOriginEXT(dispatch, commandBuffer, domainOrigin);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetVertexInputEXT(VkCommandBuffer commandBuffer, uint32_t vertexBindingDescriptionCount, const VkVertexInputBindingDescription2EXT *pVertexBindingDescriptions, uint32_t vertexAttributeDescriptionCount, const VkVertexInputAttributeDescription2EXT *pVertexAttributeDescriptions) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetVertexInputEXT(dispatch, commandBuffer, vertexBindingDescriptionCount, pVertexBindingDescriptions, vertexAttributeDescriptionCount, pVertexAttributeDescriptions);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewport(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewport *pViewports) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewport(dispatch, commandBuffer, firstViewport, viewportCount, pViewports);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportShadingRatePaletteNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkShadingRatePaletteNV *pShadingRatePalettes) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportShadingRatePaletteNV(dispatch, commandBuffer, firstViewport, viewportCount, pShadingRatePalettes);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportSwizzleNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportSwizzleNV *pViewportSwizzles) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportSwizzleNV(dispatch, commandBuffer, firstViewport, viewportCount, pViewportSwizzles);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportWScalingEnableNV(VkCommandBuffer commandBuffer, VkBool32 viewportWScalingEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportWScalingEnableNV(dispatch, commandBuffer, viewportWScalingEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportWScalingNV(VkCommandBuffer commandBuffer, uint32_t firstViewport, uint32_t viewportCount, const VkViewportWScalingNV *pViewportWScalings) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportWScalingNV(dispatch, commandBuffer, firstViewport, viewportCount, pViewportWScalings);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportWithCount(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportWithCount(dispatch, commandBuffer, viewportCount, pViewports);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSetViewportWithCountEXT(VkCommandBuffer commandBuffer, uint32_t viewportCount, const VkViewport *pViewports) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSetViewportWithCountEXT(dispatch, commandBuffer, viewportCount, pViewports);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdSubpassShadingHUAWEI(VkCommandBuffer commandBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdSubpassShadingHUAWEI(dispatch, commandBuffer);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdTraceRaysIndirect2KHR(VkCommandBuffer commandBuffer, VkDeviceAddress indirectDeviceAddress) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdTraceRaysIndirect2KHR(dispatch, commandBuffer, indirectDeviceAddress);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdTraceRaysIndirectKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, VkDeviceAddress indirectDeviceAddress) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdTraceRaysIndirectKHR(dispatch, commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, indirectDeviceAddress);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdTraceRaysKHR(VkCommandBuffer commandBuffer, const VkStridedDeviceAddressRegionKHR *pRaygenShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pMissShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pHitShaderBindingTable, const VkStridedDeviceAddressRegionKHR *pCallableShaderBindingTable, uint32_t width, uint32_t height, uint32_t depth) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdTraceRaysKHR(dispatch, commandBuffer, pRaygenShaderBindingTable, pMissShaderBindingTable, pHitShaderBindingTable, pCallableShaderBindingTable, width, height, depth);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdTraceRaysNV(VkCommandBuffer commandBuffer, VkBuffer raygenShaderBindingTableBuffer, VkDeviceSize raygenShaderBindingOffset, VkBuffer missShaderBindingTableBuffer, VkDeviceSize missShaderBindingOffset, VkDeviceSize missShaderBindingStride, VkBuffer hitShaderBindingTableBuffer, VkDeviceSize hitShaderBindingOffset, VkDeviceSize hitShaderBindingStride, VkBuffer callableShaderBindingTableBuffer, VkDeviceSize callableShaderBindingOffset, VkDeviceSize callableShaderBindingStride, uint32_t width, uint32_t height, uint32_t depth) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdTraceRaysNV(dispatch, commandBuffer, raygenShaderBindingTableBuffer, raygenShaderBindingOffset, missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdUpdateBuffer(VkCommandBuffer commandBuffer, VkBuffer dstBuffer, VkDeviceSize dstOffset, VkDeviceSize dataSize, const void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdUpdateBuffer(dispatch, commandBuffer, dstBuffer, dstOffset, dataSize, pData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdUpdatePipelineIndirectBufferNV(VkCommandBuffer commandBuffer, VkPipelineBindPoint pipelineBindPoint, VkPipeline pipeline) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdUpdatePipelineIndirectBufferNV(dispatch, commandBuffer, pipelineBindPoint, pipeline);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWaitEvents(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, VkPipelineStageFlags srcStageMask, VkPipelineStageFlags dstStageMask, uint32_t memoryBarrierCount, const VkMemoryBarrier *pMemoryBarriers, uint32_t bufferMemoryBarrierCount, const VkBufferMemoryBarrier *pBufferMemoryBarriers, uint32_t imageMemoryBarrierCount, const VkImageMemoryBarrier *pImageMemoryBarriers) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWaitEvents(dispatch, commandBuffer, eventCount, pEvents, srcStageMask, dstStageMask, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWaitEvents2(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWaitEvents2(dispatch, commandBuffer, eventCount, pEvents, pDependencyInfos);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWaitEvents2KHR(VkCommandBuffer commandBuffer, uint32_t eventCount, const VkEvent *pEvents, const VkDependencyInfo *pDependencyInfos) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWaitEvents2KHR(dispatch, commandBuffer, eventCount, pEvents, pDependencyInfos);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteAccelerationStructuresPropertiesKHR(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWriteAccelerationStructuresPropertiesKHR(dispatch, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteAccelerationStructuresPropertiesNV(VkCommandBuffer commandBuffer, uint32_t accelerationStructureCount, const VkAccelerationStructureNV *pAccelerationStructures, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWriteAccelerationStructuresPropertiesNV(dispatch, commandBuffer, accelerationStructureCount, pAccelerationStructures, queryType, queryPool, firstQuery);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteBufferMarker2AMD(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWriteBufferMarker2AMD(dispatch, commandBuffer, stage, dstBuffer, dstOffset, marker);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteBufferMarkerAMD(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkBuffer dstBuffer, VkDeviceSize dstOffset, uint32_t marker) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWriteBufferMarkerAMD(dispatch, commandBuffer, pipelineStage, dstBuffer, dstOffset, marker);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteMicromapsPropertiesEXT(VkCommandBuffer commandBuffer, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, VkQueryPool queryPool, uint32_t firstQuery) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWriteMicromapsPropertiesEXT(dispatch, commandBuffer, micromapCount, pMicromaps, queryType, queryPool, firstQuery);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteTimestamp(VkCommandBuffer commandBuffer, VkPipelineStageFlagBits pipelineStage, VkQueryPool queryPool, uint32_t query) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWriteTimestamp(dispatch, commandBuffer, pipelineStage, queryPool, query);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteTimestamp2(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWriteTimestamp2(dispatch, commandBuffer, stage, queryPool, query);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_CmdWriteTimestamp2KHR(VkCommandBuffer commandBuffer, VkPipelineStageFlags2 stage, VkQueryPool queryPool, uint32_t query) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    DeviceOverrides::CmdWriteTimestamp2KHR(dispatch, commandBuffer, stage, queryPool, query);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CompileDeferredNV(VkDevice device, VkPipeline pipeline, uint32_t shader) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CompileDeferredNV(dispatch, device, pipeline, shader);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ConvertCooperativeVectorMatrixNV(VkDevice device, const VkConvertCooperativeVectorMatrixInfoNV *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ConvertCooperativeVectorMatrixNV(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CopyAccelerationStructureKHR(dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyAccelerationStructureToMemoryKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyAccelerationStructureToMemoryInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CopyAccelerationStructureToMemoryKHR(dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyImageToImageEXT(VkDevice device, const VkCopyImageToImageInfo *pCopyImageToImageInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CopyImageToImageEXT(dispatch, device, pCopyImageToImageInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyImageToMemoryEXT(VkDevice device, const VkCopyImageToMemoryInfo *pCopyImageToMemoryInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CopyImageToMemoryEXT(dispatch, device, pCopyImageToMemoryInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyMemoryToAccelerationStructureKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToAccelerationStructureInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CopyMemoryToAccelerationStructureKHR(dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyMemoryToImageEXT(VkDevice device, const VkCopyMemoryToImageInfo *pCopyMemoryToImageInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CopyMemoryToImageEXT(dispatch, device, pCopyMemoryToImageInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyMemoryToMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMemoryToMicromapInfoEXT *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CopyMemoryToMicromapEXT(dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyMicromapEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapInfoEXT *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CopyMicromapEXT(dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CopyMicromapToMemoryEXT(VkDevice device, VkDeferredOperationKHR deferredOperation, const VkCopyMicromapToMemoryInfoEXT *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CopyMicromapToMemoryEXT(dispatch, device, deferredOperation, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateAccelerationStructureKHR(VkDevice device, const VkAccelerationStructureCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureKHR *pAccelerationStructure) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateAccelerationStructureKHR(dispatch, device, pCreateInfo, pAllocator, pAccelerationStructure);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateAccelerationStructureNV(VkDevice device, const VkAccelerationStructureCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkAccelerationStructureNV *pAccelerationStructure) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateAccelerationStructureNV(dispatch, device, pCreateInfo, pAllocator, pAccelerationStructure);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateBuffer(VkDevice device, const VkBufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBuffer *pBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateBuffer(dispatch, device, pCreateInfo, pAllocator, pBuffer);
    return ret;
  }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateBufferCollectionFUCHSIA(VkDevice device, const VkBufferCollectionCreateInfoFUCHSIA *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferCollectionFUCHSIA *pCollection) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateBufferCollectionFUCHSIA(dispatch, device, pCreateInfo, pAllocator, pCollection);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateBufferView(VkDevice device, const VkBufferViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkBufferView *pView) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateBufferView(dispatch, device, pCreateInfo, pAllocator, pView);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateCommandPool(VkDevice device, const VkCommandPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCommandPool *pCommandPool) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateCommandPool(dispatch, device, pCreateInfo, pAllocator, pCommandPool);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateComputePipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkComputePipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateComputePipelines(dispatch, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateCudaFunctionNV(VkDevice device, const VkCudaFunctionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaFunctionNV *pFunction) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateCudaFunctionNV(dispatch, device, pCreateInfo, pAllocator, pFunction);
    return ret;
  }

#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateCudaModuleNV(VkDevice device, const VkCudaModuleCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkCudaModuleNV *pModule) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateCudaModuleNV(dispatch, device, pCreateInfo, pAllocator, pModule);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDataGraphPipelineSessionARM(VkDevice device, const VkDataGraphPipelineSessionCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDataGraphPipelineSessionARM *pSession) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateDataGraphPipelineSessionARM(dispatch, device, pCreateInfo, pAllocator, pSession);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDataGraphPipelinesARM(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkDataGraphPipelineCreateInfoARM *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateDataGraphPipelinesARM(dispatch, device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDeferredOperationKHR(VkDevice device, const VkAllocationCallbacks *pAllocator, VkDeferredOperationKHR *pDeferredOperation) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateDeferredOperationKHR(dispatch, device, pAllocator, pDeferredOperation);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDescriptorPool(VkDevice device, const VkDescriptorPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorPool *pDescriptorPool) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateDescriptorPool(dispatch, device, pCreateInfo, pAllocator, pDescriptorPool);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDescriptorSetLayout(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorSetLayout *pSetLayout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateDescriptorSetLayout(dispatch, device, pCreateInfo, pAllocator, pSetLayout);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDescriptorUpdateTemplate(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateDescriptorUpdateTemplate(dispatch, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateDescriptorUpdateTemplateKHR(VkDevice device, const VkDescriptorUpdateTemplateCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkDescriptorUpdateTemplate *pDescriptorUpdateTemplate) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateDescriptorUpdateTemplateKHR(dispatch, device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateEvent(VkDevice device, const VkEventCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkEvent *pEvent) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateEvent(dispatch, device, pCreateInfo, pAllocator, pEvent);
    return ret;
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateExecutionGraphPipelinesAMDX(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkExecutionGraphPipelineCreateInfoAMDX *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateExecutionGraphPipelinesAMDX(dispatch, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateExternalComputeQueueNV(VkDevice device, const VkExternalComputeQueueCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkExternalComputeQueueNV *pExternalQueue) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateExternalComputeQueueNV(dispatch, device, pCreateInfo, pAllocator, pExternalQueue);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateFence(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateFence(dispatch, device, pCreateInfo, pAllocator, pFence);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateFramebuffer(VkDevice device, const VkFramebufferCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFramebuffer *pFramebuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateFramebuffer(dispatch, device, pCreateInfo, pAllocator, pFramebuffer);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateGraphicsPipelines(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkGraphicsPipelineCreateInfo *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateGraphicsPipelines(dispatch, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateImage(VkDevice device, const VkImageCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImage *pImage) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateImage(dispatch, device, pCreateInfo, pAllocator, pImage);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateImageView(VkDevice device, const VkImageViewCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkImageView *pView) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateImageView(dispatch, device, pCreateInfo, pAllocator, pView);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateIndirectCommandsLayoutEXT(VkDevice device, const VkIndirectCommandsLayoutCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutEXT *pIndirectCommandsLayout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateIndirectCommandsLayoutEXT(dispatch, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateIndirectCommandsLayoutNV(VkDevice device, const VkIndirectCommandsLayoutCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectCommandsLayoutNV *pIndirectCommandsLayout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateIndirectCommandsLayoutNV(dispatch, device, pCreateInfo, pAllocator, pIndirectCommandsLayout);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateIndirectExecutionSetEXT(VkDevice device, const VkIndirectExecutionSetCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkIndirectExecutionSetEXT *pIndirectExecutionSet) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateIndirectExecutionSetEXT(dispatch, device, pCreateInfo, pAllocator, pIndirectExecutionSet);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateMicromapEXT(VkDevice device, const VkMicromapCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkMicromapEXT *pMicromap) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateMicromapEXT(dispatch, device, pCreateInfo, pAllocator, pMicromap);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateOpticalFlowSessionNV(VkDevice device, const VkOpticalFlowSessionCreateInfoNV *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkOpticalFlowSessionNV *pSession) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateOpticalFlowSessionNV(dispatch, device, pCreateInfo, pAllocator, pSession);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreatePipelineBinariesKHR(VkDevice device, const VkPipelineBinaryCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineBinaryHandlesInfoKHR *pBinaries) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreatePipelineBinariesKHR(dispatch, device, pCreateInfo, pAllocator, pBinaries);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreatePipelineCache(VkDevice device, const VkPipelineCacheCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineCache *pPipelineCache) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreatePipelineCache(dispatch, device, pCreateInfo, pAllocator, pPipelineCache);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreatePipelineLayout(VkDevice device, const VkPipelineLayoutCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPipelineLayout *pPipelineLayout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreatePipelineLayout(dispatch, device, pCreateInfo, pAllocator, pPipelineLayout);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreatePrivateDataSlot(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreatePrivateDataSlot(dispatch, device, pCreateInfo, pAllocator, pPrivateDataSlot);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreatePrivateDataSlotEXT(VkDevice device, const VkPrivateDataSlotCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkPrivateDataSlot *pPrivateDataSlot) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreatePrivateDataSlotEXT(dispatch, device, pCreateInfo, pAllocator, pPrivateDataSlot);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateQueryPool(VkDevice device, const VkQueryPoolCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkQueryPool *pQueryPool) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateQueryPool(dispatch, device, pCreateInfo, pAllocator, pQueryPool);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateRayTracingPipelinesKHR(VkDevice device, VkDeferredOperationKHR deferredOperation, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateRayTracingPipelinesKHR(dispatch, device, deferredOperation, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateRayTracingPipelinesNV(VkDevice device, VkPipelineCache pipelineCache, uint32_t createInfoCount, const VkRayTracingPipelineCreateInfoNV *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkPipeline *pPipelines) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateRayTracingPipelinesNV(dispatch, device, pipelineCache, createInfoCount, pCreateInfos, pAllocator, pPipelines);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateRenderPass(VkDevice device, const VkRenderPassCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateRenderPass(dispatch, device, pCreateInfo, pAllocator, pRenderPass);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateRenderPass2(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateRenderPass2(dispatch, device, pCreateInfo, pAllocator, pRenderPass);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateRenderPass2KHR(VkDevice device, const VkRenderPassCreateInfo2 *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkRenderPass *pRenderPass) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateRenderPass2KHR(dispatch, device, pCreateInfo, pAllocator, pRenderPass);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSampler(VkDevice device, const VkSamplerCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSampler *pSampler) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateSampler(dispatch, device, pCreateInfo, pAllocator, pSampler);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSamplerYcbcrConversion(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateSamplerYcbcrConversion(dispatch, device, pCreateInfo, pAllocator, pYcbcrConversion);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSamplerYcbcrConversionKHR(VkDevice device, const VkSamplerYcbcrConversionCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSamplerYcbcrConversion *pYcbcrConversion) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateSamplerYcbcrConversionKHR(dispatch, device, pCreateInfo, pAllocator, pYcbcrConversion);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSemaphore(VkDevice device, const VkSemaphoreCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSemaphore *pSemaphore) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateSemaphore(dispatch, device, pCreateInfo, pAllocator, pSemaphore);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateShaderModule(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkShaderModule *pShaderModule) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateShaderModule(dispatch, device, pCreateInfo, pAllocator, pShaderModule);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateShadersEXT(VkDevice device, uint32_t createInfoCount, const VkShaderCreateInfoEXT *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkShaderEXT *pShaders) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateShadersEXT(dispatch, device, createInfoCount, pCreateInfos, pAllocator, pShaders);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSharedSwapchainsKHR(VkDevice device, uint32_t swapchainCount, const VkSwapchainCreateInfoKHR *pCreateInfos, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchains) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateSharedSwapchainsKHR(dispatch, device, swapchainCount, pCreateInfos, pAllocator, pSwapchains);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateSwapchainKHR(VkDevice device, const VkSwapchainCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkSwapchainKHR *pSwapchain) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateSwapchainKHR(dispatch, device, pCreateInfo, pAllocator, pSwapchain);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateTensorARM(VkDevice device, const VkTensorCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorARM *pTensor) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateTensorARM(dispatch, device, pCreateInfo, pAllocator, pTensor);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateTensorViewARM(VkDevice device, const VkTensorViewCreateInfoARM *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkTensorViewARM *pView) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateTensorViewARM(dispatch, device, pCreateInfo, pAllocator, pView);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateValidationCacheEXT(VkDevice device, const VkValidationCacheCreateInfoEXT *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkValidationCacheEXT *pValidationCache) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateValidationCacheEXT(dispatch, device, pCreateInfo, pAllocator, pValidationCache);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateVideoSessionKHR(VkDevice device, const VkVideoSessionCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionKHR *pVideoSession) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateVideoSessionKHR(dispatch, device, pCreateInfo, pAllocator, pVideoSession);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_CreateVideoSessionParametersKHR(VkDevice device, const VkVideoSessionParametersCreateInfoKHR *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkVideoSessionParametersKHR *pVideoSessionParameters) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::CreateVideoSessionParametersKHR(dispatch, device, pCreateInfo, pAllocator, pVideoSessionParameters);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_DebugMarkerSetObjectNameEXT(VkDevice device, const VkDebugMarkerObjectNameInfoEXT *pNameInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::DebugMarkerSetObjectNameEXT(dispatch, device, pNameInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_DebugMarkerSetObjectTagEXT(VkDevice device, const VkDebugMarkerObjectTagInfoEXT *pTagInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::DebugMarkerSetObjectTagEXT(dispatch, device, pTagInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_DeferredOperationJoinKHR(VkDevice device, VkDeferredOperationKHR operation) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::DeferredOperationJoinKHR(dispatch, device, operation);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyAccelerationStructureKHR(VkDevice device, VkAccelerationStructureKHR accelerationStructure, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyAccelerationStructureKHR(dispatch, device, accelerationStructure, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyAccelerationStructureNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyAccelerationStructureNV(dispatch, device, accelerationStructure, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyBuffer(VkDevice device, VkBuffer buffer, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyBuffer(dispatch, device, buffer, pAllocator);
  }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyBufferCollectionFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyBufferCollectionFUCHSIA(dispatch, device, collection, pAllocator);
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyBufferView(VkDevice device, VkBufferView bufferView, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyBufferView(dispatch, device, bufferView, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyCommandPool(VkDevice device, VkCommandPool commandPool, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyCommandPool(dispatch, device, commandPool, pAllocator);
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyCudaFunctionNV(VkDevice device, VkCudaFunctionNV function, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyCudaFunctionNV(dispatch, device, function, pAllocator);
  }

#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyCudaModuleNV(VkDevice device, VkCudaModuleNV module, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyCudaModuleNV(dispatch, device, module, pAllocator);
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDataGraphPipelineSessionARM(VkDevice device, VkDataGraphPipelineSessionARM session, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyDataGraphPipelineSessionARM(dispatch, device, session, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDeferredOperationKHR(VkDevice device, VkDeferredOperationKHR operation, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyDeferredOperationKHR(dispatch, device, operation, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyDescriptorPool(dispatch, device, descriptorPool, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDescriptorSetLayout(VkDevice device, VkDescriptorSetLayout descriptorSetLayout, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyDescriptorSetLayout(dispatch, device, descriptorSetLayout, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDescriptorUpdateTemplate(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyDescriptorUpdateTemplate(dispatch, device, descriptorUpdateTemplate, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDescriptorUpdateTemplateKHR(VkDevice device, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyDescriptorUpdateTemplateKHR(dispatch, device, descriptorUpdateTemplate, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyDevice(VkDevice device, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyDevice(dispatch, device, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyEvent(VkDevice device, VkEvent event, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyEvent(dispatch, device, event, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyExternalComputeQueueNV(VkDevice device, VkExternalComputeQueueNV externalQueue, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyExternalComputeQueueNV(dispatch, device, externalQueue, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyFence(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyFence(dispatch, device, fence, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyFramebuffer(VkDevice device, VkFramebuffer framebuffer, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyFramebuffer(dispatch, device, framebuffer, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyImage(VkDevice device, VkImage image, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyImage(dispatch, device, image, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyImageView(VkDevice device, VkImageView imageView, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyImageView(dispatch, device, imageView, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyIndirectCommandsLayoutEXT(VkDevice device, VkIndirectCommandsLayoutEXT indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyIndirectCommandsLayoutEXT(dispatch, device, indirectCommandsLayout, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyIndirectCommandsLayoutNV(VkDevice device, VkIndirectCommandsLayoutNV indirectCommandsLayout, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyIndirectCommandsLayoutNV(dispatch, device, indirectCommandsLayout, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyIndirectExecutionSetEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyIndirectExecutionSetEXT(dispatch, device, indirectExecutionSet, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyMicromapEXT(VkDevice device, VkMicromapEXT micromap, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyMicromapEXT(dispatch, device, micromap, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyOpticalFlowSessionNV(VkDevice device, VkOpticalFlowSessionNV session, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyOpticalFlowSessionNV(dispatch, device, session, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPipeline(VkDevice device, VkPipeline pipeline, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyPipeline(dispatch, device, pipeline, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPipelineBinaryKHR(VkDevice device, VkPipelineBinaryKHR pipelineBinary, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyPipelineBinaryKHR(dispatch, device, pipelineBinary, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPipelineCache(VkDevice device, VkPipelineCache pipelineCache, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyPipelineCache(dispatch, device, pipelineCache, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPipelineLayout(VkDevice device, VkPipelineLayout pipelineLayout, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyPipelineLayout(dispatch, device, pipelineLayout, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPrivateDataSlot(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyPrivateDataSlot(dispatch, device, privateDataSlot, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyPrivateDataSlotEXT(VkDevice device, VkPrivateDataSlot privateDataSlot, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyPrivateDataSlotEXT(dispatch, device, privateDataSlot, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyQueryPool(VkDevice device, VkQueryPool queryPool, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyQueryPool(dispatch, device, queryPool, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyRenderPass(VkDevice device, VkRenderPass renderPass, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyRenderPass(dispatch, device, renderPass, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroySampler(VkDevice device, VkSampler sampler, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroySampler(dispatch, device, sampler, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroySamplerYcbcrConversion(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroySamplerYcbcrConversion(dispatch, device, ycbcrConversion, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroySamplerYcbcrConversionKHR(VkDevice device, VkSamplerYcbcrConversion ycbcrConversion, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroySamplerYcbcrConversionKHR(dispatch, device, ycbcrConversion, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroySemaphore(VkDevice device, VkSemaphore semaphore, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroySemaphore(dispatch, device, semaphore, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyShaderEXT(VkDevice device, VkShaderEXT shader, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyShaderEXT(dispatch, device, shader, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyShaderModule(VkDevice device, VkShaderModule shaderModule, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyShaderModule(dispatch, device, shaderModule, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroySwapchainKHR(dispatch, device, swapchain, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyTensorARM(VkDevice device, VkTensorARM tensor, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyTensorARM(dispatch, device, tensor, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyTensorViewARM(VkDevice device, VkTensorViewARM tensorView, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyTensorViewARM(dispatch, device, tensorView, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyValidationCacheEXT(VkDevice device, VkValidationCacheEXT validationCache, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyValidationCacheEXT(dispatch, device, validationCache, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyVideoSessionKHR(VkDevice device, VkVideoSessionKHR videoSession, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyVideoSessionKHR(dispatch, device, videoSession, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_DestroyVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::DestroyVideoSessionParametersKHR(dispatch, device, videoSessionParameters, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_DeviceWaitIdle(VkDevice device) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::DeviceWaitIdle(dispatch, device);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_DisplayPowerControlEXT(VkDevice device, VkDisplayKHR display, const VkDisplayPowerInfoEXT *pDisplayPowerInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::DisplayPowerControlEXT(dispatch, device, display, pDisplayPowerInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_EndCommandBuffer(VkCommandBuffer commandBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::EndCommandBuffer(dispatch, commandBuffer);
    return ret;
  }

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_ExportMetalObjectsEXT(VkDevice device, VkExportMetalObjectsInfoEXT *pMetalObjectsInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::ExportMetalObjectsEXT(dispatch, device, pMetalObjectsInfo);
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_FlushMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::FlushMappedMemoryRanges(dispatch, device, memoryRangeCount, pMemoryRanges);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::FreeCommandBuffers(dispatch, device, commandPool, commandBufferCount, pCommandBuffers);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_FreeDescriptorSets(VkDevice device, VkDescriptorPool descriptorPool, uint32_t descriptorSetCount, const VkDescriptorSet *pDescriptorSets) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::FreeDescriptorSets(dispatch, device, descriptorPool, descriptorSetCount, pDescriptorSets);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_FreeMemory(VkDevice device, VkDeviceMemory memory, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::FreeMemory(dispatch, device, memory, pAllocator);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetAccelerationStructureBuildSizesKHR(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkAccelerationStructureBuildGeometryInfoKHR *pBuildInfo, const uint32_t *pMaxPrimitiveCounts, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetAccelerationStructureBuildSizesKHR(dispatch, device, buildType, pBuildInfo, pMaxPrimitiveCounts, pSizeInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkDeviceAddress wrap_GetAccelerationStructureDeviceAddressKHR(VkDevice device, const VkAccelerationStructureDeviceAddressInfoKHR *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkDeviceAddress ret = DeviceOverrides::GetAccelerationStructureDeviceAddressKHR(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetAccelerationStructureHandleNV(VkDevice device, VkAccelerationStructureNV accelerationStructure, size_t dataSize, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetAccelerationStructureHandleNV(dispatch, device, accelerationStructure, dataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetAccelerationStructureMemoryRequirementsNV(VkDevice device, const VkAccelerationStructureMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2KHR *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetAccelerationStructureMemoryRequirementsNV(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkAccelerationStructureCaptureDescriptorDataInfoEXT *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetAccelerationStructureOpaqueCaptureDescriptorDataEXT(dispatch, device, pInfo, pData);
    return ret;
  }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetAndroidHardwareBufferPropertiesANDROID(VkDevice device, const struct AHardwareBuffer *buffer, VkAndroidHardwareBufferPropertiesANDROID *pProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetAndroidHardwareBufferPropertiesANDROID(dispatch, device, buffer, pProperties);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetBufferCollectionPropertiesFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, VkBufferCollectionPropertiesFUCHSIA *pProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetBufferCollectionPropertiesFUCHSIA(dispatch, device, collection, pProperties);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkDeviceAddress wrap_GetBufferDeviceAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkDeviceAddress ret = DeviceOverrides::GetBufferDeviceAddress(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkDeviceAddress wrap_GetBufferDeviceAddressEXT(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkDeviceAddress ret = DeviceOverrides::GetBufferDeviceAddressEXT(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkDeviceAddress wrap_GetBufferDeviceAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkDeviceAddress ret = DeviceOverrides::GetBufferDeviceAddressKHR(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetBufferMemoryRequirements(VkDevice device, VkBuffer buffer, VkMemoryRequirements *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetBufferMemoryRequirements(dispatch, device, buffer, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetBufferMemoryRequirements2(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetBufferMemoryRequirements2(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetBufferMemoryRequirements2KHR(VkDevice device, const VkBufferMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetBufferMemoryRequirements2KHR(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static uint64_t wrap_GetBufferOpaqueCaptureAddress(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    uint64_t ret = DeviceOverrides::GetBufferOpaqueCaptureAddress(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static uint64_t wrap_GetBufferOpaqueCaptureAddressKHR(VkDevice device, const VkBufferDeviceAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    uint64_t ret = DeviceOverrides::GetBufferOpaqueCaptureAddressKHR(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetBufferOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkBufferCaptureDescriptorDataInfoEXT *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetBufferOpaqueCaptureDescriptorDataEXT(dispatch, device, pInfo, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetCalibratedTimestampsEXT(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetCalibratedTimestampsEXT(dispatch, device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetCalibratedTimestampsKHR(VkDevice device, uint32_t timestampCount, const VkCalibratedTimestampInfoKHR *pTimestampInfos, uint64_t *pTimestamps, uint64_t *pMaxDeviation) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetCalibratedTimestampsKHR(dispatch, device, timestampCount, pTimestampInfos, pTimestamps, pMaxDeviation);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetClusterAccelerationStructureBuildSizesNV(VkDevice device, const VkClusterAccelerationStructureInputInfoNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetClusterAccelerationStructureBuildSizesNV(dispatch, device, pInfo, pSizeInfo);
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetCudaModuleCacheNV(VkDevice device, VkCudaModuleNV module, size_t *pCacheSize, void *pCacheData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetCudaModuleCacheNV(dispatch, device, module, pCacheSize, pCacheData);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDataGraphPipelineAvailablePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t *pPropertiesCount, VkDataGraphPipelinePropertyARM *pProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetDataGraphPipelineAvailablePropertiesARM(dispatch, device, pPipelineInfo, pPropertiesCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDataGraphPipelinePropertiesARM(VkDevice device, const VkDataGraphPipelineInfoARM *pPipelineInfo, uint32_t propertiesCount, VkDataGraphPipelinePropertyQueryResultARM *pProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetDataGraphPipelinePropertiesARM(dispatch, device, pPipelineInfo, propertiesCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDataGraphPipelineSessionBindPointRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionBindPointRequirementsInfoARM *pInfo, uint32_t *pBindPointRequirementCount, VkDataGraphPipelineSessionBindPointRequirementARM *pBindPointRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetDataGraphPipelineSessionBindPointRequirementsARM(dispatch, device, pInfo, pBindPointRequirementCount, pBindPointRequirements);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDataGraphPipelineSessionMemoryRequirementsARM(VkDevice device, const VkDataGraphPipelineSessionMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDataGraphPipelineSessionMemoryRequirementsARM(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static uint32_t wrap_GetDeferredOperationMaxConcurrencyKHR(VkDevice device, VkDeferredOperationKHR operation) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    uint32_t ret = DeviceOverrides::GetDeferredOperationMaxConcurrencyKHR(dispatch, device, operation);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeferredOperationResultKHR(VkDevice device, VkDeferredOperationKHR operation) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetDeferredOperationResultKHR(dispatch, device, operation);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorEXT(VkDevice device, const VkDescriptorGetInfoEXT *pDescriptorInfo, size_t dataSize, void *pDescriptor) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDescriptorEXT(dispatch, device, pDescriptorInfo, dataSize, pDescriptor);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetHostMappingVALVE(VkDevice device, VkDescriptorSet descriptorSet, void **ppData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDescriptorSetHostMappingVALVE(dispatch, device, descriptorSet, ppData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetLayoutBindingOffsetEXT(VkDevice device, VkDescriptorSetLayout layout, uint32_t binding, VkDeviceSize *pOffset) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDescriptorSetLayoutBindingOffsetEXT(dispatch, device, layout, binding, pOffset);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetLayoutHostMappingInfoVALVE(VkDevice device, const VkDescriptorSetBindingReferenceVALVE *pBindingReference, VkDescriptorSetLayoutHostMappingInfoVALVE *pHostMapping) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDescriptorSetLayoutHostMappingInfoVALVE(dispatch, device, pBindingReference, pHostMapping);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetLayoutSizeEXT(VkDevice device, VkDescriptorSetLayout layout, VkDeviceSize *pLayoutSizeInBytes) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDescriptorSetLayoutSizeEXT(dispatch, device, layout, pLayoutSizeInBytes);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetLayoutSupport(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDescriptorSetLayoutSupport(dispatch, device, pCreateInfo, pSupport);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDescriptorSetLayoutSupportKHR(VkDevice device, const VkDescriptorSetLayoutCreateInfo *pCreateInfo, VkDescriptorSetLayoutSupport *pSupport) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDescriptorSetLayoutSupportKHR(dispatch, device, pCreateInfo, pSupport);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceAccelerationStructureCompatibilityKHR(VkDevice device, const VkAccelerationStructureVersionInfoKHR *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceAccelerationStructureCompatibilityKHR(dispatch, device, pVersionInfo, pCompatibility);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceBufferMemoryRequirements(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceBufferMemoryRequirements(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceBufferMemoryRequirementsKHR(VkDevice device, const VkDeviceBufferMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceBufferMemoryRequirementsKHR(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeviceFaultInfoEXT(VkDevice device, VkDeviceFaultCountsEXT *pFaultCounts, VkDeviceFaultInfoEXT *pFaultInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetDeviceFaultInfoEXT(dispatch, device, pFaultCounts, pFaultInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceGroupPeerMemoryFeatures(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceGroupPeerMemoryFeatures(dispatch, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceGroupPeerMemoryFeaturesKHR(VkDevice device, uint32_t heapIndex, uint32_t localDeviceIndex, uint32_t remoteDeviceIndex, VkPeerMemoryFeatureFlags *pPeerMemoryFeatures) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceGroupPeerMemoryFeaturesKHR(dispatch, device, heapIndex, localDeviceIndex, remoteDeviceIndex, pPeerMemoryFeatures);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeviceGroupPresentCapabilitiesKHR(VkDevice device, VkDeviceGroupPresentCapabilitiesKHR *pDeviceGroupPresentCapabilities) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetDeviceGroupPresentCapabilitiesKHR(dispatch, device, pDeviceGroupPresentCapabilities);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeviceGroupSurfacePresentModes2EXT(VkDevice device, const VkPhysicalDeviceSurfaceInfo2KHR *pSurfaceInfo, VkDeviceGroupPresentModeFlagsKHR *pModes) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetDeviceGroupSurfacePresentModes2EXT(dispatch, device, pSurfaceInfo, pModes);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeviceGroupSurfacePresentModesKHR(VkDevice device, VkSurfaceKHR surface, VkDeviceGroupPresentModeFlagsKHR *pModes) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetDeviceGroupSurfacePresentModesKHR(dispatch, device, surface, pModes);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceImageMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceImageMemoryRequirements(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceImageMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceImageMemoryRequirementsKHR(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceImageSparseMemoryRequirements(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceImageSparseMemoryRequirements(dispatch, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceImageSparseMemoryRequirementsKHR(VkDevice device, const VkDeviceImageMemoryRequirements *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceImageSparseMemoryRequirementsKHR(dispatch, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceImageSubresourceLayoutKHR(VkDevice device, const VkDeviceImageSubresourceInfo *pInfo, VkSubresourceLayout2 *pLayout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceImageSubresourceLayoutKHR(dispatch, device, pInfo, pLayout);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceMemoryCommitment(VkDevice device, VkDeviceMemory memory, VkDeviceSize *pCommittedMemoryInBytes) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceMemoryCommitment(dispatch, device, memory, pCommittedMemoryInBytes);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static uint64_t wrap_GetDeviceMemoryOpaqueCaptureAddress(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    uint64_t ret = DeviceOverrides::GetDeviceMemoryOpaqueCaptureAddress(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static uint64_t wrap_GetDeviceMemoryOpaqueCaptureAddressKHR(VkDevice device, const VkDeviceMemoryOpaqueCaptureAddressInfo *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    uint64_t ret = DeviceOverrides::GetDeviceMemoryOpaqueCaptureAddressKHR(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceMicromapCompatibilityEXT(VkDevice device, const VkMicromapVersionInfoEXT *pVersionInfo, VkAccelerationStructureCompatibilityKHR *pCompatibility) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceMicromapCompatibilityEXT(dispatch, device, pVersionInfo, pCompatibility);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceQueue(VkDevice device, uint32_t queueFamilyIndex, uint32_t queueIndex, VkQueue *pQueue) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceQueue(dispatch, device, queueFamilyIndex, queueIndex, pQueue);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceQueue2(VkDevice device, const VkDeviceQueueInfo2 *pQueueInfo, VkQueue *pQueue) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceQueue2(dispatch, device, pQueueInfo, pQueue);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(VkDevice device, VkRenderPass renderpass, VkExtent2D *pMaxWorkgroupSize) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI(dispatch, device, renderpass, pMaxWorkgroupSize);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetDeviceTensorMemoryRequirementsARM(VkDevice device, const VkDeviceTensorMemoryRequirementsARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetDeviceTensorMemoryRequirementsARM(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetDynamicRenderingTilePropertiesQCOM(VkDevice device, const VkRenderingInfo *pRenderingInfo, VkTilePropertiesQCOM *pProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetDynamicRenderingTilePropertiesQCOM(dispatch, device, pRenderingInfo, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetEncodedVideoSessionParametersKHR(VkDevice device, const VkVideoEncodeSessionParametersGetInfoKHR *pVideoSessionParametersInfo, VkVideoEncodeSessionParametersFeedbackInfoKHR *pFeedbackInfo, size_t *pDataSize, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetEncodedVideoSessionParametersKHR(dispatch, device, pVideoSessionParametersInfo, pFeedbackInfo, pDataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetEventStatus(VkDevice device, VkEvent event) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetEventStatus(dispatch, device, event);
    return ret;
  }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetExecutionGraphPipelineNodeIndexAMDX(VkDevice device, VkPipeline executionGraph, const VkPipelineShaderStageNodeCreateInfoAMDX *pNodeInfo, uint32_t *pNodeIndex) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetExecutionGraphPipelineNodeIndexAMDX(dispatch, device, executionGraph, pNodeInfo, pNodeIndex);
    return ret;
  }

#endif
#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetExecutionGraphPipelineScratchSizeAMDX(VkDevice device, VkPipeline executionGraph, VkExecutionGraphPipelineScratchSizeAMDX *pSizeInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetExecutionGraphPipelineScratchSizeAMDX(dispatch, device, executionGraph, pSizeInfo);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetExternalComputeQueueDataNV(VkExternalComputeQueueNV externalQueue, VkExternalComputeQueueDataParamsNV *params, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(externalQueue);
    DeviceOverrides::GetExternalComputeQueueDataNV(dispatch, externalQueue, params, pData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetFenceFdKHR(VkDevice device, const VkFenceGetFdInfoKHR *pGetFdInfo, int *pFd) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetFenceFdKHR(dispatch, device, pGetFdInfo, pFd);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetFenceStatus(VkDevice device, VkFence fence) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetFenceStatus(dispatch, device, fence);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetFenceWin32HandleKHR(VkDevice device, const VkFenceGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetFenceWin32HandleKHR(dispatch, device, pGetWin32HandleInfo, pHandle);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetFramebufferTilePropertiesQCOM(VkDevice device, VkFramebuffer framebuffer, uint32_t *pPropertiesCount, VkTilePropertiesQCOM *pProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetFramebufferTilePropertiesQCOM(dispatch, device, framebuffer, pPropertiesCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetGeneratedCommandsMemoryRequirementsEXT(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoEXT *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetGeneratedCommandsMemoryRequirementsEXT(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetGeneratedCommandsMemoryRequirementsNV(VkDevice device, const VkGeneratedCommandsMemoryRequirementsInfoNV *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetGeneratedCommandsMemoryRequirementsNV(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetImageDrmFormatModifierPropertiesEXT(VkDevice device, VkImage image, VkImageDrmFormatModifierPropertiesEXT *pProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetImageDrmFormatModifierPropertiesEXT(dispatch, device, image, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetImageMemoryRequirements(VkDevice device, VkImage image, VkMemoryRequirements *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetImageMemoryRequirements(dispatch, device, image, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetImageMemoryRequirements2(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetImageMemoryRequirements2(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetImageMemoryRequirements2KHR(VkDevice device, const VkImageMemoryRequirementsInfo2 *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetImageMemoryRequirements2KHR(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetImageOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageCaptureDescriptorDataInfoEXT *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetImageOpaqueCaptureDescriptorDataEXT(dispatch, device, pInfo, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSparseMemoryRequirements(VkDevice device, VkImage image, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements *pSparseMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetImageSparseMemoryRequirements(dispatch, device, image, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSparseMemoryRequirements2(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetImageSparseMemoryRequirements2(dispatch, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSparseMemoryRequirements2KHR(VkDevice device, const VkImageSparseMemoryRequirementsInfo2 *pInfo, uint32_t *pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2 *pSparseMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetImageSparseMemoryRequirements2KHR(dispatch, device, pInfo, pSparseMemoryRequirementCount, pSparseMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSubresourceLayout(VkDevice device, VkImage image, const VkImageSubresource *pSubresource, VkSubresourceLayout *pLayout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetImageSubresourceLayout(dispatch, device, image, pSubresource, pLayout);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSubresourceLayout2EXT(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetImageSubresourceLayout2EXT(dispatch, device, image, pSubresource, pLayout);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetImageSubresourceLayout2KHR(VkDevice device, VkImage image, const VkImageSubresource2 *pSubresource, VkSubresourceLayout2 *pLayout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetImageSubresourceLayout2KHR(dispatch, device, image, pSubresource, pLayout);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetImageViewOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkImageViewCaptureDescriptorDataInfoEXT *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetImageViewOpaqueCaptureDescriptorDataEXT(dispatch, device, pInfo, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetLatencyTimingsNV(VkDevice device, VkSwapchainKHR swapchain, VkGetLatencyMarkerInfoNV *pLatencyMarkerInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetLatencyTimingsNV(dispatch, device, swapchain, pLatencyMarkerInfo);
  }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryAndroidHardwareBufferANDROID(VkDevice device, const VkMemoryGetAndroidHardwareBufferInfoANDROID *pInfo, struct AHardwareBuffer **pBuffer) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryAndroidHardwareBufferANDROID(dispatch, device, pInfo, pBuffer);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryFdKHR(VkDevice device, const VkMemoryGetFdInfoKHR *pGetFdInfo, int *pFd) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryFdKHR(dispatch, device, pGetFdInfo, pFd);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryFdPropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, int fd, VkMemoryFdPropertiesKHR *pMemoryFdProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryFdPropertiesKHR(dispatch, device, handleType, fd, pMemoryFdProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryHostPointerPropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHostPointer, VkMemoryHostPointerPropertiesEXT *pMemoryHostPointerProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryHostPointerPropertiesEXT(dispatch, device, handleType, pHostPointer, pMemoryHostPointerProperties);
    return ret;
  }

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryMetalHandleEXT(VkDevice device, const VkMemoryGetMetalHandleInfoEXT *pGetMetalHandleInfo, void **pHandle) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryMetalHandleEXT(dispatch, device, pGetMetalHandleInfo, pHandle);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_METAL_EXT
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryMetalHandlePropertiesEXT(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, const void *pHandle, VkMemoryMetalHandlePropertiesEXT *pMemoryMetalHandleProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryMetalHandlePropertiesEXT(dispatch, device, handleType, pHandle, pMemoryMetalHandleProperties);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryRemoteAddressNV(VkDevice device, const VkMemoryGetRemoteAddressInfoNV *pMemoryGetRemoteAddressInfo, VkRemoteAddressNV *pAddress) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryRemoteAddressNV(dispatch, device, pMemoryGetRemoteAddressInfo, pAddress);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryWin32HandleKHR(VkDevice device, const VkMemoryGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryWin32HandleKHR(dispatch, device, pGetWin32HandleInfo, pHandle);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryWin32HandleNV(VkDevice device, VkDeviceMemory memory, VkExternalMemoryHandleTypeFlagsNV handleType, HANDLE *pHandle) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryWin32HandleNV(dispatch, device, memory, handleType, pHandle);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryWin32HandlePropertiesKHR(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, HANDLE handle, VkMemoryWin32HandlePropertiesKHR *pMemoryWin32HandleProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryWin32HandlePropertiesKHR(dispatch, device, handleType, handle, pMemoryWin32HandleProperties);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryZirconHandleFUCHSIA(VkDevice device, const VkMemoryGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryZirconHandleFUCHSIA(dispatch, device, pGetZirconHandleInfo, pZirconHandle);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetMemoryZirconHandlePropertiesFUCHSIA(VkDevice device, VkExternalMemoryHandleTypeFlagBits handleType, zx_handle_t zirconHandle, VkMemoryZirconHandlePropertiesFUCHSIA *pMemoryZirconHandleProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetMemoryZirconHandlePropertiesFUCHSIA(dispatch, device, handleType, zirconHandle, pMemoryZirconHandleProperties);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetMicromapBuildSizesEXT(VkDevice device, VkAccelerationStructureBuildTypeKHR buildType, const VkMicromapBuildInfoEXT *pBuildInfo, VkMicromapBuildSizesInfoEXT *pSizeInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetMicromapBuildSizesEXT(dispatch, device, buildType, pBuildInfo, pSizeInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPartitionedAccelerationStructuresBuildSizesNV(VkDevice device, const VkPartitionedAccelerationStructureInstancesInputNV *pInfo, VkAccelerationStructureBuildSizesInfoKHR *pSizeInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetPartitionedAccelerationStructuresBuildSizesNV(dispatch, device, pInfo, pSizeInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPastPresentationTimingGOOGLE(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pPresentationTimingCount, VkPastPresentationTimingGOOGLE *pPresentationTimings) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetPastPresentationTimingGOOGLE(dispatch, device, swapchain, pPresentationTimingCount, pPresentationTimings);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPerformanceParameterINTEL(VkDevice device, VkPerformanceParameterTypeINTEL parameter, VkPerformanceValueINTEL *pValue) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetPerformanceParameterINTEL(dispatch, device, parameter, pValue);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineBinaryDataKHR(VkDevice device, const VkPipelineBinaryDataInfoKHR *pInfo, VkPipelineBinaryKeyKHR *pPipelineBinaryKey, size_t *pPipelineBinaryDataSize, void *pPipelineBinaryData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineBinaryDataKHR(dispatch, device, pInfo, pPipelineBinaryKey, pPipelineBinaryDataSize, pPipelineBinaryData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineCacheData(VkDevice device, VkPipelineCache pipelineCache, size_t *pDataSize, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineCacheData(dispatch, device, pipelineCache, pDataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineExecutableInternalRepresentationsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR *pInternalRepresentations) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineExecutableInternalRepresentationsKHR(dispatch, device, pExecutableInfo, pInternalRepresentationCount, pInternalRepresentations);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineExecutablePropertiesKHR(VkDevice device, const VkPipelineInfoKHR *pPipelineInfo, uint32_t *pExecutableCount, VkPipelineExecutablePropertiesKHR *pProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineExecutablePropertiesKHR(dispatch, device, pPipelineInfo, pExecutableCount, pProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineExecutableStatisticsKHR(VkDevice device, const VkPipelineExecutableInfoKHR *pExecutableInfo, uint32_t *pStatisticCount, VkPipelineExecutableStatisticKHR *pStatistics) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineExecutableStatisticsKHR(dispatch, device, pExecutableInfo, pStatisticCount, pStatistics);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkDeviceAddress wrap_GetPipelineIndirectDeviceAddressNV(VkDevice device, const VkPipelineIndirectDeviceAddressInfoNV *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkDeviceAddress ret = DeviceOverrides::GetPipelineIndirectDeviceAddressNV(dispatch, device, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPipelineIndirectMemoryRequirementsNV(VkDevice device, const VkComputePipelineCreateInfo *pCreateInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetPipelineIndirectMemoryRequirementsNV(dispatch, device, pCreateInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelineKeyKHR(VkDevice device, const VkPipelineCreateInfoKHR *pPipelineCreateInfo, VkPipelineBinaryKeyKHR *pPipelineKey) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelineKeyKHR(dispatch, device, pPipelineCreateInfo, pPipelineKey);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetPipelinePropertiesEXT(VkDevice device, const VkPipelineInfoEXT *pPipelineInfo, VkBaseOutStructure *pPipelineProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetPipelinePropertiesEXT(dispatch, device, pPipelineInfo, pPipelineProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetPrivateData(dispatch, device, objectType, objectHandle, privateDataSlot, pData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetPrivateDataEXT(dispatch, device, objectType, objectHandle, privateDataSlot, pData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetQueryPoolResults(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount, size_t dataSize, void *pData, VkDeviceSize stride, VkQueryResultFlags flags) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetQueryPoolResults(dispatch, device, queryPool, firstQuery, queryCount, dataSize, pData, stride, flags);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetQueueCheckpointData2NV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointData2NV *pCheckpointData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    DeviceOverrides::GetQueueCheckpointData2NV(dispatch, queue, pCheckpointDataCount, pCheckpointData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetQueueCheckpointDataNV(VkQueue queue, uint32_t *pCheckpointDataCount, VkCheckpointDataNV *pCheckpointData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    DeviceOverrides::GetQueueCheckpointDataNV(dispatch, queue, pCheckpointDataCount, pCheckpointData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetRayTracingCaptureReplayShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetRayTracingCaptureReplayShaderGroupHandlesKHR(dispatch, device, pipeline, firstGroup, groupCount, dataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetRayTracingShaderGroupHandlesKHR(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetRayTracingShaderGroupHandlesKHR(dispatch, device, pipeline, firstGroup, groupCount, dataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetRayTracingShaderGroupHandlesNV(VkDevice device, VkPipeline pipeline, uint32_t firstGroup, uint32_t groupCount, size_t dataSize, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetRayTracingShaderGroupHandlesNV(dispatch, device, pipeline, firstGroup, groupCount, dataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkDeviceSize wrap_GetRayTracingShaderGroupStackSizeKHR(VkDevice device, VkPipeline pipeline, uint32_t group, VkShaderGroupShaderKHR groupShader) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkDeviceSize ret = DeviceOverrides::GetRayTracingShaderGroupStackSizeKHR(dispatch, device, pipeline, group, groupShader);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetRefreshCycleDurationGOOGLE(VkDevice device, VkSwapchainKHR swapchain, VkRefreshCycleDurationGOOGLE *pDisplayTimingProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetRefreshCycleDurationGOOGLE(dispatch, device, swapchain, pDisplayTimingProperties);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetRenderAreaGranularity(VkDevice device, VkRenderPass renderPass, VkExtent2D *pGranularity) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetRenderAreaGranularity(dispatch, device, renderPass, pGranularity);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetRenderingAreaGranularityKHR(VkDevice device, const VkRenderingAreaInfo *pRenderingAreaInfo, VkExtent2D *pGranularity) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetRenderingAreaGranularityKHR(dispatch, device, pRenderingAreaInfo, pGranularity);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSamplerOpaqueCaptureDescriptorDataEXT(VkDevice device, const VkSamplerCaptureDescriptorDataInfoEXT *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetSamplerOpaqueCaptureDescriptorDataEXT(dispatch, device, pInfo, pData);
    return ret;
  }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetScreenBufferPropertiesQNX(VkDevice device, const struct _screen_buffer *buffer, VkScreenBufferPropertiesQNX *pProperties) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetScreenBufferPropertiesQNX(dispatch, device, buffer, pProperties);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSemaphoreCounterValue(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetSemaphoreCounterValue(dispatch, device, semaphore, pValue);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSemaphoreCounterValueKHR(VkDevice device, VkSemaphore semaphore, uint64_t *pValue) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetSemaphoreCounterValueKHR(dispatch, device, semaphore, pValue);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSemaphoreFdKHR(VkDevice device, const VkSemaphoreGetFdInfoKHR *pGetFdInfo, int *pFd) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetSemaphoreFdKHR(dispatch, device, pGetFdInfo, pFd);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSemaphoreWin32HandleKHR(VkDevice device, const VkSemaphoreGetWin32HandleInfoKHR *pGetWin32HandleInfo, HANDLE *pHandle) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetSemaphoreWin32HandleKHR(dispatch, device, pGetWin32HandleInfo, pHandle);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkSemaphoreGetZirconHandleInfoFUCHSIA *pGetZirconHandleInfo, zx_handle_t *pZirconHandle) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetSemaphoreZirconHandleFUCHSIA(dispatch, device, pGetZirconHandleInfo, pZirconHandle);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetShaderBinaryDataEXT(VkDevice device, VkShaderEXT shader, size_t *pDataSize, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetShaderBinaryDataEXT(dispatch, device, shader, pDataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetShaderInfoAMD(VkDevice device, VkPipeline pipeline, VkShaderStageFlagBits shaderStage, VkShaderInfoTypeAMD infoType, size_t *pInfoSize, void *pInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetShaderInfoAMD(dispatch, device, pipeline, shaderStage, infoType, pInfoSize, pInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetShaderModuleCreateInfoIdentifierEXT(VkDevice device, const VkShaderModuleCreateInfo *pCreateInfo, VkShaderModuleIdentifierEXT *pIdentifier) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetShaderModuleCreateInfoIdentifierEXT(dispatch, device, pCreateInfo, pIdentifier);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetShaderModuleIdentifierEXT(VkDevice device, VkShaderModule shaderModule, VkShaderModuleIdentifierEXT *pIdentifier) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetShaderModuleIdentifierEXT(dispatch, device, shaderModule, pIdentifier);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSwapchainCounterEXT(VkDevice device, VkSwapchainKHR swapchain, VkSurfaceCounterFlagBitsEXT counter, uint64_t *pCounterValue) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetSwapchainCounterEXT(dispatch, device, swapchain, counter, pCounterValue);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSwapchainImagesKHR(VkDevice device, VkSwapchainKHR swapchain, uint32_t *pSwapchainImageCount, VkImage *pSwapchainImages) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetSwapchainImagesKHR(dispatch, device, swapchain, pSwapchainImageCount, pSwapchainImages);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetSwapchainStatusKHR(VkDevice device, VkSwapchainKHR swapchain) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetSwapchainStatusKHR(dispatch, device, swapchain);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_GetTensorMemoryRequirementsARM(VkDevice device, const VkTensorMemoryRequirementsInfoARM *pInfo, VkMemoryRequirements2 *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::GetTensorMemoryRequirementsARM(dispatch, device, pInfo, pMemoryRequirements);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetTensorOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorCaptureDescriptorDataInfoARM *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetTensorOpaqueCaptureDescriptorDataARM(dispatch, device, pInfo, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetTensorViewOpaqueCaptureDescriptorDataARM(VkDevice device, const VkTensorViewCaptureDescriptorDataInfoARM *pInfo, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetTensorViewOpaqueCaptureDescriptorDataARM(dispatch, device, pInfo, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetValidationCacheDataEXT(VkDevice device, VkValidationCacheEXT validationCache, size_t *pDataSize, void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetValidationCacheDataEXT(dispatch, device, validationCache, pDataSize, pData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_GetVideoSessionMemoryRequirementsKHR(VkDevice device, VkVideoSessionKHR videoSession, uint32_t *pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR *pMemoryRequirements) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::GetVideoSessionMemoryRequirementsKHR(dispatch, device, videoSession, pMemoryRequirementsCount, pMemoryRequirements);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ImportFenceFdKHR(VkDevice device, const VkImportFenceFdInfoKHR *pImportFenceFdInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ImportFenceFdKHR(dispatch, device, pImportFenceFdInfo);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ImportFenceWin32HandleKHR(VkDevice device, const VkImportFenceWin32HandleInfoKHR *pImportFenceWin32HandleInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ImportFenceWin32HandleKHR(dispatch, device, pImportFenceWin32HandleInfo);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ImportSemaphoreFdKHR(VkDevice device, const VkImportSemaphoreFdInfoKHR *pImportSemaphoreFdInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ImportSemaphoreFdKHR(dispatch, device, pImportSemaphoreFdInfo);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ImportSemaphoreWin32HandleKHR(VkDevice device, const VkImportSemaphoreWin32HandleInfoKHR *pImportSemaphoreWin32HandleInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ImportSemaphoreWin32HandleKHR(dispatch, device, pImportSemaphoreWin32HandleInfo);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ImportSemaphoreZirconHandleFUCHSIA(VkDevice device, const VkImportSemaphoreZirconHandleInfoFUCHSIA *pImportSemaphoreZirconHandleInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ImportSemaphoreZirconHandleFUCHSIA(dispatch, device, pImportSemaphoreZirconHandleInfo);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_InitializePerformanceApiINTEL(VkDevice device, const VkInitializePerformanceApiInfoINTEL *pInitializeInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::InitializePerformanceApiINTEL(dispatch, device, pInitializeInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_InvalidateMappedMemoryRanges(VkDevice device, uint32_t memoryRangeCount, const VkMappedMemoryRange *pMemoryRanges) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::InvalidateMappedMemoryRanges(dispatch, device, memoryRangeCount, pMemoryRanges);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_LatencySleepNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepInfoNV *pSleepInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::LatencySleepNV(dispatch, device, swapchain, pSleepInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_MapMemory(VkDevice device, VkDeviceMemory memory, VkDeviceSize offset, VkDeviceSize size, VkMemoryMapFlags flags, void **ppData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::MapMemory(dispatch, device, memory, offset, size, flags, ppData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_MapMemory2KHR(VkDevice device, const VkMemoryMapInfo *pMemoryMapInfo, void **ppData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::MapMemory2KHR(dispatch, device, pMemoryMapInfo, ppData);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_MergePipelineCaches(VkDevice device, VkPipelineCache dstCache, uint32_t srcCacheCount, const VkPipelineCache *pSrcCaches) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::MergePipelineCaches(dispatch, device, dstCache, srcCacheCount, pSrcCaches);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_MergeValidationCachesEXT(VkDevice device, VkValidationCacheEXT dstCache, uint32_t srcCacheCount, const VkValidationCacheEXT *pSrcCaches) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::MergeValidationCachesEXT(dispatch, device, dstCache, srcCacheCount, pSrcCaches);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_QueueBeginDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    DeviceOverrides::QueueBeginDebugUtilsLabelEXT(dispatch, queue, pLabelInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueBindSparse(VkQueue queue, uint32_t bindInfoCount, const VkBindSparseInfo *pBindInfo, VkFence fence) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    VkResult ret = DeviceOverrides::QueueBindSparse(dispatch, queue, bindInfoCount, pBindInfo, fence);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_QueueEndDebugUtilsLabelEXT(VkQueue queue) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    DeviceOverrides::QueueEndDebugUtilsLabelEXT(dispatch, queue);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_QueueInsertDebugUtilsLabelEXT(VkQueue queue, const VkDebugUtilsLabelEXT *pLabelInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    DeviceOverrides::QueueInsertDebugUtilsLabelEXT(dispatch, queue, pLabelInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_QueueNotifyOutOfBandNV(VkQueue queue, const VkOutOfBandQueueTypeInfoNV *pQueueTypeInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    DeviceOverrides::QueueNotifyOutOfBandNV(dispatch, queue, pQueueTypeInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueuePresentKHR(VkQueue queue, const VkPresentInfoKHR *pPresentInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    VkResult ret = DeviceOverrides::QueuePresentKHR(dispatch, queue, pPresentInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueSetPerformanceConfigurationINTEL(VkQueue queue, VkPerformanceConfigurationINTEL configuration) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    VkResult ret = DeviceOverrides::QueueSetPerformanceConfigurationINTEL(dispatch, queue, configuration);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueSubmit(VkQueue queue, uint32_t submitCount, const VkSubmitInfo *pSubmits, VkFence fence) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    VkResult ret = DeviceOverrides::QueueSubmit(dispatch, queue, submitCount, pSubmits, fence);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueSubmit2(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    VkResult ret = DeviceOverrides::QueueSubmit2(dispatch, queue, submitCount, pSubmits, fence);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueSubmit2KHR(VkQueue queue, uint32_t submitCount, const VkSubmitInfo2 *pSubmits, VkFence fence) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    VkResult ret = DeviceOverrides::QueueSubmit2KHR(dispatch, queue, submitCount, pSubmits, fence);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_QueueWaitIdle(VkQueue queue) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(queue);
    VkResult ret = DeviceOverrides::QueueWaitIdle(dispatch, queue);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_RegisterDeviceEventEXT(VkDevice device, const VkDeviceEventInfoEXT *pDeviceEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::RegisterDeviceEventEXT(dispatch, device, pDeviceEventInfo, pAllocator, pFence);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_RegisterDisplayEventEXT(VkDevice device, VkDisplayKHR display, const VkDisplayEventInfoEXT *pDisplayEventInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::RegisterDisplayEventEXT(dispatch, device, display, pDisplayEventInfo, pAllocator, pFence);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleaseCapturedPipelineDataKHR(VkDevice device, const VkReleaseCapturedPipelineDataInfoKHR *pInfo, const VkAllocationCallbacks *pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ReleaseCapturedPipelineDataKHR(dispatch, device, pInfo, pAllocator);
    return ret;
  }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleaseFullScreenExclusiveModeEXT(VkDevice device, VkSwapchainKHR swapchain) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ReleaseFullScreenExclusiveModeEXT(dispatch, device, swapchain);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleasePerformanceConfigurationINTEL(VkDevice device, VkPerformanceConfigurationINTEL configuration) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ReleasePerformanceConfigurationINTEL(dispatch, device, configuration);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_ReleaseProfilingLockKHR(VkDevice device) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::ReleaseProfilingLockKHR(dispatch, device);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleaseSwapchainImagesEXT(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ReleaseSwapchainImagesEXT(dispatch, device, pReleaseInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ReleaseSwapchainImagesKHR(VkDevice device, const VkReleaseSwapchainImagesInfoKHR *pReleaseInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ReleaseSwapchainImagesKHR(dispatch, device, pReleaseInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ResetCommandBuffer(VkCommandBuffer commandBuffer, VkCommandBufferResetFlags flags) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(commandBuffer);
    VkResult ret = DeviceOverrides::ResetCommandBuffer(dispatch, commandBuffer, flags);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ResetCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolResetFlags flags) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ResetCommandPool(dispatch, device, commandPool, flags);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ResetDescriptorPool(VkDevice device, VkDescriptorPool descriptorPool, VkDescriptorPoolResetFlags flags) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ResetDescriptorPool(dispatch, device, descriptorPool, flags);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ResetEvent(VkDevice device, VkEvent event) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ResetEvent(dispatch, device, event);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_ResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::ResetFences(dispatch, device, fenceCount, pFences);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_ResetQueryPool(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::ResetQueryPool(dispatch, device, queryPool, firstQuery, queryCount);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_ResetQueryPoolEXT(VkDevice device, VkQueryPool queryPool, uint32_t firstQuery, uint32_t queryCount) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::ResetQueryPoolEXT(dispatch, device, queryPool, firstQuery, queryCount);
  }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetBufferCollectionBufferConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkBufferConstraintsInfoFUCHSIA *pBufferConstraintsInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::SetBufferCollectionBufferConstraintsFUCHSIA(dispatch, device, collection, pBufferConstraintsInfo);
    return ret;
  }

#endif
#ifdef VK_USE_PLATFORM_FUCHSIA
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetBufferCollectionImageConstraintsFUCHSIA(VkDevice device, VkBufferCollectionFUCHSIA collection, const VkImageConstraintsInfoFUCHSIA *pImageConstraintsInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::SetBufferCollectionImageConstraintsFUCHSIA(dispatch, device, collection, pImageConstraintsInfo);
    return ret;
  }

#endif
  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetDebugUtilsObjectNameEXT(VkDevice device, const VkDebugUtilsObjectNameInfoEXT *pNameInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::SetDebugUtilsObjectNameEXT(dispatch, device, pNameInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetDebugUtilsObjectTagEXT(VkDevice device, const VkDebugUtilsObjectTagInfoEXT *pTagInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::SetDebugUtilsObjectTagEXT(dispatch, device, pTagInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_SetDeviceMemoryPriorityEXT(VkDevice device, VkDeviceMemory memory, float priority) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::SetDeviceMemoryPriorityEXT(dispatch, device, memory, priority);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetEvent(VkDevice device, VkEvent event) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::SetEvent(dispatch, device, event);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_SetHdrMetadataEXT(VkDevice device, uint32_t swapchainCount, const VkSwapchainKHR *pSwapchains, const VkHdrMetadataEXT *pMetadata) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::SetHdrMetadataEXT(dispatch, device, swapchainCount, pSwapchains, pMetadata);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_SetLatencyMarkerNV(VkDevice device, VkSwapchainKHR swapchain, const VkSetLatencyMarkerInfoNV *pLatencyMarkerInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::SetLatencyMarkerNV(dispatch, device, swapchain, pLatencyMarkerInfo);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetLatencySleepModeNV(VkDevice device, VkSwapchainKHR swapchain, const VkLatencySleepModeInfoNV *pSleepModeInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::SetLatencySleepModeNV(dispatch, device, swapchain, pSleepModeInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_SetLocalDimmingAMD(VkDevice device, VkSwapchainKHR swapChain, VkBool32 localDimmingEnable) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::SetLocalDimmingAMD(dispatch, device, swapChain, localDimmingEnable);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetPrivateData(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::SetPrivateData(dispatch, device, objectType, objectHandle, privateDataSlot, data);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_SetPrivateDataEXT(VkDevice device, VkObjectType objectType, uint64_t objectHandle, VkPrivateDataSlot privateDataSlot, uint64_t data) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::SetPrivateDataEXT(dispatch, device, objectType, objectHandle, privateDataSlot, data);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_SignalSemaphore(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::SignalSemaphore(dispatch, device, pSignalInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_SignalSemaphoreKHR(VkDevice device, const VkSemaphoreSignalInfo *pSignalInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::SignalSemaphoreKHR(dispatch, device, pSignalInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_TransitionImageLayoutEXT(VkDevice device, uint32_t transitionCount, const VkHostImageLayoutTransitionInfo *pTransitions) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::TransitionImageLayoutEXT(dispatch, device, transitionCount, pTransitions);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_TrimCommandPool(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::TrimCommandPool(dispatch, device, commandPool, flags);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_TrimCommandPoolKHR(VkDevice device, VkCommandPool commandPool, VkCommandPoolTrimFlags flags) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::TrimCommandPoolKHR(dispatch, device, commandPool, flags);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_UninitializePerformanceApiINTEL(VkDevice device) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::UninitializePerformanceApiINTEL(dispatch, device);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_UnmapMemory(VkDevice device, VkDeviceMemory memory) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::UnmapMemory(dispatch, device, memory);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_UnmapMemory2KHR(VkDevice device, const VkMemoryUnmapInfo *pMemoryUnmapInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::UnmapMemory2KHR(dispatch, device, pMemoryUnmapInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_UpdateDescriptorSetWithTemplate(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::UpdateDescriptorSetWithTemplate(dispatch, device, descriptorSet, descriptorUpdateTemplate, pData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_UpdateDescriptorSetWithTemplateKHR(VkDevice device, VkDescriptorSet descriptorSet, VkDescriptorUpdateTemplate descriptorUpdateTemplate, const void *pData) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::UpdateDescriptorSetWithTemplateKHR(dispatch, device, descriptorSet, descriptorUpdateTemplate, pData);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_UpdateDescriptorSets(VkDevice device, uint32_t descriptorWriteCount, const VkWriteDescriptorSet *pDescriptorWrites, uint32_t descriptorCopyCount, const VkCopyDescriptorSet *pDescriptorCopies) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::UpdateDescriptorSets(dispatch, device, descriptorWriteCount, pDescriptorWrites, descriptorCopyCount, pDescriptorCopies);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_UpdateIndirectExecutionSetPipelineEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetPipelineEXT *pExecutionSetWrites) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::UpdateIndirectExecutionSetPipelineEXT(dispatch, device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static void wrap_UpdateIndirectExecutionSetShaderEXT(VkDevice device, VkIndirectExecutionSetEXT indirectExecutionSet, uint32_t executionSetWriteCount, const VkWriteIndirectExecutionSetShaderEXT *pExecutionSetWrites) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    DeviceOverrides::UpdateIndirectExecutionSetShaderEXT(dispatch, device, indirectExecutionSet, executionSetWriteCount, pExecutionSetWrites);
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_UpdateVideoSessionParametersKHR(VkDevice device, VkVideoSessionParametersKHR videoSessionParameters, const VkVideoSessionParametersUpdateInfoKHR *pUpdateInfo) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::UpdateVideoSessionParametersKHR(dispatch, device, videoSessionParameters, pUpdateInfo);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_WaitForFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::WaitForFences(dispatch, device, fenceCount, pFences, waitAll, timeout);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_WaitForPresent2KHR(VkDevice device, VkSwapchainKHR swapchain, const VkPresentWait2InfoKHR *pPresentWait2Info) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::WaitForPresent2KHR(dispatch, device, swapchain, pPresentWait2Info);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_WaitForPresentKHR(VkDevice device, VkSwapchainKHR swapchain, uint64_t presentId, uint64_t timeout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::WaitForPresentKHR(dispatch, device, swapchain, presentId, timeout);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_WaitSemaphores(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::WaitSemaphores(dispatch, device, pWaitInfo, timeout);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_WaitSemaphoresKHR(VkDevice device, const VkSemaphoreWaitInfo *pWaitInfo, uint64_t timeout) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::WaitSemaphoresKHR(dispatch, device, pWaitInfo, timeout);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_WriteAccelerationStructuresPropertiesKHR(VkDevice device, uint32_t accelerationStructureCount, const VkAccelerationStructureKHR *pAccelerationStructures, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::WriteAccelerationStructuresPropertiesKHR(dispatch, device, accelerationStructureCount, pAccelerationStructures, queryType, dataSize, pData, stride);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static VkResult wrap_WriteMicromapsPropertiesEXT(VkDevice device, uint32_t micromapCount, const VkMicromapEXT *pMicromaps, VkQueryType queryType, size_t dataSize, void *pData, size_t stride) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    VkResult ret = DeviceOverrides::WriteMicromapsPropertiesEXT(dispatch, device, micromapCount, pMicromaps, queryType, dataSize, pData, stride);
    return ret;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static PFN_vkVoidFunction GetInstanceProcAddr(VkInstance instance, const char* name) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
#ifdef VK_USE_PLATFORM_ANDROID_KHR
    constexpr bool HasCreateAndroidSurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateAndroidSurfaceKHR; };
    if constexpr (HasCreateAndroidSurfaceKHR) {
      if (!std::strcmp("vkCreateAndroidSurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateAndroidSurfaceKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateDebugReportCallbackEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDebugReportCallbackEXT; };
    if constexpr (HasCreateDebugReportCallbackEXT) {
      if (!std::strcmp("vkCreateDebugReportCallbackEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateDebugReportCallbackEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDebugUtilsMessengerEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDebugUtilsMessengerEXT; };
    if constexpr (HasCreateDebugUtilsMessengerEXT) {
      if (!std::strcmp("vkCreateDebugUtilsMessengerEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateDebugUtilsMessengerEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDevice = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDevice; };
    if constexpr (HasCreateDevice) {
      if (!std::strcmp("vkCreateDevice", name))
        return (PFN_vkVoidFunction) &wrap_CreateDevice<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::is_base_of<NoOverrides, DeviceOverrides>::value && !std::strcmp("vkCreateDevice", name))
        return (PFN_vkVoidFunction) &implicit_wrap_CreateDevice;
    }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    constexpr bool HasCreateDirectFBSurfaceEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDirectFBSurfaceEXT; };
    if constexpr (HasCreateDirectFBSurfaceEXT) {
      if (!std::strcmp("vkCreateDirectFBSurfaceEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateDirectFBSurfaceEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateDisplayModeKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDisplayModeKHR; };
    if constexpr (HasCreateDisplayModeKHR) {
      if (!std::strcmp("vkCreateDisplayModeKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateDisplayModeKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDisplayPlaneSurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateDisplayPlaneSurfaceKHR; };
    if constexpr (HasCreateDisplayPlaneSurfaceKHR) {
      if (!std::strcmp("vkCreateDisplayPlaneSurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateDisplayPlaneSurfaceKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateHeadlessSurfaceEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateHeadlessSurfaceEXT; };
    if constexpr (HasCreateHeadlessSurfaceEXT) {
      if (!std::strcmp("vkCreateHeadlessSurfaceEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateHeadlessSurfaceEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_IOS_MVK
    constexpr bool HasCreateIOSSurfaceMVK = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateIOSSurfaceMVK; };
    if constexpr (HasCreateIOSSurfaceMVK) {
      if (!std::strcmp("vkCreateIOSSurfaceMVK", name))
        return (PFN_vkVoidFunction) &wrap_CreateIOSSurfaceMVK<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasCreateImagePipeSurfaceFUCHSIA = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateImagePipeSurfaceFUCHSIA; };
    if constexpr (HasCreateImagePipeSurfaceFUCHSIA) {
      if (!std::strcmp("vkCreateImagePipeSurfaceFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_CreateImagePipeSurfaceFUCHSIA<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateInstance = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateInstance; };
    if constexpr (HasCreateInstance) {
      if (!std::strcmp("vkCreateInstance", name))
        return (PFN_vkVoidFunction) &wrap_CreateInstance<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::strcmp("vkCreateInstance", name))
        return (PFN_vkVoidFunction) &implicit_wrap_CreateInstance;
    }

#ifdef VK_USE_PLATFORM_MACOS_MVK
    constexpr bool HasCreateMacOSSurfaceMVK = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateMacOSSurfaceMVK; };
    if constexpr (HasCreateMacOSSurfaceMVK) {
      if (!std::strcmp("vkCreateMacOSSurfaceMVK", name))
        return (PFN_vkVoidFunction) &wrap_CreateMacOSSurfaceMVK<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
    constexpr bool HasCreateMetalSurfaceEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateMetalSurfaceEXT; };
    if constexpr (HasCreateMetalSurfaceEXT) {
      if (!std::strcmp("vkCreateMetalSurfaceEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateMetalSurfaceEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_SCREEN_QNX
    constexpr bool HasCreateScreenSurfaceQNX = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateScreenSurfaceQNX; };
    if constexpr (HasCreateScreenSurfaceQNX) {
      if (!std::strcmp("vkCreateScreenSurfaceQNX", name))
        return (PFN_vkVoidFunction) &wrap_CreateScreenSurfaceQNX<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_GGP
    constexpr bool HasCreateStreamDescriptorSurfaceGGP = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateStreamDescriptorSurfaceGGP; };
    if constexpr (HasCreateStreamDescriptorSurfaceGGP) {
      if (!std::strcmp("vkCreateStreamDescriptorSurfaceGGP", name))
        return (PFN_vkVoidFunction) &wrap_CreateStreamDescriptorSurfaceGGP<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_OHOS
    constexpr bool HasCreateSurfaceOHOS = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateSurfaceOHOS; };
    if constexpr (HasCreateSurfaceOHOS) {
      if (!std::strcmp("vkCreateSurfaceOHOS", name))
        return (PFN_vkVoidFunction) &wrap_CreateSurfaceOHOS<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_VI_NN
    constexpr bool HasCreateViSurfaceNN = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateViSurfaceNN; };
    if constexpr (HasCreateViSurfaceNN) {
      if (!std::strcmp("vkCreateViSurfaceNN", name))
        return (PFN_vkVoidFunction) &wrap_CreateViSurfaceNN<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    constexpr bool HasCreateWaylandSurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateWaylandSurfaceKHR; };
    if constexpr (HasCreateWaylandSurfaceKHR) {
      if (!std::strcmp("vkCreateWaylandSurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateWaylandSurfaceKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasCreateWin32SurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateWin32SurfaceKHR; };
    if constexpr (HasCreateWin32SurfaceKHR) {
      if (!std::strcmp("vkCreateWin32SurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateWin32SurfaceKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
    constexpr bool HasCreateXcbSurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateXcbSurfaceKHR; };
    if constexpr (HasCreateXcbSurfaceKHR) {
      if (!std::strcmp("vkCreateXcbSurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateXcbSurfaceKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
    constexpr bool HasCreateXlibSurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::CreateXlibSurfaceKHR; };
    if constexpr (HasCreateXlibSurfaceKHR) {
      if (!std::strcmp("vkCreateXlibSurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateXlibSurfaceKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasDebugReportMessageEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::DebugReportMessageEXT; };
    if constexpr (HasDebugReportMessageEXT) {
      if (!std::strcmp("vkDebugReportMessageEXT", name))
        return (PFN_vkVoidFunction) &wrap_DebugReportMessageEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDebugReportCallbackEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::DestroyDebugReportCallbackEXT; };
    if constexpr (HasDestroyDebugReportCallbackEXT) {
      if (!std::strcmp("vkDestroyDebugReportCallbackEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDebugReportCallbackEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDebugUtilsMessengerEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::DestroyDebugUtilsMessengerEXT; };
    if constexpr (HasDestroyDebugUtilsMessengerEXT) {
      if (!std::strcmp("vkDestroyDebugUtilsMessengerEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDebugUtilsMessengerEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyInstance = requires(const InstanceOverrides& t) { &InstanceOverrides::DestroyInstance; };
    if constexpr (HasDestroyInstance) {
      if (!std::strcmp("vkDestroyInstance", name))
        return (PFN_vkVoidFunction) &wrap_DestroyInstance<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::strcmp("vkDestroyInstance", name))
        return (PFN_vkVoidFunction) &implicit_wrap_DestroyInstance;
    }

    constexpr bool HasDestroySurfaceKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::DestroySurfaceKHR; };
    if constexpr (HasDestroySurfaceKHR) {
      if (!std::strcmp("vkDestroySurfaceKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroySurfaceKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumerateDeviceExtensionProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumerateDeviceExtensionProperties; };
    if constexpr (HasEnumerateDeviceExtensionProperties) {
      if (!std::strcmp("vkEnumerateDeviceExtensionProperties", name))
        return (PFN_vkVoidFunction) &wrap_EnumerateDeviceExtensionProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumerateDeviceLayerProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumerateDeviceLayerProperties; };
    if constexpr (HasEnumerateDeviceLayerProperties) {
      if (!std::strcmp("vkEnumerateDeviceLayerProperties", name))
        return (PFN_vkVoidFunction) &wrap_EnumerateDeviceLayerProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumeratePhysicalDeviceGroups = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumeratePhysicalDeviceGroups; };
    if constexpr (HasEnumeratePhysicalDeviceGroups) {
      if (!std::strcmp("vkEnumeratePhysicalDeviceGroups", name))
        return (PFN_vkVoidFunction) &wrap_EnumeratePhysicalDeviceGroups<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumeratePhysicalDeviceGroupsKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumeratePhysicalDeviceGroupsKHR; };
    if constexpr (HasEnumeratePhysicalDeviceGroupsKHR) {
      if (!std::strcmp("vkEnumeratePhysicalDeviceGroupsKHR", name))
        return (PFN_vkVoidFunction) &wrap_EnumeratePhysicalDeviceGroupsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEnumeratePhysicalDevices = requires(const InstanceOverrides& t) { &InstanceOverrides::EnumeratePhysicalDevices; };
    if constexpr (HasEnumeratePhysicalDevices) {
      if (!std::strcmp("vkEnumeratePhysicalDevices", name))
        return (PFN_vkVoidFunction) &wrap_EnumeratePhysicalDevices<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayModePropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayModePropertiesKHR; };
    if constexpr (HasGetDisplayModePropertiesKHR) {
      if (!std::strcmp("vkGetDisplayModePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayModePropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayPlaneCapabilitiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayPlaneCapabilitiesKHR; };
    if constexpr (HasGetDisplayPlaneCapabilitiesKHR) {
      if (!std::strcmp("vkGetDisplayPlaneCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayPlaneCapabilitiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayPlaneSupportedDisplaysKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetDisplayPlaneSupportedDisplaysKHR; };
    if constexpr (HasGetDisplayPlaneSupportedDisplaysKHR) {
      if (!std::strcmp("vkGetDisplayPlaneSupportedDisplaysKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayPlaneSupportedDisplaysKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    if (!std::strcmp("vkGetInstanceProcAddr", name))
      return (PFN_vkVoidFunction) &GetInstanceProcAddr<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;

    constexpr bool HasGetPhysicalDeviceDisplayPlanePropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDisplayPlanePropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceDisplayPlanePropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayPlanePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayPlanePropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceDisplayPropertiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceDisplayPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceDisplayPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayPropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalBufferProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalBufferProperties; };
    if constexpr (HasGetPhysicalDeviceExternalBufferProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalBufferProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalBufferProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalFenceProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalFenceProperties; };
    if constexpr (HasGetPhysicalDeviceExternalFenceProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalFenceProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalFenceProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalSemaphoreProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceExternalSemaphoreProperties; };
    if constexpr (HasGetPhysicalDeviceExternalSemaphoreProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalSemaphoreProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalSemaphoreProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFeatures = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFeatures; };
    if constexpr (HasGetPhysicalDeviceFeatures) {
      if (!std::strcmp("vkGetPhysicalDeviceFeatures", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFeatures<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFeatures2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFeatures2; };
    if constexpr (HasGetPhysicalDeviceFeatures2) {
      if (!std::strcmp("vkGetPhysicalDeviceFeatures2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFeatures2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFormatProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFormatProperties; };
    if constexpr (HasGetPhysicalDeviceFormatProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceFormatProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFormatProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFormatProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceFormatProperties2; };
    if constexpr (HasGetPhysicalDeviceFormatProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceFormatProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFormatProperties2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceImageFormatProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceImageFormatProperties; };
    if constexpr (HasGetPhysicalDeviceImageFormatProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceImageFormatProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceImageFormatProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceImageFormatProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceImageFormatProperties2; };
    if constexpr (HasGetPhysicalDeviceImageFormatProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceImageFormatProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceImageFormatProperties2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMemoryProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceMemoryProperties; };
    if constexpr (HasGetPhysicalDeviceMemoryProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceMemoryProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMemoryProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMemoryProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceMemoryProperties2; };
    if constexpr (HasGetPhysicalDeviceMemoryProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceMemoryProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMemoryProperties2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDevicePresentRectanglesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDevicePresentRectanglesKHR; };
    if constexpr (HasGetPhysicalDevicePresentRectanglesKHR) {
      if (!std::strcmp("vkGetPhysicalDevicePresentRectanglesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDevicePresentRectanglesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceProperties; };
    if constexpr (HasGetPhysicalDeviceProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceProperties2; };
    if constexpr (HasGetPhysicalDeviceProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceProperties2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceQueueFamilyProperties2; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyProperties2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSparseImageFormatProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties; };
    if constexpr (HasGetPhysicalDeviceSparseImageFormatProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceSparseImageFormatProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSparseImageFormatProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSparseImageFormatProperties2 = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSparseImageFormatProperties2; };
    if constexpr (HasGetPhysicalDeviceSparseImageFormatProperties2) {
      if (!std::strcmp("vkGetPhysicalDeviceSparseImageFormatProperties2", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSparseImageFormatProperties2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceCapabilities2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceCapabilities2KHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceCapabilities2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceCapabilities2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceCapabilities2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceCapabilitiesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceCapabilitiesKHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceCapabilitiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceCapabilitiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceFormats2KHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceFormats2KHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceFormats2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceFormats2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceFormats2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceFormatsKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceFormatsKHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceFormatsKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceFormatsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceFormatsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfacePresentModesKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfacePresentModesKHR; };
    if constexpr (HasGetPhysicalDeviceSurfacePresentModesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfacePresentModesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfacePresentModesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceSurfaceSupportKHR; };
    if constexpr (HasGetPhysicalDeviceSurfaceSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceSupportKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceToolProperties = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceToolProperties; };
    if constexpr (HasGetPhysicalDeviceToolProperties) {
      if (!std::strcmp("vkGetPhysicalDeviceToolProperties", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceToolProperties<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
    constexpr bool HasGetPhysicalDeviceWaylandPresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceWaylandPresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceWaylandPresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceWaylandPresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceWaylandPresentationSupportKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetPhysicalDeviceWin32PresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceWin32PresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceWin32PresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceWin32PresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceWin32PresentationSupportKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XCB_KHR
    constexpr bool HasGetPhysicalDeviceXcbPresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceXcbPresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceXcbPresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceXcbPresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceXcbPresentationSupportKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
    constexpr bool HasGetPhysicalDeviceXlibPresentationSupportKHR = requires(const InstanceOverrides& t) { &InstanceOverrides::GetPhysicalDeviceXlibPresentationSupportKHR; };
    if constexpr (HasGetPhysicalDeviceXlibPresentationSupportKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceXlibPresentationSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceXlibPresentationSupportKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasSubmitDebugUtilsMessageEXT = requires(const InstanceOverrides& t) { &InstanceOverrides::SubmitDebugUtilsMessageEXT; };
    if constexpr (HasSubmitDebugUtilsMessageEXT) {
      if (!std::strcmp("vkSubmitDebugUtilsMessageEXT", name))
        return (PFN_vkVoidFunction) &wrap_SubmitDebugUtilsMessageEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    if (dispatch)
      return dispatch->GetInstanceProcAddr(instance, name);
    else
      return NULL;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static PFN_vkVoidFunction GetPhysicalDeviceProcAddr(VkInstance instance, const char* name) {
    const VkPhysicalDeviceDispatch* dispatch = tables::LookupPhysicalDeviceDispatch(instance);
    constexpr bool HasAcquireDrmDisplayEXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::AcquireDrmDisplayEXT; };
    if constexpr (HasAcquireDrmDisplayEXT) {
      if (!std::strcmp("vkAcquireDrmDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_AcquireDrmDisplayEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasAcquireWinrtDisplayNV = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::AcquireWinrtDisplayNV; };
    if constexpr (HasAcquireWinrtDisplayNV) {
      if (!std::strcmp("vkAcquireWinrtDisplayNV", name))
        return (PFN_vkVoidFunction) &wrap_AcquireWinrtDisplayNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    constexpr bool HasAcquireXlibDisplayEXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::AcquireXlibDisplayEXT; };
    if constexpr (HasAcquireXlibDisplayEXT) {
      if (!std::strcmp("vkAcquireXlibDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_AcquireXlibDisplayEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR; };
    if constexpr (HasEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR) {
      if (!std::strcmp("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", name))
        return (PFN_vkVoidFunction) &wrap_EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayModeProperties2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetDisplayModeProperties2KHR; };
    if constexpr (HasGetDisplayModeProperties2KHR) {
      if (!std::strcmp("vkGetDisplayModeProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayModeProperties2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDisplayPlaneCapabilities2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetDisplayPlaneCapabilities2KHR; };
    if constexpr (HasGetDisplayPlaneCapabilities2KHR) {
      if (!std::strcmp("vkGetDisplayPlaneCapabilities2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDisplayPlaneCapabilities2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDrmDisplayEXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetDrmDisplayEXT; };
    if constexpr (HasGetDrmDisplayEXT) {
      if (!std::strcmp("vkGetDrmDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDrmDisplayEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCalibrateableTimeDomainsEXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceCalibrateableTimeDomainsEXT; };
    if constexpr (HasGetPhysicalDeviceCalibrateableTimeDomainsEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCalibrateableTimeDomainsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCalibrateableTimeDomainsKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceCalibrateableTimeDomainsKHR; };
    if constexpr (HasGetPhysicalDeviceCalibrateableTimeDomainsKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCalibrateableTimeDomainsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeMatrixFlexibleDimensionsPropertiesNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeMatrixPropertiesKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceCooperativeMatrixPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceCooperativeMatrixPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeMatrixPropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeMatrixPropertiesNV = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceCooperativeMatrixPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceCooperativeMatrixPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeMatrixPropertiesNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceCooperativeVectorPropertiesNV = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceCooperativeVectorPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceCooperativeVectorPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceCooperativeVectorPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceCooperativeVectorPropertiesNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
    constexpr bool HasGetPhysicalDeviceDirectFBPresentationSupportEXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceDirectFBPresentationSupportEXT; };
    if constexpr (HasGetPhysicalDeviceDirectFBPresentationSupportEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceDirectFBPresentationSupportEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDirectFBPresentationSupportEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetPhysicalDeviceDisplayPlaneProperties2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceDisplayPlaneProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceDisplayPlaneProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayPlaneProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayPlaneProperties2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceDisplayProperties2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceDisplayProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceDisplayProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceDisplayProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceDisplayProperties2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalBufferPropertiesKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceExternalBufferPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceExternalBufferPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalBufferPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalBufferPropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalFencePropertiesKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceExternalFencePropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceExternalFencePropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalFencePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalFencePropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalImageFormatPropertiesNV = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceExternalImageFormatPropertiesNV; };
    if constexpr (HasGetPhysicalDeviceExternalImageFormatPropertiesNV) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalImageFormatPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalImageFormatPropertiesNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalSemaphorePropertiesKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceExternalSemaphorePropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceExternalSemaphorePropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalSemaphorePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalSemaphorePropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceExternalTensorPropertiesARM = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceExternalTensorPropertiesARM; };
    if constexpr (HasGetPhysicalDeviceExternalTensorPropertiesARM) {
      if (!std::strcmp("vkGetPhysicalDeviceExternalTensorPropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceExternalTensorPropertiesARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFeatures2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceFeatures2KHR; };
    if constexpr (HasGetPhysicalDeviceFeatures2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceFeatures2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFeatures2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFormatProperties2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceFormatProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceFormatProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceFormatProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFormatProperties2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceFragmentShadingRatesKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceFragmentShadingRatesKHR; };
    if constexpr (HasGetPhysicalDeviceFragmentShadingRatesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceFragmentShadingRatesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceFragmentShadingRatesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceImageFormatProperties2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceImageFormatProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceImageFormatProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceImageFormatProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceImageFormatProperties2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMemoryProperties2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceMemoryProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceMemoryProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceMemoryProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMemoryProperties2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceMultisamplePropertiesEXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceMultisamplePropertiesEXT; };
    if constexpr (HasGetPhysicalDeviceMultisamplePropertiesEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceMultisamplePropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceMultisamplePropertiesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceOpticalFlowImageFormatsNV = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceOpticalFlowImageFormatsNV; };
    if constexpr (HasGetPhysicalDeviceOpticalFlowImageFormatsNV) {
      if (!std::strcmp("vkGetPhysicalDeviceOpticalFlowImageFormatsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceOpticalFlowImageFormatsNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceProperties2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceProperties2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyDataGraphProcessingEnginePropertiesARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyDataGraphPropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyDataGraphPropertiesARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceQueueFamilyProperties2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceQueueFamilyProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceQueueFamilyProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceQueueFamilyProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceQueueFamilyProperties2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
    constexpr bool HasGetPhysicalDeviceScreenPresentationSupportQNX = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceScreenPresentationSupportQNX; };
    if constexpr (HasGetPhysicalDeviceScreenPresentationSupportQNX) {
      if (!std::strcmp("vkGetPhysicalDeviceScreenPresentationSupportQNX", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceScreenPresentationSupportQNX<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetPhysicalDeviceSparseImageFormatProperties2KHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceSparseImageFormatProperties2KHR; };
    if constexpr (HasGetPhysicalDeviceSparseImageFormatProperties2KHR) {
      if (!std::strcmp("vkGetPhysicalDeviceSparseImageFormatProperties2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSparseImageFormatProperties2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV; };
    if constexpr (HasGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV) {
      if (!std::strcmp("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceSurfaceCapabilities2EXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceSurfaceCapabilities2EXT; };
    if constexpr (HasGetPhysicalDeviceSurfaceCapabilities2EXT) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfaceCapabilities2EXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfaceCapabilities2EXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetPhysicalDeviceSurfacePresentModes2EXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceSurfacePresentModes2EXT; };
    if constexpr (HasGetPhysicalDeviceSurfacePresentModes2EXT) {
      if (!std::strcmp("vkGetPhysicalDeviceSurfacePresentModes2EXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceSurfacePresentModes2EXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetPhysicalDeviceToolPropertiesEXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceToolPropertiesEXT; };
    if constexpr (HasGetPhysicalDeviceToolPropertiesEXT) {
      if (!std::strcmp("vkGetPhysicalDeviceToolPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceToolPropertiesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceVideoCapabilitiesKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceVideoCapabilitiesKHR; };
    if constexpr (HasGetPhysicalDeviceVideoCapabilitiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceVideoCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceVideoCapabilitiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPhysicalDeviceVideoFormatPropertiesKHR = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetPhysicalDeviceVideoFormatPropertiesKHR; };
    if constexpr (HasGetPhysicalDeviceVideoFormatPropertiesKHR) {
      if (!std::strcmp("vkGetPhysicalDeviceVideoFormatPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPhysicalDeviceVideoFormatPropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_XLIB_XRANDR_EXT
    constexpr bool HasGetRandROutputDisplayEXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetRandROutputDisplayEXT; };
    if constexpr (HasGetRandROutputDisplayEXT) {
      if (!std::strcmp("vkGetRandROutputDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetRandROutputDisplayEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetWinrtDisplayNV = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::GetWinrtDisplayNV; };
    if constexpr (HasGetWinrtDisplayNV) {
      if (!std::strcmp("vkGetWinrtDisplayNV", name))
        return (PFN_vkVoidFunction) &wrap_GetWinrtDisplayNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasReleaseDisplayEXT = requires(const PhysicalDeviceOverrides& t) { &PhysicalDeviceOverrides::ReleaseDisplayEXT; };
    if constexpr (HasReleaseDisplayEXT) {
      if (!std::strcmp("vkReleaseDisplayEXT", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseDisplayEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    if constexpr (!std::is_base_of<NoOverrides, PhysicalDeviceOverrides>::value || !std::is_base_of<NoOverrides, DeviceOverrides>::value) {
      if (!std::strcmp("vk_layerGetPhysicalDeviceProcAddr", name))
        return (PFN_vkVoidFunction) &GetPhysicalDeviceProcAddr<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    if (dispatch)
      return dispatch->GetPhysicalDeviceProcAddr(instance, name);
    else
      return NULL;
  }

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  static PFN_vkVoidFunction GetDeviceProcAddr(VkDevice device, const char* name) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasAcquireFullScreenExclusiveModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::AcquireFullScreenExclusiveModeEXT; };
    if constexpr (HasAcquireFullScreenExclusiveModeEXT) {
      if (!std::strcmp("vkAcquireFullScreenExclusiveModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_AcquireFullScreenExclusiveModeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasAcquireNextImage2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::AcquireNextImage2KHR; };
    if constexpr (HasAcquireNextImage2KHR) {
      if (!std::strcmp("vkAcquireNextImage2KHR", name))
        return (PFN_vkVoidFunction) &wrap_AcquireNextImage2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAcquireNextImageKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::AcquireNextImageKHR; };
    if constexpr (HasAcquireNextImageKHR) {
      if (!std::strcmp("vkAcquireNextImageKHR", name))
        return (PFN_vkVoidFunction) &wrap_AcquireNextImageKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAcquirePerformanceConfigurationINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::AcquirePerformanceConfigurationINTEL; };
    if constexpr (HasAcquirePerformanceConfigurationINTEL) {
      if (!std::strcmp("vkAcquirePerformanceConfigurationINTEL", name))
        return (PFN_vkVoidFunction) &wrap_AcquirePerformanceConfigurationINTEL<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAcquireProfilingLockKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::AcquireProfilingLockKHR; };
    if constexpr (HasAcquireProfilingLockKHR) {
      if (!std::strcmp("vkAcquireProfilingLockKHR", name))
        return (PFN_vkVoidFunction) &wrap_AcquireProfilingLockKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAllocateCommandBuffers = requires(const DeviceOverrides& t) { &DeviceOverrides::AllocateCommandBuffers; };
    if constexpr (HasAllocateCommandBuffers) {
      if (!std::strcmp("vkAllocateCommandBuffers", name))
        return (PFN_vkVoidFunction) &wrap_AllocateCommandBuffers<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::is_base_of<NoOverrides, DeviceOverrides>::value && !std::strcmp("vkAllocateCommandBuffers", name))
        return (PFN_vkVoidFunction) &implicit_wrap_AllocateCommandBuffers;
    }

    constexpr bool HasAllocateDescriptorSets = requires(const DeviceOverrides& t) { &DeviceOverrides::AllocateDescriptorSets; };
    if constexpr (HasAllocateDescriptorSets) {
      if (!std::strcmp("vkAllocateDescriptorSets", name))
        return (PFN_vkVoidFunction) &wrap_AllocateDescriptorSets<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAllocateMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::AllocateMemory; };
    if constexpr (HasAllocateMemory) {
      if (!std::strcmp("vkAllocateMemory", name))
        return (PFN_vkVoidFunction) &wrap_AllocateMemory<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasAntiLagUpdateAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::AntiLagUpdateAMD; };
    if constexpr (HasAntiLagUpdateAMD) {
      if (!std::strcmp("vkAntiLagUpdateAMD", name))
        return (PFN_vkVoidFunction) &wrap_AntiLagUpdateAMD<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBeginCommandBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::BeginCommandBuffer; };
    if constexpr (HasBeginCommandBuffer) {
      if (!std::strcmp("vkBeginCommandBuffer", name))
        return (PFN_vkVoidFunction) &wrap_BeginCommandBuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindAccelerationStructureMemoryNV = requires(const DeviceOverrides& t) { &DeviceOverrides::BindAccelerationStructureMemoryNV; };
    if constexpr (HasBindAccelerationStructureMemoryNV) {
      if (!std::strcmp("vkBindAccelerationStructureMemoryNV", name))
        return (PFN_vkVoidFunction) &wrap_BindAccelerationStructureMemoryNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindBufferMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::BindBufferMemory; };
    if constexpr (HasBindBufferMemory) {
      if (!std::strcmp("vkBindBufferMemory", name))
        return (PFN_vkVoidFunction) &wrap_BindBufferMemory<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindBufferMemory2 = requires(const DeviceOverrides& t) { &DeviceOverrides::BindBufferMemory2; };
    if constexpr (HasBindBufferMemory2) {
      if (!std::strcmp("vkBindBufferMemory2", name))
        return (PFN_vkVoidFunction) &wrap_BindBufferMemory2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindBufferMemory2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::BindBufferMemory2KHR; };
    if constexpr (HasBindBufferMemory2KHR) {
      if (!std::strcmp("vkBindBufferMemory2KHR", name))
        return (PFN_vkVoidFunction) &wrap_BindBufferMemory2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindDataGraphPipelineSessionMemoryARM = requires(const DeviceOverrides& t) { &DeviceOverrides::BindDataGraphPipelineSessionMemoryARM; };
    if constexpr (HasBindDataGraphPipelineSessionMemoryARM) {
      if (!std::strcmp("vkBindDataGraphPipelineSessionMemoryARM", name))
        return (PFN_vkVoidFunction) &wrap_BindDataGraphPipelineSessionMemoryARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindImageMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::BindImageMemory; };
    if constexpr (HasBindImageMemory) {
      if (!std::strcmp("vkBindImageMemory", name))
        return (PFN_vkVoidFunction) &wrap_BindImageMemory<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindImageMemory2 = requires(const DeviceOverrides& t) { &DeviceOverrides::BindImageMemory2; };
    if constexpr (HasBindImageMemory2) {
      if (!std::strcmp("vkBindImageMemory2", name))
        return (PFN_vkVoidFunction) &wrap_BindImageMemory2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindImageMemory2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::BindImageMemory2KHR; };
    if constexpr (HasBindImageMemory2KHR) {
      if (!std::strcmp("vkBindImageMemory2KHR", name))
        return (PFN_vkVoidFunction) &wrap_BindImageMemory2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindOpticalFlowSessionImageNV = requires(const DeviceOverrides& t) { &DeviceOverrides::BindOpticalFlowSessionImageNV; };
    if constexpr (HasBindOpticalFlowSessionImageNV) {
      if (!std::strcmp("vkBindOpticalFlowSessionImageNV", name))
        return (PFN_vkVoidFunction) &wrap_BindOpticalFlowSessionImageNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindTensorMemoryARM = requires(const DeviceOverrides& t) { &DeviceOverrides::BindTensorMemoryARM; };
    if constexpr (HasBindTensorMemoryARM) {
      if (!std::strcmp("vkBindTensorMemoryARM", name))
        return (PFN_vkVoidFunction) &wrap_BindTensorMemoryARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBindVideoSessionMemoryKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::BindVideoSessionMemoryKHR; };
    if constexpr (HasBindVideoSessionMemoryKHR) {
      if (!std::strcmp("vkBindVideoSessionMemoryKHR", name))
        return (PFN_vkVoidFunction) &wrap_BindVideoSessionMemoryKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBuildAccelerationStructuresKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::BuildAccelerationStructuresKHR; };
    if constexpr (HasBuildAccelerationStructuresKHR) {
      if (!std::strcmp("vkBuildAccelerationStructuresKHR", name))
        return (PFN_vkVoidFunction) &wrap_BuildAccelerationStructuresKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasBuildMicromapsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::BuildMicromapsEXT; };
    if constexpr (HasBuildMicromapsEXT) {
      if (!std::strcmp("vkBuildMicromapsEXT", name))
        return (PFN_vkVoidFunction) &wrap_BuildMicromapsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginConditionalRenderingEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginConditionalRenderingEXT; };
    if constexpr (HasCmdBeginConditionalRenderingEXT) {
      if (!std::strcmp("vkCmdBeginConditionalRenderingEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginConditionalRenderingEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginDebugUtilsLabelEXT; };
    if constexpr (HasCmdBeginDebugUtilsLabelEXT) {
      if (!std::strcmp("vkCmdBeginDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginDebugUtilsLabelEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginPerTileExecutionQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginPerTileExecutionQCOM; };
    if constexpr (HasCmdBeginPerTileExecutionQCOM) {
      if (!std::strcmp("vkCmdBeginPerTileExecutionQCOM", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginPerTileExecutionQCOM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginQuery = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginQuery; };
    if constexpr (HasCmdBeginQuery) {
      if (!std::strcmp("vkCmdBeginQuery", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginQuery<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginQueryIndexedEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginQueryIndexedEXT; };
    if constexpr (HasCmdBeginQueryIndexedEXT) {
      if (!std::strcmp("vkCmdBeginQueryIndexedEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginQueryIndexedEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginRenderPass = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass; };
    if constexpr (HasCmdBeginRenderPass) {
      if (!std::strcmp("vkCmdBeginRenderPass", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginRenderPass<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginRenderPass2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass2; };
    if constexpr (HasCmdBeginRenderPass2) {
      if (!std::strcmp("vkCmdBeginRenderPass2", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginRenderPass2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginRenderPass2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderPass2KHR; };
    if constexpr (HasCmdBeginRenderPass2KHR) {
      if (!std::strcmp("vkCmdBeginRenderPass2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginRenderPass2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginRendering = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRendering; };
    if constexpr (HasCmdBeginRendering) {
      if (!std::strcmp("vkCmdBeginRendering", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginRendering<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginRenderingKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginRenderingKHR; };
    if constexpr (HasCmdBeginRenderingKHR) {
      if (!std::strcmp("vkCmdBeginRenderingKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginRenderingKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginTransformFeedbackEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginTransformFeedbackEXT; };
    if constexpr (HasCmdBeginTransformFeedbackEXT) {
      if (!std::strcmp("vkCmdBeginTransformFeedbackEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginTransformFeedbackEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBeginVideoCodingKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBeginVideoCodingKHR; };
    if constexpr (HasCmdBeginVideoCodingKHR) {
      if (!std::strcmp("vkCmdBeginVideoCodingKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBeginVideoCodingKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindDescriptorBufferEmbeddedSamplers2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplers2EXT; };
    if constexpr (HasCmdBindDescriptorBufferEmbeddedSamplers2EXT) {
      if (!std::strcmp("vkCmdBindDescriptorBufferEmbeddedSamplers2EXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindDescriptorBufferEmbeddedSamplers2EXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindDescriptorBufferEmbeddedSamplersEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBufferEmbeddedSamplersEXT; };
    if constexpr (HasCmdBindDescriptorBufferEmbeddedSamplersEXT) {
      if (!std::strcmp("vkCmdBindDescriptorBufferEmbeddedSamplersEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindDescriptorBufferEmbeddedSamplersEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindDescriptorBuffersEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorBuffersEXT; };
    if constexpr (HasCmdBindDescriptorBuffersEXT) {
      if (!std::strcmp("vkCmdBindDescriptorBuffersEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindDescriptorBuffersEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindDescriptorSets = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorSets; };
    if constexpr (HasCmdBindDescriptorSets) {
      if (!std::strcmp("vkCmdBindDescriptorSets", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindDescriptorSets<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindDescriptorSets2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindDescriptorSets2KHR; };
    if constexpr (HasCmdBindDescriptorSets2KHR) {
      if (!std::strcmp("vkCmdBindDescriptorSets2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindDescriptorSets2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindIndexBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindIndexBuffer; };
    if constexpr (HasCmdBindIndexBuffer) {
      if (!std::strcmp("vkCmdBindIndexBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindIndexBuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindIndexBuffer2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindIndexBuffer2KHR; };
    if constexpr (HasCmdBindIndexBuffer2KHR) {
      if (!std::strcmp("vkCmdBindIndexBuffer2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindIndexBuffer2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindInvocationMaskHUAWEI = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindInvocationMaskHUAWEI; };
    if constexpr (HasCmdBindInvocationMaskHUAWEI) {
      if (!std::strcmp("vkCmdBindInvocationMaskHUAWEI", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindInvocationMaskHUAWEI<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindPipeline = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindPipeline; };
    if constexpr (HasCmdBindPipeline) {
      if (!std::strcmp("vkCmdBindPipeline", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindPipeline<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindPipelineShaderGroupNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindPipelineShaderGroupNV; };
    if constexpr (HasCmdBindPipelineShaderGroupNV) {
      if (!std::strcmp("vkCmdBindPipelineShaderGroupNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindPipelineShaderGroupNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindShadersEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindShadersEXT; };
    if constexpr (HasCmdBindShadersEXT) {
      if (!std::strcmp("vkCmdBindShadersEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindShadersEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindShadingRateImageNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindShadingRateImageNV; };
    if constexpr (HasCmdBindShadingRateImageNV) {
      if (!std::strcmp("vkCmdBindShadingRateImageNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindShadingRateImageNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindTileMemoryQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindTileMemoryQCOM; };
    if constexpr (HasCmdBindTileMemoryQCOM) {
      if (!std::strcmp("vkCmdBindTileMemoryQCOM", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindTileMemoryQCOM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindTransformFeedbackBuffersEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindTransformFeedbackBuffersEXT; };
    if constexpr (HasCmdBindTransformFeedbackBuffersEXT) {
      if (!std::strcmp("vkCmdBindTransformFeedbackBuffersEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindTransformFeedbackBuffersEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindVertexBuffers = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers; };
    if constexpr (HasCmdBindVertexBuffers) {
      if (!std::strcmp("vkCmdBindVertexBuffers", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindVertexBuffers<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindVertexBuffers2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers2; };
    if constexpr (HasCmdBindVertexBuffers2) {
      if (!std::strcmp("vkCmdBindVertexBuffers2", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindVertexBuffers2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBindVertexBuffers2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBindVertexBuffers2EXT; };
    if constexpr (HasCmdBindVertexBuffers2EXT) {
      if (!std::strcmp("vkCmdBindVertexBuffers2EXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBindVertexBuffers2EXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBlitImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage; };
    if constexpr (HasCmdBlitImage) {
      if (!std::strcmp("vkCmdBlitImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdBlitImage<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBlitImage2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage2; };
    if constexpr (HasCmdBlitImage2) {
      if (!std::strcmp("vkCmdBlitImage2", name))
        return (PFN_vkVoidFunction) &wrap_CmdBlitImage2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBlitImage2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBlitImage2KHR; };
    if constexpr (HasCmdBlitImage2KHR) {
      if (!std::strcmp("vkCmdBlitImage2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBlitImage2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildAccelerationStructureNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructureNV; };
    if constexpr (HasCmdBuildAccelerationStructureNV) {
      if (!std::strcmp("vkCmdBuildAccelerationStructureNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildAccelerationStructureNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildAccelerationStructuresIndirectKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructuresIndirectKHR; };
    if constexpr (HasCmdBuildAccelerationStructuresIndirectKHR) {
      if (!std::strcmp("vkCmdBuildAccelerationStructuresIndirectKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildAccelerationStructuresIndirectKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildAccelerationStructuresKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildAccelerationStructuresKHR; };
    if constexpr (HasCmdBuildAccelerationStructuresKHR) {
      if (!std::strcmp("vkCmdBuildAccelerationStructuresKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildAccelerationStructuresKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildClusterAccelerationStructureIndirectNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildClusterAccelerationStructureIndirectNV; };
    if constexpr (HasCmdBuildClusterAccelerationStructureIndirectNV) {
      if (!std::strcmp("vkCmdBuildClusterAccelerationStructureIndirectNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildClusterAccelerationStructureIndirectNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildMicromapsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildMicromapsEXT; };
    if constexpr (HasCmdBuildMicromapsEXT) {
      if (!std::strcmp("vkCmdBuildMicromapsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildMicromapsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdBuildPartitionedAccelerationStructuresNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdBuildPartitionedAccelerationStructuresNV; };
    if constexpr (HasCmdBuildPartitionedAccelerationStructuresNV) {
      if (!std::strcmp("vkCmdBuildPartitionedAccelerationStructuresNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdBuildPartitionedAccelerationStructuresNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdClearAttachments = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearAttachments; };
    if constexpr (HasCmdClearAttachments) {
      if (!std::strcmp("vkCmdClearAttachments", name))
        return (PFN_vkVoidFunction) &wrap_CmdClearAttachments<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdClearColorImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearColorImage; };
    if constexpr (HasCmdClearColorImage) {
      if (!std::strcmp("vkCmdClearColorImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdClearColorImage<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdClearDepthStencilImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdClearDepthStencilImage; };
    if constexpr (HasCmdClearDepthStencilImage) {
      if (!std::strcmp("vkCmdClearDepthStencilImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdClearDepthStencilImage<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdControlVideoCodingKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdControlVideoCodingKHR; };
    if constexpr (HasCmdControlVideoCodingKHR) {
      if (!std::strcmp("vkCmdControlVideoCodingKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdControlVideoCodingKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdConvertCooperativeVectorMatrixNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdConvertCooperativeVectorMatrixNV; };
    if constexpr (HasCmdConvertCooperativeVectorMatrixNV) {
      if (!std::strcmp("vkCmdConvertCooperativeVectorMatrixNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdConvertCooperativeVectorMatrixNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureKHR; };
    if constexpr (HasCmdCopyAccelerationStructureKHR) {
      if (!std::strcmp("vkCmdCopyAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyAccelerationStructureKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyAccelerationStructureNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureNV; };
    if constexpr (HasCmdCopyAccelerationStructureNV) {
      if (!std::strcmp("vkCmdCopyAccelerationStructureNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyAccelerationStructureNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyAccelerationStructureToMemoryKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyAccelerationStructureToMemoryKHR; };
    if constexpr (HasCmdCopyAccelerationStructureToMemoryKHR) {
      if (!std::strcmp("vkCmdCopyAccelerationStructureToMemoryKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyAccelerationStructureToMemoryKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer; };
    if constexpr (HasCmdCopyBuffer) {
      if (!std::strcmp("vkCmdCopyBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBuffer2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer2; };
    if constexpr (HasCmdCopyBuffer2) {
      if (!std::strcmp("vkCmdCopyBuffer2", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBuffer2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBuffer2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBuffer2KHR; };
    if constexpr (HasCmdCopyBuffer2KHR) {
      if (!std::strcmp("vkCmdCopyBuffer2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBuffer2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBufferToImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage; };
    if constexpr (HasCmdCopyBufferToImage) {
      if (!std::strcmp("vkCmdCopyBufferToImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBufferToImage<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBufferToImage2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage2; };
    if constexpr (HasCmdCopyBufferToImage2) {
      if (!std::strcmp("vkCmdCopyBufferToImage2", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBufferToImage2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyBufferToImage2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyBufferToImage2KHR; };
    if constexpr (HasCmdCopyBufferToImage2KHR) {
      if (!std::strcmp("vkCmdCopyBufferToImage2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyBufferToImage2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage; };
    if constexpr (HasCmdCopyImage) {
      if (!std::strcmp("vkCmdCopyImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImage<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImage2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage2; };
    if constexpr (HasCmdCopyImage2) {
      if (!std::strcmp("vkCmdCopyImage2", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImage2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImage2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImage2KHR; };
    if constexpr (HasCmdCopyImage2KHR) {
      if (!std::strcmp("vkCmdCopyImage2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImage2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImageToBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer; };
    if constexpr (HasCmdCopyImageToBuffer) {
      if (!std::strcmp("vkCmdCopyImageToBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImageToBuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImageToBuffer2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer2; };
    if constexpr (HasCmdCopyImageToBuffer2) {
      if (!std::strcmp("vkCmdCopyImageToBuffer2", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImageToBuffer2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyImageToBuffer2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyImageToBuffer2KHR; };
    if constexpr (HasCmdCopyImageToBuffer2KHR) {
      if (!std::strcmp("vkCmdCopyImageToBuffer2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyImageToBuffer2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMemoryIndirectNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryIndirectNV; };
    if constexpr (HasCmdCopyMemoryIndirectNV) {
      if (!std::strcmp("vkCmdCopyMemoryIndirectNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMemoryIndirectNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMemoryToAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToAccelerationStructureKHR; };
    if constexpr (HasCmdCopyMemoryToAccelerationStructureKHR) {
      if (!std::strcmp("vkCmdCopyMemoryToAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMemoryToAccelerationStructureKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMemoryToImageIndirectNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToImageIndirectNV; };
    if constexpr (HasCmdCopyMemoryToImageIndirectNV) {
      if (!std::strcmp("vkCmdCopyMemoryToImageIndirectNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMemoryToImageIndirectNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMemoryToMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMemoryToMicromapEXT; };
    if constexpr (HasCmdCopyMemoryToMicromapEXT) {
      if (!std::strcmp("vkCmdCopyMemoryToMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMemoryToMicromapEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMicromapEXT; };
    if constexpr (HasCmdCopyMicromapEXT) {
      if (!std::strcmp("vkCmdCopyMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMicromapEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyMicromapToMemoryEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyMicromapToMemoryEXT; };
    if constexpr (HasCmdCopyMicromapToMemoryEXT) {
      if (!std::strcmp("vkCmdCopyMicromapToMemoryEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyMicromapToMemoryEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyQueryPoolResults = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyQueryPoolResults; };
    if constexpr (HasCmdCopyQueryPoolResults) {
      if (!std::strcmp("vkCmdCopyQueryPoolResults", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyQueryPoolResults<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdCopyTensorARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCopyTensorARM; };
    if constexpr (HasCmdCopyTensorARM) {
      if (!std::strcmp("vkCmdCopyTensorARM", name))
        return (PFN_vkVoidFunction) &wrap_CmdCopyTensorARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCmdCudaLaunchKernelNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdCudaLaunchKernelNV; };
    if constexpr (HasCmdCudaLaunchKernelNV) {
      if (!std::strcmp("vkCmdCudaLaunchKernelNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdCudaLaunchKernelNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCmdDebugMarkerBeginEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerBeginEXT; };
    if constexpr (HasCmdDebugMarkerBeginEXT) {
      if (!std::strcmp("vkCmdDebugMarkerBeginEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDebugMarkerBeginEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDebugMarkerEndEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerEndEXT; };
    if constexpr (HasCmdDebugMarkerEndEXT) {
      if (!std::strcmp("vkCmdDebugMarkerEndEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDebugMarkerEndEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDebugMarkerInsertEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDebugMarkerInsertEXT; };
    if constexpr (HasCmdDebugMarkerInsertEXT) {
      if (!std::strcmp("vkCmdDebugMarkerInsertEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDebugMarkerInsertEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDecodeVideoKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecodeVideoKHR; };
    if constexpr (HasCmdDecodeVideoKHR) {
      if (!std::strcmp("vkCmdDecodeVideoKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdDecodeVideoKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDecompressMemoryIndirectCountNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecompressMemoryIndirectCountNV; };
    if constexpr (HasCmdDecompressMemoryIndirectCountNV) {
      if (!std::strcmp("vkCmdDecompressMemoryIndirectCountNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdDecompressMemoryIndirectCountNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDecompressMemoryNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDecompressMemoryNV; };
    if constexpr (HasCmdDecompressMemoryNV) {
      if (!std::strcmp("vkCmdDecompressMemoryNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdDecompressMemoryNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDispatch = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatch; };
    if constexpr (HasCmdDispatch) {
      if (!std::strcmp("vkCmdDispatch", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatch<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDispatchBase = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchBase; };
    if constexpr (HasCmdDispatchBase) {
      if (!std::strcmp("vkCmdDispatchBase", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchBase<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDispatchBaseKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchBaseKHR; };
    if constexpr (HasCmdDispatchBaseKHR) {
      if (!std::strcmp("vkCmdDispatchBaseKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchBaseKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDispatchDataGraphARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchDataGraphARM; };
    if constexpr (HasCmdDispatchDataGraphARM) {
      if (!std::strcmp("vkCmdDispatchDataGraphARM", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchDataGraphARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCmdDispatchGraphAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphAMDX; };
    if constexpr (HasCmdDispatchGraphAMDX) {
      if (!std::strcmp("vkCmdDispatchGraphAMDX", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchGraphAMDX<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCmdDispatchGraphIndirectAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphIndirectAMDX; };
    if constexpr (HasCmdDispatchGraphIndirectAMDX) {
      if (!std::strcmp("vkCmdDispatchGraphIndirectAMDX", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchGraphIndirectAMDX<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCmdDispatchGraphIndirectCountAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchGraphIndirectCountAMDX; };
    if constexpr (HasCmdDispatchGraphIndirectCountAMDX) {
      if (!std::strcmp("vkCmdDispatchGraphIndirectCountAMDX", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchGraphIndirectCountAMDX<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCmdDispatchIndirect = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchIndirect; };
    if constexpr (HasCmdDispatchIndirect) {
      if (!std::strcmp("vkCmdDispatchIndirect", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchIndirect<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDispatchTileQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDispatchTileQCOM; };
    if constexpr (HasCmdDispatchTileQCOM) {
      if (!std::strcmp("vkCmdDispatchTileQCOM", name))
        return (PFN_vkVoidFunction) &wrap_CmdDispatchTileQCOM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDraw = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDraw; };
    if constexpr (HasCmdDraw) {
      if (!std::strcmp("vkCmdDraw", name))
        return (PFN_vkVoidFunction) &wrap_CmdDraw<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawClusterHUAWEI = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawClusterHUAWEI; };
    if constexpr (HasCmdDrawClusterHUAWEI) {
      if (!std::strcmp("vkCmdDrawClusterHUAWEI", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawClusterHUAWEI<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawClusterIndirectHUAWEI = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawClusterIndirectHUAWEI; };
    if constexpr (HasCmdDrawClusterIndirectHUAWEI) {
      if (!std::strcmp("vkCmdDrawClusterIndirectHUAWEI", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawClusterIndirectHUAWEI<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndexed = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexed; };
    if constexpr (HasCmdDrawIndexed) {
      if (!std::strcmp("vkCmdDrawIndexed", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndexed<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndexedIndirect = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirect; };
    if constexpr (HasCmdDrawIndexedIndirect) {
      if (!std::strcmp("vkCmdDrawIndexedIndirect", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndexedIndirect<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndexedIndirectCount = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCount; };
    if constexpr (HasCmdDrawIndexedIndirectCount) {
      if (!std::strcmp("vkCmdDrawIndexedIndirectCount", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndexedIndirectCount<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndexedIndirectCountAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCountAMD; };
    if constexpr (HasCmdDrawIndexedIndirectCountAMD) {
      if (!std::strcmp("vkCmdDrawIndexedIndirectCountAMD", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndexedIndirectCountAMD<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndexedIndirectCountKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndexedIndirectCountKHR; };
    if constexpr (HasCmdDrawIndexedIndirectCountKHR) {
      if (!std::strcmp("vkCmdDrawIndexedIndirectCountKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndexedIndirectCountKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndirect = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirect; };
    if constexpr (HasCmdDrawIndirect) {
      if (!std::strcmp("vkCmdDrawIndirect", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndirect<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndirectByteCountEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectByteCountEXT; };
    if constexpr (HasCmdDrawIndirectByteCountEXT) {
      if (!std::strcmp("vkCmdDrawIndirectByteCountEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndirectByteCountEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndirectCount = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCount; };
    if constexpr (HasCmdDrawIndirectCount) {
      if (!std::strcmp("vkCmdDrawIndirectCount", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndirectCount<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndirectCountAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCountAMD; };
    if constexpr (HasCmdDrawIndirectCountAMD) {
      if (!std::strcmp("vkCmdDrawIndirectCountAMD", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndirectCountAMD<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawIndirectCountKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawIndirectCountKHR; };
    if constexpr (HasCmdDrawIndirectCountKHR) {
      if (!std::strcmp("vkCmdDrawIndirectCountKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawIndirectCountKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksEXT; };
    if constexpr (HasCmdDrawMeshTasksEXT) {
      if (!std::strcmp("vkCmdDrawMeshTasksEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksIndirectCountEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectCountEXT; };
    if constexpr (HasCmdDrawMeshTasksIndirectCountEXT) {
      if (!std::strcmp("vkCmdDrawMeshTasksIndirectCountEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksIndirectCountEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksIndirectCountNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectCountNV; };
    if constexpr (HasCmdDrawMeshTasksIndirectCountNV) {
      if (!std::strcmp("vkCmdDrawMeshTasksIndirectCountNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksIndirectCountNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksIndirectEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectEXT; };
    if constexpr (HasCmdDrawMeshTasksIndirectEXT) {
      if (!std::strcmp("vkCmdDrawMeshTasksIndirectEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksIndirectEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksIndirectNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksIndirectNV; };
    if constexpr (HasCmdDrawMeshTasksIndirectNV) {
      if (!std::strcmp("vkCmdDrawMeshTasksIndirectNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksIndirectNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMeshTasksNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMeshTasksNV; };
    if constexpr (HasCmdDrawMeshTasksNV) {
      if (!std::strcmp("vkCmdDrawMeshTasksNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMeshTasksNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMultiEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMultiEXT; };
    if constexpr (HasCmdDrawMultiEXT) {
      if (!std::strcmp("vkCmdDrawMultiEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMultiEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdDrawMultiIndexedEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdDrawMultiIndexedEXT; };
    if constexpr (HasCmdDrawMultiIndexedEXT) {
      if (!std::strcmp("vkCmdDrawMultiIndexedEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdDrawMultiIndexedEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEncodeVideoKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEncodeVideoKHR; };
    if constexpr (HasCmdEncodeVideoKHR) {
      if (!std::strcmp("vkCmdEncodeVideoKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdEncodeVideoKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndConditionalRenderingEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndConditionalRenderingEXT; };
    if constexpr (HasCmdEndConditionalRenderingEXT) {
      if (!std::strcmp("vkCmdEndConditionalRenderingEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndConditionalRenderingEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndDebugUtilsLabelEXT; };
    if constexpr (HasCmdEndDebugUtilsLabelEXT) {
      if (!std::strcmp("vkCmdEndDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndDebugUtilsLabelEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndPerTileExecutionQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndPerTileExecutionQCOM; };
    if constexpr (HasCmdEndPerTileExecutionQCOM) {
      if (!std::strcmp("vkCmdEndPerTileExecutionQCOM", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndPerTileExecutionQCOM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndQuery = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndQuery; };
    if constexpr (HasCmdEndQuery) {
      if (!std::strcmp("vkCmdEndQuery", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndQuery<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndQueryIndexedEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndQueryIndexedEXT; };
    if constexpr (HasCmdEndQueryIndexedEXT) {
      if (!std::strcmp("vkCmdEndQueryIndexedEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndQueryIndexedEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRenderPass = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass; };
    if constexpr (HasCmdEndRenderPass) {
      if (!std::strcmp("vkCmdEndRenderPass", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRenderPass<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRenderPass2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass2; };
    if constexpr (HasCmdEndRenderPass2) {
      if (!std::strcmp("vkCmdEndRenderPass2", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRenderPass2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRenderPass2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderPass2KHR; };
    if constexpr (HasCmdEndRenderPass2KHR) {
      if (!std::strcmp("vkCmdEndRenderPass2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRenderPass2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRendering = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRendering; };
    if constexpr (HasCmdEndRendering) {
      if (!std::strcmp("vkCmdEndRendering", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRendering<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRendering2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRendering2EXT; };
    if constexpr (HasCmdEndRendering2EXT) {
      if (!std::strcmp("vkCmdEndRendering2EXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRendering2EXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndRenderingKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndRenderingKHR; };
    if constexpr (HasCmdEndRenderingKHR) {
      if (!std::strcmp("vkCmdEndRenderingKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndRenderingKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndTransformFeedbackEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndTransformFeedbackEXT; };
    if constexpr (HasCmdEndTransformFeedbackEXT) {
      if (!std::strcmp("vkCmdEndTransformFeedbackEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndTransformFeedbackEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdEndVideoCodingKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdEndVideoCodingKHR; };
    if constexpr (HasCmdEndVideoCodingKHR) {
      if (!std::strcmp("vkCmdEndVideoCodingKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdEndVideoCodingKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdExecuteCommands = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteCommands; };
    if constexpr (HasCmdExecuteCommands) {
      if (!std::strcmp("vkCmdExecuteCommands", name))
        return (PFN_vkVoidFunction) &wrap_CmdExecuteCommands<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdExecuteGeneratedCommandsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteGeneratedCommandsEXT; };
    if constexpr (HasCmdExecuteGeneratedCommandsEXT) {
      if (!std::strcmp("vkCmdExecuteGeneratedCommandsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdExecuteGeneratedCommandsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdExecuteGeneratedCommandsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdExecuteGeneratedCommandsNV; };
    if constexpr (HasCmdExecuteGeneratedCommandsNV) {
      if (!std::strcmp("vkCmdExecuteGeneratedCommandsNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdExecuteGeneratedCommandsNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdFillBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdFillBuffer; };
    if constexpr (HasCmdFillBuffer) {
      if (!std::strcmp("vkCmdFillBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CmdFillBuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCmdInitializeGraphScratchMemoryAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdInitializeGraphScratchMemoryAMDX; };
    if constexpr (HasCmdInitializeGraphScratchMemoryAMDX) {
      if (!std::strcmp("vkCmdInitializeGraphScratchMemoryAMDX", name))
        return (PFN_vkVoidFunction) &wrap_CmdInitializeGraphScratchMemoryAMDX<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCmdInsertDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdInsertDebugUtilsLabelEXT; };
    if constexpr (HasCmdInsertDebugUtilsLabelEXT) {
      if (!std::strcmp("vkCmdInsertDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdInsertDebugUtilsLabelEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdNextSubpass = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass; };
    if constexpr (HasCmdNextSubpass) {
      if (!std::strcmp("vkCmdNextSubpass", name))
        return (PFN_vkVoidFunction) &wrap_CmdNextSubpass<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdNextSubpass2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass2; };
    if constexpr (HasCmdNextSubpass2) {
      if (!std::strcmp("vkCmdNextSubpass2", name))
        return (PFN_vkVoidFunction) &wrap_CmdNextSubpass2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdNextSubpass2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdNextSubpass2KHR; };
    if constexpr (HasCmdNextSubpass2KHR) {
      if (!std::strcmp("vkCmdNextSubpass2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdNextSubpass2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdOpticalFlowExecuteNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdOpticalFlowExecuteNV; };
    if constexpr (HasCmdOpticalFlowExecuteNV) {
      if (!std::strcmp("vkCmdOpticalFlowExecuteNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdOpticalFlowExecuteNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPipelineBarrier = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier; };
    if constexpr (HasCmdPipelineBarrier) {
      if (!std::strcmp("vkCmdPipelineBarrier", name))
        return (PFN_vkVoidFunction) &wrap_CmdPipelineBarrier<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPipelineBarrier2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier2; };
    if constexpr (HasCmdPipelineBarrier2) {
      if (!std::strcmp("vkCmdPipelineBarrier2", name))
        return (PFN_vkVoidFunction) &wrap_CmdPipelineBarrier2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPipelineBarrier2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPipelineBarrier2KHR; };
    if constexpr (HasCmdPipelineBarrier2KHR) {
      if (!std::strcmp("vkCmdPipelineBarrier2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPipelineBarrier2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPreprocessGeneratedCommandsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPreprocessGeneratedCommandsEXT; };
    if constexpr (HasCmdPreprocessGeneratedCommandsEXT) {
      if (!std::strcmp("vkCmdPreprocessGeneratedCommandsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdPreprocessGeneratedCommandsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPreprocessGeneratedCommandsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPreprocessGeneratedCommandsNV; };
    if constexpr (HasCmdPreprocessGeneratedCommandsNV) {
      if (!std::strcmp("vkCmdPreprocessGeneratedCommandsNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdPreprocessGeneratedCommandsNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushConstants = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushConstants; };
    if constexpr (HasCmdPushConstants) {
      if (!std::strcmp("vkCmdPushConstants", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushConstants<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushConstants2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushConstants2KHR; };
    if constexpr (HasCmdPushConstants2KHR) {
      if (!std::strcmp("vkCmdPushConstants2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushConstants2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushDescriptorSet2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSet2KHR; };
    if constexpr (HasCmdPushDescriptorSet2KHR) {
      if (!std::strcmp("vkCmdPushDescriptorSet2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushDescriptorSet2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushDescriptorSetKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetKHR; };
    if constexpr (HasCmdPushDescriptorSetKHR) {
      if (!std::strcmp("vkCmdPushDescriptorSetKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushDescriptorSetKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushDescriptorSetWithTemplate2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetWithTemplate2KHR; };
    if constexpr (HasCmdPushDescriptorSetWithTemplate2KHR) {
      if (!std::strcmp("vkCmdPushDescriptorSetWithTemplate2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushDescriptorSetWithTemplate2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdPushDescriptorSetWithTemplateKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdPushDescriptorSetWithTemplateKHR; };
    if constexpr (HasCmdPushDescriptorSetWithTemplateKHR) {
      if (!std::strcmp("vkCmdPushDescriptorSetWithTemplateKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdPushDescriptorSetWithTemplateKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResetEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent; };
    if constexpr (HasCmdResetEvent) {
      if (!std::strcmp("vkCmdResetEvent", name))
        return (PFN_vkVoidFunction) &wrap_CmdResetEvent<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResetEvent2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent2; };
    if constexpr (HasCmdResetEvent2) {
      if (!std::strcmp("vkCmdResetEvent2", name))
        return (PFN_vkVoidFunction) &wrap_CmdResetEvent2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResetEvent2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetEvent2KHR; };
    if constexpr (HasCmdResetEvent2KHR) {
      if (!std::strcmp("vkCmdResetEvent2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdResetEvent2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResetQueryPool = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResetQueryPool; };
    if constexpr (HasCmdResetQueryPool) {
      if (!std::strcmp("vkCmdResetQueryPool", name))
        return (PFN_vkVoidFunction) &wrap_CmdResetQueryPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResolveImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage; };
    if constexpr (HasCmdResolveImage) {
      if (!std::strcmp("vkCmdResolveImage", name))
        return (PFN_vkVoidFunction) &wrap_CmdResolveImage<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResolveImage2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage2; };
    if constexpr (HasCmdResolveImage2) {
      if (!std::strcmp("vkCmdResolveImage2", name))
        return (PFN_vkVoidFunction) &wrap_CmdResolveImage2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdResolveImage2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdResolveImage2KHR; };
    if constexpr (HasCmdResolveImage2KHR) {
      if (!std::strcmp("vkCmdResolveImage2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdResolveImage2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetAlphaToCoverageEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAlphaToCoverageEnableEXT; };
    if constexpr (HasCmdSetAlphaToCoverageEnableEXT) {
      if (!std::strcmp("vkCmdSetAlphaToCoverageEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetAlphaToCoverageEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetAlphaToOneEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAlphaToOneEnableEXT; };
    if constexpr (HasCmdSetAlphaToOneEnableEXT) {
      if (!std::strcmp("vkCmdSetAlphaToOneEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetAlphaToOneEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetAttachmentFeedbackLoopEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetAttachmentFeedbackLoopEnableEXT; };
    if constexpr (HasCmdSetAttachmentFeedbackLoopEnableEXT) {
      if (!std::strcmp("vkCmdSetAttachmentFeedbackLoopEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetAttachmentFeedbackLoopEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetBlendConstants = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetBlendConstants; };
    if constexpr (HasCmdSetBlendConstants) {
      if (!std::strcmp("vkCmdSetBlendConstants", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetBlendConstants<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCheckpointNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCheckpointNV; };
    if constexpr (HasCmdSetCheckpointNV) {
      if (!std::strcmp("vkCmdSetCheckpointNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCheckpointNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoarseSampleOrderNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoarseSampleOrderNV; };
    if constexpr (HasCmdSetCoarseSampleOrderNV) {
      if (!std::strcmp("vkCmdSetCoarseSampleOrderNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoarseSampleOrderNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetColorBlendAdvancedEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendAdvancedEXT; };
    if constexpr (HasCmdSetColorBlendAdvancedEXT) {
      if (!std::strcmp("vkCmdSetColorBlendAdvancedEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetColorBlendAdvancedEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetColorBlendEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendEnableEXT; };
    if constexpr (HasCmdSetColorBlendEnableEXT) {
      if (!std::strcmp("vkCmdSetColorBlendEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetColorBlendEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetColorBlendEquationEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorBlendEquationEXT; };
    if constexpr (HasCmdSetColorBlendEquationEXT) {
      if (!std::strcmp("vkCmdSetColorBlendEquationEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetColorBlendEquationEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetColorWriteEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorWriteEnableEXT; };
    if constexpr (HasCmdSetColorWriteEnableEXT) {
      if (!std::strcmp("vkCmdSetColorWriteEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetColorWriteEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetColorWriteMaskEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetColorWriteMaskEXT; };
    if constexpr (HasCmdSetColorWriteMaskEXT) {
      if (!std::strcmp("vkCmdSetColorWriteMaskEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetColorWriteMaskEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetConservativeRasterizationModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetConservativeRasterizationModeEXT; };
    if constexpr (HasCmdSetConservativeRasterizationModeEXT) {
      if (!std::strcmp("vkCmdSetConservativeRasterizationModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetConservativeRasterizationModeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageModulationModeNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationModeNV; };
    if constexpr (HasCmdSetCoverageModulationModeNV) {
      if (!std::strcmp("vkCmdSetCoverageModulationModeNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageModulationModeNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageModulationTableEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationTableEnableNV; };
    if constexpr (HasCmdSetCoverageModulationTableEnableNV) {
      if (!std::strcmp("vkCmdSetCoverageModulationTableEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageModulationTableEnableNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageModulationTableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageModulationTableNV; };
    if constexpr (HasCmdSetCoverageModulationTableNV) {
      if (!std::strcmp("vkCmdSetCoverageModulationTableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageModulationTableNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageReductionModeNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageReductionModeNV; };
    if constexpr (HasCmdSetCoverageReductionModeNV) {
      if (!std::strcmp("vkCmdSetCoverageReductionModeNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageReductionModeNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageToColorEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageToColorEnableNV; };
    if constexpr (HasCmdSetCoverageToColorEnableNV) {
      if (!std::strcmp("vkCmdSetCoverageToColorEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageToColorEnableNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCoverageToColorLocationNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCoverageToColorLocationNV; };
    if constexpr (HasCmdSetCoverageToColorLocationNV) {
      if (!std::strcmp("vkCmdSetCoverageToColorLocationNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCoverageToColorLocationNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCullMode = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCullMode; };
    if constexpr (HasCmdSetCullMode) {
      if (!std::strcmp("vkCmdSetCullMode", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCullMode<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetCullModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetCullModeEXT; };
    if constexpr (HasCmdSetCullModeEXT) {
      if (!std::strcmp("vkCmdSetCullModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetCullModeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBias = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBias; };
    if constexpr (HasCmdSetDepthBias) {
      if (!std::strcmp("vkCmdSetDepthBias", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBias<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBias2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBias2EXT; };
    if constexpr (HasCmdSetDepthBias2EXT) {
      if (!std::strcmp("vkCmdSetDepthBias2EXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBias2EXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBiasEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBiasEnable; };
    if constexpr (HasCmdSetDepthBiasEnable) {
      if (!std::strcmp("vkCmdSetDepthBiasEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBiasEnable<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBiasEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBiasEnableEXT; };
    if constexpr (HasCmdSetDepthBiasEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthBiasEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBiasEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBounds = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBounds; };
    if constexpr (HasCmdSetDepthBounds) {
      if (!std::strcmp("vkCmdSetDepthBounds", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBounds<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBoundsTestEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBoundsTestEnable; };
    if constexpr (HasCmdSetDepthBoundsTestEnable) {
      if (!std::strcmp("vkCmdSetDepthBoundsTestEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBoundsTestEnable<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthBoundsTestEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthBoundsTestEnableEXT; };
    if constexpr (HasCmdSetDepthBoundsTestEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthBoundsTestEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthBoundsTestEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthClampEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClampEnableEXT; };
    if constexpr (HasCmdSetDepthClampEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthClampEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthClampEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthClampRangeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClampRangeEXT; };
    if constexpr (HasCmdSetDepthClampRangeEXT) {
      if (!std::strcmp("vkCmdSetDepthClampRangeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthClampRangeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthClipEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClipEnableEXT; };
    if constexpr (HasCmdSetDepthClipEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthClipEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthClipEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthClipNegativeOneToOneEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthClipNegativeOneToOneEXT; };
    if constexpr (HasCmdSetDepthClipNegativeOneToOneEXT) {
      if (!std::strcmp("vkCmdSetDepthClipNegativeOneToOneEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthClipNegativeOneToOneEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthCompareOp = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthCompareOp; };
    if constexpr (HasCmdSetDepthCompareOp) {
      if (!std::strcmp("vkCmdSetDepthCompareOp", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthCompareOp<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthCompareOpEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthCompareOpEXT; };
    if constexpr (HasCmdSetDepthCompareOpEXT) {
      if (!std::strcmp("vkCmdSetDepthCompareOpEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthCompareOpEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthTestEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthTestEnable; };
    if constexpr (HasCmdSetDepthTestEnable) {
      if (!std::strcmp("vkCmdSetDepthTestEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthTestEnable<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthTestEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthTestEnableEXT; };
    if constexpr (HasCmdSetDepthTestEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthTestEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthTestEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthWriteEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthWriteEnable; };
    if constexpr (HasCmdSetDepthWriteEnable) {
      if (!std::strcmp("vkCmdSetDepthWriteEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthWriteEnable<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDepthWriteEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDepthWriteEnableEXT; };
    if constexpr (HasCmdSetDepthWriteEnableEXT) {
      if (!std::strcmp("vkCmdSetDepthWriteEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDepthWriteEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDescriptorBufferOffsets2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDescriptorBufferOffsets2EXT; };
    if constexpr (HasCmdSetDescriptorBufferOffsets2EXT) {
      if (!std::strcmp("vkCmdSetDescriptorBufferOffsets2EXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDescriptorBufferOffsets2EXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDescriptorBufferOffsetsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDescriptorBufferOffsetsEXT; };
    if constexpr (HasCmdSetDescriptorBufferOffsetsEXT) {
      if (!std::strcmp("vkCmdSetDescriptorBufferOffsetsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDescriptorBufferOffsetsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDeviceMask = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDeviceMask; };
    if constexpr (HasCmdSetDeviceMask) {
      if (!std::strcmp("vkCmdSetDeviceMask", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDeviceMask<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDeviceMaskKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDeviceMaskKHR; };
    if constexpr (HasCmdSetDeviceMaskKHR) {
      if (!std::strcmp("vkCmdSetDeviceMaskKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDeviceMaskKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDiscardRectangleEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleEXT; };
    if constexpr (HasCmdSetDiscardRectangleEXT) {
      if (!std::strcmp("vkCmdSetDiscardRectangleEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDiscardRectangleEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDiscardRectangleEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleEnableEXT; };
    if constexpr (HasCmdSetDiscardRectangleEnableEXT) {
      if (!std::strcmp("vkCmdSetDiscardRectangleEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDiscardRectangleEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetDiscardRectangleModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetDiscardRectangleModeEXT; };
    if constexpr (HasCmdSetDiscardRectangleModeEXT) {
      if (!std::strcmp("vkCmdSetDiscardRectangleModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetDiscardRectangleModeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent; };
    if constexpr (HasCmdSetEvent) {
      if (!std::strcmp("vkCmdSetEvent", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetEvent<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetEvent2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent2; };
    if constexpr (HasCmdSetEvent2) {
      if (!std::strcmp("vkCmdSetEvent2", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetEvent2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetEvent2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetEvent2KHR; };
    if constexpr (HasCmdSetEvent2KHR) {
      if (!std::strcmp("vkCmdSetEvent2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetEvent2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetExclusiveScissorEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExclusiveScissorEnableNV; };
    if constexpr (HasCmdSetExclusiveScissorEnableNV) {
      if (!std::strcmp("vkCmdSetExclusiveScissorEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetExclusiveScissorEnableNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetExclusiveScissorNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExclusiveScissorNV; };
    if constexpr (HasCmdSetExclusiveScissorNV) {
      if (!std::strcmp("vkCmdSetExclusiveScissorNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetExclusiveScissorNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetExtraPrimitiveOverestimationSizeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetExtraPrimitiveOverestimationSizeEXT; };
    if constexpr (HasCmdSetExtraPrimitiveOverestimationSizeEXT) {
      if (!std::strcmp("vkCmdSetExtraPrimitiveOverestimationSizeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetExtraPrimitiveOverestimationSizeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetFragmentShadingRateEnumNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFragmentShadingRateEnumNV; };
    if constexpr (HasCmdSetFragmentShadingRateEnumNV) {
      if (!std::strcmp("vkCmdSetFragmentShadingRateEnumNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetFragmentShadingRateEnumNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetFragmentShadingRateKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFragmentShadingRateKHR; };
    if constexpr (HasCmdSetFragmentShadingRateKHR) {
      if (!std::strcmp("vkCmdSetFragmentShadingRateKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetFragmentShadingRateKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetFrontFace = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFrontFace; };
    if constexpr (HasCmdSetFrontFace) {
      if (!std::strcmp("vkCmdSetFrontFace", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetFrontFace<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetFrontFaceEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetFrontFaceEXT; };
    if constexpr (HasCmdSetFrontFaceEXT) {
      if (!std::strcmp("vkCmdSetFrontFaceEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetFrontFaceEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLineRasterizationModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineRasterizationModeEXT; };
    if constexpr (HasCmdSetLineRasterizationModeEXT) {
      if (!std::strcmp("vkCmdSetLineRasterizationModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLineRasterizationModeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLineStippleEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleEXT; };
    if constexpr (HasCmdSetLineStippleEXT) {
      if (!std::strcmp("vkCmdSetLineStippleEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLineStippleEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLineStippleEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleEnableEXT; };
    if constexpr (HasCmdSetLineStippleEnableEXT) {
      if (!std::strcmp("vkCmdSetLineStippleEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLineStippleEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLineStippleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineStippleKHR; };
    if constexpr (HasCmdSetLineStippleKHR) {
      if (!std::strcmp("vkCmdSetLineStippleKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLineStippleKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLineWidth = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLineWidth; };
    if constexpr (HasCmdSetLineWidth) {
      if (!std::strcmp("vkCmdSetLineWidth", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLineWidth<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLogicOpEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLogicOpEXT; };
    if constexpr (HasCmdSetLogicOpEXT) {
      if (!std::strcmp("vkCmdSetLogicOpEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLogicOpEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetLogicOpEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetLogicOpEnableEXT; };
    if constexpr (HasCmdSetLogicOpEnableEXT) {
      if (!std::strcmp("vkCmdSetLogicOpEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetLogicOpEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPatchControlPointsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPatchControlPointsEXT; };
    if constexpr (HasCmdSetPatchControlPointsEXT) {
      if (!std::strcmp("vkCmdSetPatchControlPointsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPatchControlPointsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPerformanceMarkerINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceMarkerINTEL; };
    if constexpr (HasCmdSetPerformanceMarkerINTEL) {
      if (!std::strcmp("vkCmdSetPerformanceMarkerINTEL", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPerformanceMarkerINTEL<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPerformanceOverrideINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceOverrideINTEL; };
    if constexpr (HasCmdSetPerformanceOverrideINTEL) {
      if (!std::strcmp("vkCmdSetPerformanceOverrideINTEL", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPerformanceOverrideINTEL<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPerformanceStreamMarkerINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPerformanceStreamMarkerINTEL; };
    if constexpr (HasCmdSetPerformanceStreamMarkerINTEL) {
      if (!std::strcmp("vkCmdSetPerformanceStreamMarkerINTEL", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPerformanceStreamMarkerINTEL<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPolygonModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPolygonModeEXT; };
    if constexpr (HasCmdSetPolygonModeEXT) {
      if (!std::strcmp("vkCmdSetPolygonModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPolygonModeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPrimitiveRestartEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveRestartEnable; };
    if constexpr (HasCmdSetPrimitiveRestartEnable) {
      if (!std::strcmp("vkCmdSetPrimitiveRestartEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPrimitiveRestartEnable<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPrimitiveRestartEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveRestartEnableEXT; };
    if constexpr (HasCmdSetPrimitiveRestartEnableEXT) {
      if (!std::strcmp("vkCmdSetPrimitiveRestartEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPrimitiveRestartEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPrimitiveTopology = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveTopology; };
    if constexpr (HasCmdSetPrimitiveTopology) {
      if (!std::strcmp("vkCmdSetPrimitiveTopology", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPrimitiveTopology<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetPrimitiveTopologyEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetPrimitiveTopologyEXT; };
    if constexpr (HasCmdSetPrimitiveTopologyEXT) {
      if (!std::strcmp("vkCmdSetPrimitiveTopologyEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetPrimitiveTopologyEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetProvokingVertexModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetProvokingVertexModeEXT; };
    if constexpr (HasCmdSetProvokingVertexModeEXT) {
      if (!std::strcmp("vkCmdSetProvokingVertexModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetProvokingVertexModeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRasterizationSamplesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizationSamplesEXT; };
    if constexpr (HasCmdSetRasterizationSamplesEXT) {
      if (!std::strcmp("vkCmdSetRasterizationSamplesEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRasterizationSamplesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRasterizationStreamEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizationStreamEXT; };
    if constexpr (HasCmdSetRasterizationStreamEXT) {
      if (!std::strcmp("vkCmdSetRasterizationStreamEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRasterizationStreamEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRasterizerDiscardEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizerDiscardEnable; };
    if constexpr (HasCmdSetRasterizerDiscardEnable) {
      if (!std::strcmp("vkCmdSetRasterizerDiscardEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRasterizerDiscardEnable<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRasterizerDiscardEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRasterizerDiscardEnableEXT; };
    if constexpr (HasCmdSetRasterizerDiscardEnableEXT) {
      if (!std::strcmp("vkCmdSetRasterizerDiscardEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRasterizerDiscardEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRayTracingPipelineStackSizeKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRayTracingPipelineStackSizeKHR; };
    if constexpr (HasCmdSetRayTracingPipelineStackSizeKHR) {
      if (!std::strcmp("vkCmdSetRayTracingPipelineStackSizeKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRayTracingPipelineStackSizeKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRenderingAttachmentLocationsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRenderingAttachmentLocationsKHR; };
    if constexpr (HasCmdSetRenderingAttachmentLocationsKHR) {
      if (!std::strcmp("vkCmdSetRenderingAttachmentLocationsKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRenderingAttachmentLocationsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRenderingInputAttachmentIndicesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRenderingInputAttachmentIndicesKHR; };
    if constexpr (HasCmdSetRenderingInputAttachmentIndicesKHR) {
      if (!std::strcmp("vkCmdSetRenderingInputAttachmentIndicesKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRenderingInputAttachmentIndicesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetRepresentativeFragmentTestEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetRepresentativeFragmentTestEnableNV; };
    if constexpr (HasCmdSetRepresentativeFragmentTestEnableNV) {
      if (!std::strcmp("vkCmdSetRepresentativeFragmentTestEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetRepresentativeFragmentTestEnableNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetSampleLocationsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleLocationsEXT; };
    if constexpr (HasCmdSetSampleLocationsEXT) {
      if (!std::strcmp("vkCmdSetSampleLocationsEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetSampleLocationsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetSampleLocationsEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleLocationsEnableEXT; };
    if constexpr (HasCmdSetSampleLocationsEnableEXT) {
      if (!std::strcmp("vkCmdSetSampleLocationsEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetSampleLocationsEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetSampleMaskEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetSampleMaskEXT; };
    if constexpr (HasCmdSetSampleMaskEXT) {
      if (!std::strcmp("vkCmdSetSampleMaskEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetSampleMaskEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetScissor = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissor; };
    if constexpr (HasCmdSetScissor) {
      if (!std::strcmp("vkCmdSetScissor", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetScissor<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetScissorWithCount = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissorWithCount; };
    if constexpr (HasCmdSetScissorWithCount) {
      if (!std::strcmp("vkCmdSetScissorWithCount", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetScissorWithCount<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetScissorWithCountEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetScissorWithCountEXT; };
    if constexpr (HasCmdSetScissorWithCountEXT) {
      if (!std::strcmp("vkCmdSetScissorWithCountEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetScissorWithCountEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetShadingRateImageEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetShadingRateImageEnableNV; };
    if constexpr (HasCmdSetShadingRateImageEnableNV) {
      if (!std::strcmp("vkCmdSetShadingRateImageEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetShadingRateImageEnableNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilCompareMask = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilCompareMask; };
    if constexpr (HasCmdSetStencilCompareMask) {
      if (!std::strcmp("vkCmdSetStencilCompareMask", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilCompareMask<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilOp = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilOp; };
    if constexpr (HasCmdSetStencilOp) {
      if (!std::strcmp("vkCmdSetStencilOp", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilOp<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilOpEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilOpEXT; };
    if constexpr (HasCmdSetStencilOpEXT) {
      if (!std::strcmp("vkCmdSetStencilOpEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilOpEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilReference = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilReference; };
    if constexpr (HasCmdSetStencilReference) {
      if (!std::strcmp("vkCmdSetStencilReference", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilReference<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilTestEnable = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilTestEnable; };
    if constexpr (HasCmdSetStencilTestEnable) {
      if (!std::strcmp("vkCmdSetStencilTestEnable", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilTestEnable<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilTestEnableEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilTestEnableEXT; };
    if constexpr (HasCmdSetStencilTestEnableEXT) {
      if (!std::strcmp("vkCmdSetStencilTestEnableEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilTestEnableEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetStencilWriteMask = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetStencilWriteMask; };
    if constexpr (HasCmdSetStencilWriteMask) {
      if (!std::strcmp("vkCmdSetStencilWriteMask", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetStencilWriteMask<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetTessellationDomainOriginEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetTessellationDomainOriginEXT; };
    if constexpr (HasCmdSetTessellationDomainOriginEXT) {
      if (!std::strcmp("vkCmdSetTessellationDomainOriginEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetTessellationDomainOriginEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetVertexInputEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetVertexInputEXT; };
    if constexpr (HasCmdSetVertexInputEXT) {
      if (!std::strcmp("vkCmdSetVertexInputEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetVertexInputEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewport = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewport; };
    if constexpr (HasCmdSetViewport) {
      if (!std::strcmp("vkCmdSetViewport", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewport<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportShadingRatePaletteNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportShadingRatePaletteNV; };
    if constexpr (HasCmdSetViewportShadingRatePaletteNV) {
      if (!std::strcmp("vkCmdSetViewportShadingRatePaletteNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportShadingRatePaletteNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportSwizzleNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportSwizzleNV; };
    if constexpr (HasCmdSetViewportSwizzleNV) {
      if (!std::strcmp("vkCmdSetViewportSwizzleNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportSwizzleNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportWScalingEnableNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWScalingEnableNV; };
    if constexpr (HasCmdSetViewportWScalingEnableNV) {
      if (!std::strcmp("vkCmdSetViewportWScalingEnableNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportWScalingEnableNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportWScalingNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWScalingNV; };
    if constexpr (HasCmdSetViewportWScalingNV) {
      if (!std::strcmp("vkCmdSetViewportWScalingNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportWScalingNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportWithCount = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWithCount; };
    if constexpr (HasCmdSetViewportWithCount) {
      if (!std::strcmp("vkCmdSetViewportWithCount", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportWithCount<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSetViewportWithCountEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSetViewportWithCountEXT; };
    if constexpr (HasCmdSetViewportWithCountEXT) {
      if (!std::strcmp("vkCmdSetViewportWithCountEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdSetViewportWithCountEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdSubpassShadingHUAWEI = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdSubpassShadingHUAWEI; };
    if constexpr (HasCmdSubpassShadingHUAWEI) {
      if (!std::strcmp("vkCmdSubpassShadingHUAWEI", name))
        return (PFN_vkVoidFunction) &wrap_CmdSubpassShadingHUAWEI<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdTraceRaysIndirect2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysIndirect2KHR; };
    if constexpr (HasCmdTraceRaysIndirect2KHR) {
      if (!std::strcmp("vkCmdTraceRaysIndirect2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdTraceRaysIndirect2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdTraceRaysIndirectKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysIndirectKHR; };
    if constexpr (HasCmdTraceRaysIndirectKHR) {
      if (!std::strcmp("vkCmdTraceRaysIndirectKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdTraceRaysIndirectKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdTraceRaysKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysKHR; };
    if constexpr (HasCmdTraceRaysKHR) {
      if (!std::strcmp("vkCmdTraceRaysKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdTraceRaysKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdTraceRaysNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdTraceRaysNV; };
    if constexpr (HasCmdTraceRaysNV) {
      if (!std::strcmp("vkCmdTraceRaysNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdTraceRaysNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdUpdateBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdUpdateBuffer; };
    if constexpr (HasCmdUpdateBuffer) {
      if (!std::strcmp("vkCmdUpdateBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CmdUpdateBuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdUpdatePipelineIndirectBufferNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdUpdatePipelineIndirectBufferNV; };
    if constexpr (HasCmdUpdatePipelineIndirectBufferNV) {
      if (!std::strcmp("vkCmdUpdatePipelineIndirectBufferNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdUpdatePipelineIndirectBufferNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWaitEvents = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents; };
    if constexpr (HasCmdWaitEvents) {
      if (!std::strcmp("vkCmdWaitEvents", name))
        return (PFN_vkVoidFunction) &wrap_CmdWaitEvents<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWaitEvents2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents2; };
    if constexpr (HasCmdWaitEvents2) {
      if (!std::strcmp("vkCmdWaitEvents2", name))
        return (PFN_vkVoidFunction) &wrap_CmdWaitEvents2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWaitEvents2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWaitEvents2KHR; };
    if constexpr (HasCmdWaitEvents2KHR) {
      if (!std::strcmp("vkCmdWaitEvents2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdWaitEvents2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteAccelerationStructuresPropertiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteAccelerationStructuresPropertiesKHR; };
    if constexpr (HasCmdWriteAccelerationStructuresPropertiesKHR) {
      if (!std::strcmp("vkCmdWriteAccelerationStructuresPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteAccelerationStructuresPropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteAccelerationStructuresPropertiesNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteAccelerationStructuresPropertiesNV; };
    if constexpr (HasCmdWriteAccelerationStructuresPropertiesNV) {
      if (!std::strcmp("vkCmdWriteAccelerationStructuresPropertiesNV", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteAccelerationStructuresPropertiesNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteBufferMarker2AMD = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteBufferMarker2AMD; };
    if constexpr (HasCmdWriteBufferMarker2AMD) {
      if (!std::strcmp("vkCmdWriteBufferMarker2AMD", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteBufferMarker2AMD<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteBufferMarkerAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteBufferMarkerAMD; };
    if constexpr (HasCmdWriteBufferMarkerAMD) {
      if (!std::strcmp("vkCmdWriteBufferMarkerAMD", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteBufferMarkerAMD<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteMicromapsPropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteMicromapsPropertiesEXT; };
    if constexpr (HasCmdWriteMicromapsPropertiesEXT) {
      if (!std::strcmp("vkCmdWriteMicromapsPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteMicromapsPropertiesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteTimestamp = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp; };
    if constexpr (HasCmdWriteTimestamp) {
      if (!std::strcmp("vkCmdWriteTimestamp", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteTimestamp<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteTimestamp2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp2; };
    if constexpr (HasCmdWriteTimestamp2) {
      if (!std::strcmp("vkCmdWriteTimestamp2", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteTimestamp2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCmdWriteTimestamp2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CmdWriteTimestamp2KHR; };
    if constexpr (HasCmdWriteTimestamp2KHR) {
      if (!std::strcmp("vkCmdWriteTimestamp2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CmdWriteTimestamp2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCompileDeferredNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CompileDeferredNV; };
    if constexpr (HasCompileDeferredNV) {
      if (!std::strcmp("vkCompileDeferredNV", name))
        return (PFN_vkVoidFunction) &wrap_CompileDeferredNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasConvertCooperativeVectorMatrixNV = requires(const DeviceOverrides& t) { &DeviceOverrides::ConvertCooperativeVectorMatrixNV; };
    if constexpr (HasConvertCooperativeVectorMatrixNV) {
      if (!std::strcmp("vkConvertCooperativeVectorMatrixNV", name))
        return (PFN_vkVoidFunction) &wrap_ConvertCooperativeVectorMatrixNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyAccelerationStructureKHR; };
    if constexpr (HasCopyAccelerationStructureKHR) {
      if (!std::strcmp("vkCopyAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_CopyAccelerationStructureKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyAccelerationStructureToMemoryKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyAccelerationStructureToMemoryKHR; };
    if constexpr (HasCopyAccelerationStructureToMemoryKHR) {
      if (!std::strcmp("vkCopyAccelerationStructureToMemoryKHR", name))
        return (PFN_vkVoidFunction) &wrap_CopyAccelerationStructureToMemoryKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyImageToImageEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyImageToImageEXT; };
    if constexpr (HasCopyImageToImageEXT) {
      if (!std::strcmp("vkCopyImageToImageEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyImageToImageEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyImageToMemoryEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyImageToMemoryEXT; };
    if constexpr (HasCopyImageToMemoryEXT) {
      if (!std::strcmp("vkCopyImageToMemoryEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyImageToMemoryEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyMemoryToAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyMemoryToAccelerationStructureKHR; };
    if constexpr (HasCopyMemoryToAccelerationStructureKHR) {
      if (!std::strcmp("vkCopyMemoryToAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_CopyMemoryToAccelerationStructureKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyMemoryToImageEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyMemoryToImageEXT; };
    if constexpr (HasCopyMemoryToImageEXT) {
      if (!std::strcmp("vkCopyMemoryToImageEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyMemoryToImageEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyMemoryToMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyMemoryToMicromapEXT; };
    if constexpr (HasCopyMemoryToMicromapEXT) {
      if (!std::strcmp("vkCopyMemoryToMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyMemoryToMicromapEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyMicromapEXT; };
    if constexpr (HasCopyMicromapEXT) {
      if (!std::strcmp("vkCopyMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyMicromapEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCopyMicromapToMemoryEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CopyMicromapToMemoryEXT; };
    if constexpr (HasCopyMicromapToMemoryEXT) {
      if (!std::strcmp("vkCopyMicromapToMemoryEXT", name))
        return (PFN_vkVoidFunction) &wrap_CopyMicromapToMemoryEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateAccelerationStructureKHR; };
    if constexpr (HasCreateAccelerationStructureKHR) {
      if (!std::strcmp("vkCreateAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateAccelerationStructureKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateAccelerationStructureNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateAccelerationStructureNV; };
    if constexpr (HasCreateAccelerationStructureNV) {
      if (!std::strcmp("vkCreateAccelerationStructureNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateAccelerationStructureNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateBuffer; };
    if constexpr (HasCreateBuffer) {
      if (!std::strcmp("vkCreateBuffer", name))
        return (PFN_vkVoidFunction) &wrap_CreateBuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasCreateBufferCollectionFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateBufferCollectionFUCHSIA; };
    if constexpr (HasCreateBufferCollectionFUCHSIA) {
      if (!std::strcmp("vkCreateBufferCollectionFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_CreateBufferCollectionFUCHSIA<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateBufferView = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateBufferView; };
    if constexpr (HasCreateBufferView) {
      if (!std::strcmp("vkCreateBufferView", name))
        return (PFN_vkVoidFunction) &wrap_CreateBufferView<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateCommandPool = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateCommandPool; };
    if constexpr (HasCreateCommandPool) {
      if (!std::strcmp("vkCreateCommandPool", name))
        return (PFN_vkVoidFunction) &wrap_CreateCommandPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateComputePipelines = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateComputePipelines; };
    if constexpr (HasCreateComputePipelines) {
      if (!std::strcmp("vkCreateComputePipelines", name))
        return (PFN_vkVoidFunction) &wrap_CreateComputePipelines<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCreateCudaFunctionNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateCudaFunctionNV; };
    if constexpr (HasCreateCudaFunctionNV) {
      if (!std::strcmp("vkCreateCudaFunctionNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateCudaFunctionNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCreateCudaModuleNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateCudaModuleNV; };
    if constexpr (HasCreateCudaModuleNV) {
      if (!std::strcmp("vkCreateCudaModuleNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateCudaModuleNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateDataGraphPipelineSessionARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDataGraphPipelineSessionARM; };
    if constexpr (HasCreateDataGraphPipelineSessionARM) {
      if (!std::strcmp("vkCreateDataGraphPipelineSessionARM", name))
        return (PFN_vkVoidFunction) &wrap_CreateDataGraphPipelineSessionARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDataGraphPipelinesARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDataGraphPipelinesARM; };
    if constexpr (HasCreateDataGraphPipelinesARM) {
      if (!std::strcmp("vkCreateDataGraphPipelinesARM", name))
        return (PFN_vkVoidFunction) &wrap_CreateDataGraphPipelinesARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDeferredOperationKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDeferredOperationKHR; };
    if constexpr (HasCreateDeferredOperationKHR) {
      if (!std::strcmp("vkCreateDeferredOperationKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateDeferredOperationKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDescriptorPool = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDescriptorPool; };
    if constexpr (HasCreateDescriptorPool) {
      if (!std::strcmp("vkCreateDescriptorPool", name))
        return (PFN_vkVoidFunction) &wrap_CreateDescriptorPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDescriptorSetLayout = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDescriptorSetLayout; };
    if constexpr (HasCreateDescriptorSetLayout) {
      if (!std::strcmp("vkCreateDescriptorSetLayout", name))
        return (PFN_vkVoidFunction) &wrap_CreateDescriptorSetLayout<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDescriptorUpdateTemplate = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDescriptorUpdateTemplate; };
    if constexpr (HasCreateDescriptorUpdateTemplate) {
      if (!std::strcmp("vkCreateDescriptorUpdateTemplate", name))
        return (PFN_vkVoidFunction) &wrap_CreateDescriptorUpdateTemplate<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateDescriptorUpdateTemplateKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateDescriptorUpdateTemplateKHR; };
    if constexpr (HasCreateDescriptorUpdateTemplateKHR) {
      if (!std::strcmp("vkCreateDescriptorUpdateTemplateKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateDescriptorUpdateTemplateKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateEvent; };
    if constexpr (HasCreateEvent) {
      if (!std::strcmp("vkCreateEvent", name))
        return (PFN_vkVoidFunction) &wrap_CreateEvent<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasCreateExecutionGraphPipelinesAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateExecutionGraphPipelinesAMDX; };
    if constexpr (HasCreateExecutionGraphPipelinesAMDX) {
      if (!std::strcmp("vkCreateExecutionGraphPipelinesAMDX", name))
        return (PFN_vkVoidFunction) &wrap_CreateExecutionGraphPipelinesAMDX<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasCreateExternalComputeQueueNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateExternalComputeQueueNV; };
    if constexpr (HasCreateExternalComputeQueueNV) {
      if (!std::strcmp("vkCreateExternalComputeQueueNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateExternalComputeQueueNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateFence = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateFence; };
    if constexpr (HasCreateFence) {
      if (!std::strcmp("vkCreateFence", name))
        return (PFN_vkVoidFunction) &wrap_CreateFence<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateFramebuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateFramebuffer; };
    if constexpr (HasCreateFramebuffer) {
      if (!std::strcmp("vkCreateFramebuffer", name))
        return (PFN_vkVoidFunction) &wrap_CreateFramebuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateGraphicsPipelines = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateGraphicsPipelines; };
    if constexpr (HasCreateGraphicsPipelines) {
      if (!std::strcmp("vkCreateGraphicsPipelines", name))
        return (PFN_vkVoidFunction) &wrap_CreateGraphicsPipelines<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateImage = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateImage; };
    if constexpr (HasCreateImage) {
      if (!std::strcmp("vkCreateImage", name))
        return (PFN_vkVoidFunction) &wrap_CreateImage<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateImageView = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateImageView; };
    if constexpr (HasCreateImageView) {
      if (!std::strcmp("vkCreateImageView", name))
        return (PFN_vkVoidFunction) &wrap_CreateImageView<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateIndirectCommandsLayoutEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateIndirectCommandsLayoutEXT; };
    if constexpr (HasCreateIndirectCommandsLayoutEXT) {
      if (!std::strcmp("vkCreateIndirectCommandsLayoutEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateIndirectCommandsLayoutEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateIndirectCommandsLayoutNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateIndirectCommandsLayoutNV; };
    if constexpr (HasCreateIndirectCommandsLayoutNV) {
      if (!std::strcmp("vkCreateIndirectCommandsLayoutNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateIndirectCommandsLayoutNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateIndirectExecutionSetEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateIndirectExecutionSetEXT; };
    if constexpr (HasCreateIndirectExecutionSetEXT) {
      if (!std::strcmp("vkCreateIndirectExecutionSetEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateIndirectExecutionSetEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateMicromapEXT; };
    if constexpr (HasCreateMicromapEXT) {
      if (!std::strcmp("vkCreateMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateMicromapEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateOpticalFlowSessionNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateOpticalFlowSessionNV; };
    if constexpr (HasCreateOpticalFlowSessionNV) {
      if (!std::strcmp("vkCreateOpticalFlowSessionNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateOpticalFlowSessionNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreatePipelineBinariesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreatePipelineBinariesKHR; };
    if constexpr (HasCreatePipelineBinariesKHR) {
      if (!std::strcmp("vkCreatePipelineBinariesKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreatePipelineBinariesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreatePipelineCache = requires(const DeviceOverrides& t) { &DeviceOverrides::CreatePipelineCache; };
    if constexpr (HasCreatePipelineCache) {
      if (!std::strcmp("vkCreatePipelineCache", name))
        return (PFN_vkVoidFunction) &wrap_CreatePipelineCache<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreatePipelineLayout = requires(const DeviceOverrides& t) { &DeviceOverrides::CreatePipelineLayout; };
    if constexpr (HasCreatePipelineLayout) {
      if (!std::strcmp("vkCreatePipelineLayout", name))
        return (PFN_vkVoidFunction) &wrap_CreatePipelineLayout<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreatePrivateDataSlot = requires(const DeviceOverrides& t) { &DeviceOverrides::CreatePrivateDataSlot; };
    if constexpr (HasCreatePrivateDataSlot) {
      if (!std::strcmp("vkCreatePrivateDataSlot", name))
        return (PFN_vkVoidFunction) &wrap_CreatePrivateDataSlot<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreatePrivateDataSlotEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreatePrivateDataSlotEXT; };
    if constexpr (HasCreatePrivateDataSlotEXT) {
      if (!std::strcmp("vkCreatePrivateDataSlotEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreatePrivateDataSlotEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateQueryPool = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateQueryPool; };
    if constexpr (HasCreateQueryPool) {
      if (!std::strcmp("vkCreateQueryPool", name))
        return (PFN_vkVoidFunction) &wrap_CreateQueryPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateRayTracingPipelinesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateRayTracingPipelinesKHR; };
    if constexpr (HasCreateRayTracingPipelinesKHR) {
      if (!std::strcmp("vkCreateRayTracingPipelinesKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateRayTracingPipelinesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateRayTracingPipelinesNV = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateRayTracingPipelinesNV; };
    if constexpr (HasCreateRayTracingPipelinesNV) {
      if (!std::strcmp("vkCreateRayTracingPipelinesNV", name))
        return (PFN_vkVoidFunction) &wrap_CreateRayTracingPipelinesNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateRenderPass = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateRenderPass; };
    if constexpr (HasCreateRenderPass) {
      if (!std::strcmp("vkCreateRenderPass", name))
        return (PFN_vkVoidFunction) &wrap_CreateRenderPass<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateRenderPass2 = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateRenderPass2; };
    if constexpr (HasCreateRenderPass2) {
      if (!std::strcmp("vkCreateRenderPass2", name))
        return (PFN_vkVoidFunction) &wrap_CreateRenderPass2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateRenderPass2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateRenderPass2KHR; };
    if constexpr (HasCreateRenderPass2KHR) {
      if (!std::strcmp("vkCreateRenderPass2KHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateRenderPass2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSampler = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSampler; };
    if constexpr (HasCreateSampler) {
      if (!std::strcmp("vkCreateSampler", name))
        return (PFN_vkVoidFunction) &wrap_CreateSampler<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSamplerYcbcrConversion = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSamplerYcbcrConversion; };
    if constexpr (HasCreateSamplerYcbcrConversion) {
      if (!std::strcmp("vkCreateSamplerYcbcrConversion", name))
        return (PFN_vkVoidFunction) &wrap_CreateSamplerYcbcrConversion<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSamplerYcbcrConversionKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSamplerYcbcrConversionKHR; };
    if constexpr (HasCreateSamplerYcbcrConversionKHR) {
      if (!std::strcmp("vkCreateSamplerYcbcrConversionKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateSamplerYcbcrConversionKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSemaphore = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSemaphore; };
    if constexpr (HasCreateSemaphore) {
      if (!std::strcmp("vkCreateSemaphore", name))
        return (PFN_vkVoidFunction) &wrap_CreateSemaphore<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateShaderModule = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateShaderModule; };
    if constexpr (HasCreateShaderModule) {
      if (!std::strcmp("vkCreateShaderModule", name))
        return (PFN_vkVoidFunction) &wrap_CreateShaderModule<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateShadersEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateShadersEXT; };
    if constexpr (HasCreateShadersEXT) {
      if (!std::strcmp("vkCreateShadersEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateShadersEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSharedSwapchainsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSharedSwapchainsKHR; };
    if constexpr (HasCreateSharedSwapchainsKHR) {
      if (!std::strcmp("vkCreateSharedSwapchainsKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateSharedSwapchainsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateSwapchainKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateSwapchainKHR; };
    if constexpr (HasCreateSwapchainKHR) {
      if (!std::strcmp("vkCreateSwapchainKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateSwapchainKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateTensorARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateTensorARM; };
    if constexpr (HasCreateTensorARM) {
      if (!std::strcmp("vkCreateTensorARM", name))
        return (PFN_vkVoidFunction) &wrap_CreateTensorARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateTensorViewARM = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateTensorViewARM; };
    if constexpr (HasCreateTensorViewARM) {
      if (!std::strcmp("vkCreateTensorViewARM", name))
        return (PFN_vkVoidFunction) &wrap_CreateTensorViewARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateValidationCacheEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateValidationCacheEXT; };
    if constexpr (HasCreateValidationCacheEXT) {
      if (!std::strcmp("vkCreateValidationCacheEXT", name))
        return (PFN_vkVoidFunction) &wrap_CreateValidationCacheEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateVideoSessionKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateVideoSessionKHR; };
    if constexpr (HasCreateVideoSessionKHR) {
      if (!std::strcmp("vkCreateVideoSessionKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateVideoSessionKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasCreateVideoSessionParametersKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::CreateVideoSessionParametersKHR; };
    if constexpr (HasCreateVideoSessionParametersKHR) {
      if (!std::strcmp("vkCreateVideoSessionParametersKHR", name))
        return (PFN_vkVoidFunction) &wrap_CreateVideoSessionParametersKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDebugMarkerSetObjectNameEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DebugMarkerSetObjectNameEXT; };
    if constexpr (HasDebugMarkerSetObjectNameEXT) {
      if (!std::strcmp("vkDebugMarkerSetObjectNameEXT", name))
        return (PFN_vkVoidFunction) &wrap_DebugMarkerSetObjectNameEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDebugMarkerSetObjectTagEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DebugMarkerSetObjectTagEXT; };
    if constexpr (HasDebugMarkerSetObjectTagEXT) {
      if (!std::strcmp("vkDebugMarkerSetObjectTagEXT", name))
        return (PFN_vkVoidFunction) &wrap_DebugMarkerSetObjectTagEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDeferredOperationJoinKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DeferredOperationJoinKHR; };
    if constexpr (HasDeferredOperationJoinKHR) {
      if (!std::strcmp("vkDeferredOperationJoinKHR", name))
        return (PFN_vkVoidFunction) &wrap_DeferredOperationJoinKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyAccelerationStructureKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyAccelerationStructureKHR; };
    if constexpr (HasDestroyAccelerationStructureKHR) {
      if (!std::strcmp("vkDestroyAccelerationStructureKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyAccelerationStructureKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyAccelerationStructureNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyAccelerationStructureNV; };
    if constexpr (HasDestroyAccelerationStructureNV) {
      if (!std::strcmp("vkDestroyAccelerationStructureNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyAccelerationStructureNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyBuffer; };
    if constexpr (HasDestroyBuffer) {
      if (!std::strcmp("vkDestroyBuffer", name))
        return (PFN_vkVoidFunction) &wrap_DestroyBuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasDestroyBufferCollectionFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyBufferCollectionFUCHSIA; };
    if constexpr (HasDestroyBufferCollectionFUCHSIA) {
      if (!std::strcmp("vkDestroyBufferCollectionFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_DestroyBufferCollectionFUCHSIA<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasDestroyBufferView = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyBufferView; };
    if constexpr (HasDestroyBufferView) {
      if (!std::strcmp("vkDestroyBufferView", name))
        return (PFN_vkVoidFunction) &wrap_DestroyBufferView<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyCommandPool = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyCommandPool; };
    if constexpr (HasDestroyCommandPool) {
      if (!std::strcmp("vkDestroyCommandPool", name))
        return (PFN_vkVoidFunction) &wrap_DestroyCommandPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasDestroyCudaFunctionNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyCudaFunctionNV; };
    if constexpr (HasDestroyCudaFunctionNV) {
      if (!std::strcmp("vkDestroyCudaFunctionNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyCudaFunctionNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasDestroyCudaModuleNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyCudaModuleNV; };
    if constexpr (HasDestroyCudaModuleNV) {
      if (!std::strcmp("vkDestroyCudaModuleNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyCudaModuleNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasDestroyDataGraphPipelineSessionARM = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDataGraphPipelineSessionARM; };
    if constexpr (HasDestroyDataGraphPipelineSessionARM) {
      if (!std::strcmp("vkDestroyDataGraphPipelineSessionARM", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDataGraphPipelineSessionARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDeferredOperationKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDeferredOperationKHR; };
    if constexpr (HasDestroyDeferredOperationKHR) {
      if (!std::strcmp("vkDestroyDeferredOperationKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDeferredOperationKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDescriptorPool = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDescriptorPool; };
    if constexpr (HasDestroyDescriptorPool) {
      if (!std::strcmp("vkDestroyDescriptorPool", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDescriptorPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDescriptorSetLayout = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDescriptorSetLayout; };
    if constexpr (HasDestroyDescriptorSetLayout) {
      if (!std::strcmp("vkDestroyDescriptorSetLayout", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDescriptorSetLayout<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDescriptorUpdateTemplate = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDescriptorUpdateTemplate; };
    if constexpr (HasDestroyDescriptorUpdateTemplate) {
      if (!std::strcmp("vkDestroyDescriptorUpdateTemplate", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDescriptorUpdateTemplate<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDescriptorUpdateTemplateKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDescriptorUpdateTemplateKHR; };
    if constexpr (HasDestroyDescriptorUpdateTemplateKHR) {
      if (!std::strcmp("vkDestroyDescriptorUpdateTemplateKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDescriptorUpdateTemplateKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyDevice = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyDevice; };
    if constexpr (HasDestroyDevice) {
      if (!std::strcmp("vkDestroyDevice", name))
        return (PFN_vkVoidFunction) &wrap_DestroyDevice<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::strcmp("vkDestroyDevice", name))
        return (PFN_vkVoidFunction) &implicit_wrap_DestroyDevice;
    }

    constexpr bool HasDestroyEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyEvent; };
    if constexpr (HasDestroyEvent) {
      if (!std::strcmp("vkDestroyEvent", name))
        return (PFN_vkVoidFunction) &wrap_DestroyEvent<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyExternalComputeQueueNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyExternalComputeQueueNV; };
    if constexpr (HasDestroyExternalComputeQueueNV) {
      if (!std::strcmp("vkDestroyExternalComputeQueueNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyExternalComputeQueueNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyFence = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyFence; };
    if constexpr (HasDestroyFence) {
      if (!std::strcmp("vkDestroyFence", name))
        return (PFN_vkVoidFunction) &wrap_DestroyFence<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyFramebuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyFramebuffer; };
    if constexpr (HasDestroyFramebuffer) {
      if (!std::strcmp("vkDestroyFramebuffer", name))
        return (PFN_vkVoidFunction) &wrap_DestroyFramebuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyImage = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyImage; };
    if constexpr (HasDestroyImage) {
      if (!std::strcmp("vkDestroyImage", name))
        return (PFN_vkVoidFunction) &wrap_DestroyImage<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyImageView = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyImageView; };
    if constexpr (HasDestroyImageView) {
      if (!std::strcmp("vkDestroyImageView", name))
        return (PFN_vkVoidFunction) &wrap_DestroyImageView<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyIndirectCommandsLayoutEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyIndirectCommandsLayoutEXT; };
    if constexpr (HasDestroyIndirectCommandsLayoutEXT) {
      if (!std::strcmp("vkDestroyIndirectCommandsLayoutEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyIndirectCommandsLayoutEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyIndirectCommandsLayoutNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyIndirectCommandsLayoutNV; };
    if constexpr (HasDestroyIndirectCommandsLayoutNV) {
      if (!std::strcmp("vkDestroyIndirectCommandsLayoutNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyIndirectCommandsLayoutNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyIndirectExecutionSetEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyIndirectExecutionSetEXT; };
    if constexpr (HasDestroyIndirectExecutionSetEXT) {
      if (!std::strcmp("vkDestroyIndirectExecutionSetEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyIndirectExecutionSetEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyMicromapEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyMicromapEXT; };
    if constexpr (HasDestroyMicromapEXT) {
      if (!std::strcmp("vkDestroyMicromapEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyMicromapEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyOpticalFlowSessionNV = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyOpticalFlowSessionNV; };
    if constexpr (HasDestroyOpticalFlowSessionNV) {
      if (!std::strcmp("vkDestroyOpticalFlowSessionNV", name))
        return (PFN_vkVoidFunction) &wrap_DestroyOpticalFlowSessionNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPipeline = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPipeline; };
    if constexpr (HasDestroyPipeline) {
      if (!std::strcmp("vkDestroyPipeline", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPipeline<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPipelineBinaryKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPipelineBinaryKHR; };
    if constexpr (HasDestroyPipelineBinaryKHR) {
      if (!std::strcmp("vkDestroyPipelineBinaryKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPipelineBinaryKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPipelineCache = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPipelineCache; };
    if constexpr (HasDestroyPipelineCache) {
      if (!std::strcmp("vkDestroyPipelineCache", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPipelineCache<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPipelineLayout = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPipelineLayout; };
    if constexpr (HasDestroyPipelineLayout) {
      if (!std::strcmp("vkDestroyPipelineLayout", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPipelineLayout<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPrivateDataSlot = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPrivateDataSlot; };
    if constexpr (HasDestroyPrivateDataSlot) {
      if (!std::strcmp("vkDestroyPrivateDataSlot", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPrivateDataSlot<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyPrivateDataSlotEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyPrivateDataSlotEXT; };
    if constexpr (HasDestroyPrivateDataSlotEXT) {
      if (!std::strcmp("vkDestroyPrivateDataSlotEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyPrivateDataSlotEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyQueryPool = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyQueryPool; };
    if constexpr (HasDestroyQueryPool) {
      if (!std::strcmp("vkDestroyQueryPool", name))
        return (PFN_vkVoidFunction) &wrap_DestroyQueryPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyRenderPass = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyRenderPass; };
    if constexpr (HasDestroyRenderPass) {
      if (!std::strcmp("vkDestroyRenderPass", name))
        return (PFN_vkVoidFunction) &wrap_DestroyRenderPass<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroySampler = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroySampler; };
    if constexpr (HasDestroySampler) {
      if (!std::strcmp("vkDestroySampler", name))
        return (PFN_vkVoidFunction) &wrap_DestroySampler<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroySamplerYcbcrConversion = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroySamplerYcbcrConversion; };
    if constexpr (HasDestroySamplerYcbcrConversion) {
      if (!std::strcmp("vkDestroySamplerYcbcrConversion", name))
        return (PFN_vkVoidFunction) &wrap_DestroySamplerYcbcrConversion<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroySamplerYcbcrConversionKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroySamplerYcbcrConversionKHR; };
    if constexpr (HasDestroySamplerYcbcrConversionKHR) {
      if (!std::strcmp("vkDestroySamplerYcbcrConversionKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroySamplerYcbcrConversionKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroySemaphore = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroySemaphore; };
    if constexpr (HasDestroySemaphore) {
      if (!std::strcmp("vkDestroySemaphore", name))
        return (PFN_vkVoidFunction) &wrap_DestroySemaphore<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyShaderEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyShaderEXT; };
    if constexpr (HasDestroyShaderEXT) {
      if (!std::strcmp("vkDestroyShaderEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyShaderEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyShaderModule = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyShaderModule; };
    if constexpr (HasDestroyShaderModule) {
      if (!std::strcmp("vkDestroyShaderModule", name))
        return (PFN_vkVoidFunction) &wrap_DestroyShaderModule<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroySwapchainKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroySwapchainKHR; };
    if constexpr (HasDestroySwapchainKHR) {
      if (!std::strcmp("vkDestroySwapchainKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroySwapchainKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyTensorARM = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyTensorARM; };
    if constexpr (HasDestroyTensorARM) {
      if (!std::strcmp("vkDestroyTensorARM", name))
        return (PFN_vkVoidFunction) &wrap_DestroyTensorARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyTensorViewARM = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyTensorViewARM; };
    if constexpr (HasDestroyTensorViewARM) {
      if (!std::strcmp("vkDestroyTensorViewARM", name))
        return (PFN_vkVoidFunction) &wrap_DestroyTensorViewARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyValidationCacheEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyValidationCacheEXT; };
    if constexpr (HasDestroyValidationCacheEXT) {
      if (!std::strcmp("vkDestroyValidationCacheEXT", name))
        return (PFN_vkVoidFunction) &wrap_DestroyValidationCacheEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyVideoSessionKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyVideoSessionKHR; };
    if constexpr (HasDestroyVideoSessionKHR) {
      if (!std::strcmp("vkDestroyVideoSessionKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyVideoSessionKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDestroyVideoSessionParametersKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::DestroyVideoSessionParametersKHR; };
    if constexpr (HasDestroyVideoSessionParametersKHR) {
      if (!std::strcmp("vkDestroyVideoSessionParametersKHR", name))
        return (PFN_vkVoidFunction) &wrap_DestroyVideoSessionParametersKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDeviceWaitIdle = requires(const DeviceOverrides& t) { &DeviceOverrides::DeviceWaitIdle; };
    if constexpr (HasDeviceWaitIdle) {
      if (!std::strcmp("vkDeviceWaitIdle", name))
        return (PFN_vkVoidFunction) &wrap_DeviceWaitIdle<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasDisplayPowerControlEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::DisplayPowerControlEXT; };
    if constexpr (HasDisplayPowerControlEXT) {
      if (!std::strcmp("vkDisplayPowerControlEXT", name))
        return (PFN_vkVoidFunction) &wrap_DisplayPowerControlEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasEndCommandBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::EndCommandBuffer; };
    if constexpr (HasEndCommandBuffer) {
      if (!std::strcmp("vkEndCommandBuffer", name))
        return (PFN_vkVoidFunction) &wrap_EndCommandBuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_METAL_EXT
    constexpr bool HasExportMetalObjectsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::ExportMetalObjectsEXT; };
    if constexpr (HasExportMetalObjectsEXT) {
      if (!std::strcmp("vkExportMetalObjectsEXT", name))
        return (PFN_vkVoidFunction) &wrap_ExportMetalObjectsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasFlushMappedMemoryRanges = requires(const DeviceOverrides& t) { &DeviceOverrides::FlushMappedMemoryRanges; };
    if constexpr (HasFlushMappedMemoryRanges) {
      if (!std::strcmp("vkFlushMappedMemoryRanges", name))
        return (PFN_vkVoidFunction) &wrap_FlushMappedMemoryRanges<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasFreeCommandBuffers = requires(const DeviceOverrides& t) { &DeviceOverrides::FreeCommandBuffers; };
    if constexpr (HasFreeCommandBuffers) {
      if (!std::strcmp("vkFreeCommandBuffers", name))
        return (PFN_vkVoidFunction) &wrap_FreeCommandBuffers<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
    else {
      if (!std::is_base_of<NoOverrides, DeviceOverrides>::value && !std::strcmp("vkFreeCommandBuffers", name))
        return (PFN_vkVoidFunction) &implicit_wrap_FreeCommandBuffers;
    }

    constexpr bool HasFreeDescriptorSets = requires(const DeviceOverrides& t) { &DeviceOverrides::FreeDescriptorSets; };
    if constexpr (HasFreeDescriptorSets) {
      if (!std::strcmp("vkFreeDescriptorSets", name))
        return (PFN_vkVoidFunction) &wrap_FreeDescriptorSets<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasFreeMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::FreeMemory; };
    if constexpr (HasFreeMemory) {
      if (!std::strcmp("vkFreeMemory", name))
        return (PFN_vkVoidFunction) &wrap_FreeMemory<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetAccelerationStructureBuildSizesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAccelerationStructureBuildSizesKHR; };
    if constexpr (HasGetAccelerationStructureBuildSizesKHR) {
      if (!std::strcmp("vkGetAccelerationStructureBuildSizesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetAccelerationStructureBuildSizesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetAccelerationStructureDeviceAddressKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAccelerationStructureDeviceAddressKHR; };
    if constexpr (HasGetAccelerationStructureDeviceAddressKHR) {
      if (!std::strcmp("vkGetAccelerationStructureDeviceAddressKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetAccelerationStructureDeviceAddressKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetAccelerationStructureHandleNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAccelerationStructureHandleNV; };
    if constexpr (HasGetAccelerationStructureHandleNV) {
      if (!std::strcmp("vkGetAccelerationStructureHandleNV", name))
        return (PFN_vkVoidFunction) &wrap_GetAccelerationStructureHandleNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetAccelerationStructureMemoryRequirementsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAccelerationStructureMemoryRequirementsNV; };
    if constexpr (HasGetAccelerationStructureMemoryRequirementsNV) {
      if (!std::strcmp("vkGetAccelerationStructureMemoryRequirementsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetAccelerationStructureMemoryRequirementsNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetAccelerationStructureOpaqueCaptureDescriptorDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAccelerationStructureOpaqueCaptureDescriptorDataEXT; };
    if constexpr (HasGetAccelerationStructureOpaqueCaptureDescriptorDataEXT) {
      if (!std::strcmp("vkGetAccelerationStructureOpaqueCaptureDescriptorDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetAccelerationStructureOpaqueCaptureDescriptorDataEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    constexpr bool HasGetAndroidHardwareBufferPropertiesANDROID = requires(const DeviceOverrides& t) { &DeviceOverrides::GetAndroidHardwareBufferPropertiesANDROID; };
    if constexpr (HasGetAndroidHardwareBufferPropertiesANDROID) {
      if (!std::strcmp("vkGetAndroidHardwareBufferPropertiesANDROID", name))
        return (PFN_vkVoidFunction) &wrap_GetAndroidHardwareBufferPropertiesANDROID<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasGetBufferCollectionPropertiesFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferCollectionPropertiesFUCHSIA; };
    if constexpr (HasGetBufferCollectionPropertiesFUCHSIA) {
      if (!std::strcmp("vkGetBufferCollectionPropertiesFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferCollectionPropertiesFUCHSIA<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetBufferDeviceAddress = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferDeviceAddress; };
    if constexpr (HasGetBufferDeviceAddress) {
      if (!std::strcmp("vkGetBufferDeviceAddress", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferDeviceAddress<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferDeviceAddressEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferDeviceAddressEXT; };
    if constexpr (HasGetBufferDeviceAddressEXT) {
      if (!std::strcmp("vkGetBufferDeviceAddressEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferDeviceAddressEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferDeviceAddressKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferDeviceAddressKHR; };
    if constexpr (HasGetBufferDeviceAddressKHR) {
      if (!std::strcmp("vkGetBufferDeviceAddressKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferDeviceAddressKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferMemoryRequirements; };
    if constexpr (HasGetBufferMemoryRequirements) {
      if (!std::strcmp("vkGetBufferMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferMemoryRequirements<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferMemoryRequirements2 = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferMemoryRequirements2; };
    if constexpr (HasGetBufferMemoryRequirements2) {
      if (!std::strcmp("vkGetBufferMemoryRequirements2", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferMemoryRequirements2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferMemoryRequirements2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferMemoryRequirements2KHR; };
    if constexpr (HasGetBufferMemoryRequirements2KHR) {
      if (!std::strcmp("vkGetBufferMemoryRequirements2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferMemoryRequirements2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferOpaqueCaptureAddress = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferOpaqueCaptureAddress; };
    if constexpr (HasGetBufferOpaqueCaptureAddress) {
      if (!std::strcmp("vkGetBufferOpaqueCaptureAddress", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferOpaqueCaptureAddress<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferOpaqueCaptureAddressKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferOpaqueCaptureAddressKHR; };
    if constexpr (HasGetBufferOpaqueCaptureAddressKHR) {
      if (!std::strcmp("vkGetBufferOpaqueCaptureAddressKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferOpaqueCaptureAddressKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetBufferOpaqueCaptureDescriptorDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetBufferOpaqueCaptureDescriptorDataEXT; };
    if constexpr (HasGetBufferOpaqueCaptureDescriptorDataEXT) {
      if (!std::strcmp("vkGetBufferOpaqueCaptureDescriptorDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetBufferOpaqueCaptureDescriptorDataEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetCalibratedTimestampsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetCalibratedTimestampsEXT; };
    if constexpr (HasGetCalibratedTimestampsEXT) {
      if (!std::strcmp("vkGetCalibratedTimestampsEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetCalibratedTimestampsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetCalibratedTimestampsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetCalibratedTimestampsKHR; };
    if constexpr (HasGetCalibratedTimestampsKHR) {
      if (!std::strcmp("vkGetCalibratedTimestampsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetCalibratedTimestampsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetClusterAccelerationStructureBuildSizesNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetClusterAccelerationStructureBuildSizesNV; };
    if constexpr (HasGetClusterAccelerationStructureBuildSizesNV) {
      if (!std::strcmp("vkGetClusterAccelerationStructureBuildSizesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetClusterAccelerationStructureBuildSizesNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasGetCudaModuleCacheNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetCudaModuleCacheNV; };
    if constexpr (HasGetCudaModuleCacheNV) {
      if (!std::strcmp("vkGetCudaModuleCacheNV", name))
        return (PFN_vkVoidFunction) &wrap_GetCudaModuleCacheNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetDataGraphPipelineAvailablePropertiesARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDataGraphPipelineAvailablePropertiesARM; };
    if constexpr (HasGetDataGraphPipelineAvailablePropertiesARM) {
      if (!std::strcmp("vkGetDataGraphPipelineAvailablePropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetDataGraphPipelineAvailablePropertiesARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDataGraphPipelinePropertiesARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDataGraphPipelinePropertiesARM; };
    if constexpr (HasGetDataGraphPipelinePropertiesARM) {
      if (!std::strcmp("vkGetDataGraphPipelinePropertiesARM", name))
        return (PFN_vkVoidFunction) &wrap_GetDataGraphPipelinePropertiesARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDataGraphPipelineSessionBindPointRequirementsARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDataGraphPipelineSessionBindPointRequirementsARM; };
    if constexpr (HasGetDataGraphPipelineSessionBindPointRequirementsARM) {
      if (!std::strcmp("vkGetDataGraphPipelineSessionBindPointRequirementsARM", name))
        return (PFN_vkVoidFunction) &wrap_GetDataGraphPipelineSessionBindPointRequirementsARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDataGraphPipelineSessionMemoryRequirementsARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDataGraphPipelineSessionMemoryRequirementsARM; };
    if constexpr (HasGetDataGraphPipelineSessionMemoryRequirementsARM) {
      if (!std::strcmp("vkGetDataGraphPipelineSessionMemoryRequirementsARM", name))
        return (PFN_vkVoidFunction) &wrap_GetDataGraphPipelineSessionMemoryRequirementsARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeferredOperationMaxConcurrencyKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeferredOperationMaxConcurrencyKHR; };
    if constexpr (HasGetDeferredOperationMaxConcurrencyKHR) {
      if (!std::strcmp("vkGetDeferredOperationMaxConcurrencyKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeferredOperationMaxConcurrencyKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeferredOperationResultKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeferredOperationResultKHR; };
    if constexpr (HasGetDeferredOperationResultKHR) {
      if (!std::strcmp("vkGetDeferredOperationResultKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeferredOperationResultKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorEXT; };
    if constexpr (HasGetDescriptorEXT) {
      if (!std::strcmp("vkGetDescriptorEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetHostMappingVALVE = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetHostMappingVALVE; };
    if constexpr (HasGetDescriptorSetHostMappingVALVE) {
      if (!std::strcmp("vkGetDescriptorSetHostMappingVALVE", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetHostMappingVALVE<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetLayoutBindingOffsetEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetLayoutBindingOffsetEXT; };
    if constexpr (HasGetDescriptorSetLayoutBindingOffsetEXT) {
      if (!std::strcmp("vkGetDescriptorSetLayoutBindingOffsetEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetLayoutBindingOffsetEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetLayoutHostMappingInfoVALVE = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetLayoutHostMappingInfoVALVE; };
    if constexpr (HasGetDescriptorSetLayoutHostMappingInfoVALVE) {
      if (!std::strcmp("vkGetDescriptorSetLayoutHostMappingInfoVALVE", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetLayoutHostMappingInfoVALVE<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetLayoutSizeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetLayoutSizeEXT; };
    if constexpr (HasGetDescriptorSetLayoutSizeEXT) {
      if (!std::strcmp("vkGetDescriptorSetLayoutSizeEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetLayoutSizeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetLayoutSupport = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetLayoutSupport; };
    if constexpr (HasGetDescriptorSetLayoutSupport) {
      if (!std::strcmp("vkGetDescriptorSetLayoutSupport", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetLayoutSupport<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDescriptorSetLayoutSupportKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDescriptorSetLayoutSupportKHR; };
    if constexpr (HasGetDescriptorSetLayoutSupportKHR) {
      if (!std::strcmp("vkGetDescriptorSetLayoutSupportKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDescriptorSetLayoutSupportKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceAccelerationStructureCompatibilityKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceAccelerationStructureCompatibilityKHR; };
    if constexpr (HasGetDeviceAccelerationStructureCompatibilityKHR) {
      if (!std::strcmp("vkGetDeviceAccelerationStructureCompatibilityKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceAccelerationStructureCompatibilityKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceBufferMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceBufferMemoryRequirements; };
    if constexpr (HasGetDeviceBufferMemoryRequirements) {
      if (!std::strcmp("vkGetDeviceBufferMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceBufferMemoryRequirements<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceBufferMemoryRequirementsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceBufferMemoryRequirementsKHR; };
    if constexpr (HasGetDeviceBufferMemoryRequirementsKHR) {
      if (!std::strcmp("vkGetDeviceBufferMemoryRequirementsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceBufferMemoryRequirementsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceFaultInfoEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceFaultInfoEXT; };
    if constexpr (HasGetDeviceFaultInfoEXT) {
      if (!std::strcmp("vkGetDeviceFaultInfoEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceFaultInfoEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceGroupPeerMemoryFeatures = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceGroupPeerMemoryFeatures; };
    if constexpr (HasGetDeviceGroupPeerMemoryFeatures) {
      if (!std::strcmp("vkGetDeviceGroupPeerMemoryFeatures", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceGroupPeerMemoryFeatures<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceGroupPeerMemoryFeaturesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceGroupPeerMemoryFeaturesKHR; };
    if constexpr (HasGetDeviceGroupPeerMemoryFeaturesKHR) {
      if (!std::strcmp("vkGetDeviceGroupPeerMemoryFeaturesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceGroupPeerMemoryFeaturesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceGroupPresentCapabilitiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceGroupPresentCapabilitiesKHR; };
    if constexpr (HasGetDeviceGroupPresentCapabilitiesKHR) {
      if (!std::strcmp("vkGetDeviceGroupPresentCapabilitiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceGroupPresentCapabilitiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetDeviceGroupSurfacePresentModes2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceGroupSurfacePresentModes2EXT; };
    if constexpr (HasGetDeviceGroupSurfacePresentModes2EXT) {
      if (!std::strcmp("vkGetDeviceGroupSurfacePresentModes2EXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceGroupSurfacePresentModes2EXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetDeviceGroupSurfacePresentModesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceGroupSurfacePresentModesKHR; };
    if constexpr (HasGetDeviceGroupSurfacePresentModesKHR) {
      if (!std::strcmp("vkGetDeviceGroupSurfacePresentModesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceGroupSurfacePresentModesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceImageMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceImageMemoryRequirements; };
    if constexpr (HasGetDeviceImageMemoryRequirements) {
      if (!std::strcmp("vkGetDeviceImageMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceImageMemoryRequirements<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceImageMemoryRequirementsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceImageMemoryRequirementsKHR; };
    if constexpr (HasGetDeviceImageMemoryRequirementsKHR) {
      if (!std::strcmp("vkGetDeviceImageMemoryRequirementsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceImageMemoryRequirementsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceImageSparseMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceImageSparseMemoryRequirements; };
    if constexpr (HasGetDeviceImageSparseMemoryRequirements) {
      if (!std::strcmp("vkGetDeviceImageSparseMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceImageSparseMemoryRequirements<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceImageSparseMemoryRequirementsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceImageSparseMemoryRequirementsKHR; };
    if constexpr (HasGetDeviceImageSparseMemoryRequirementsKHR) {
      if (!std::strcmp("vkGetDeviceImageSparseMemoryRequirementsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceImageSparseMemoryRequirementsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceImageSubresourceLayoutKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceImageSubresourceLayoutKHR; };
    if constexpr (HasGetDeviceImageSubresourceLayoutKHR) {
      if (!std::strcmp("vkGetDeviceImageSubresourceLayoutKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceImageSubresourceLayoutKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceMemoryCommitment = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceMemoryCommitment; };
    if constexpr (HasGetDeviceMemoryCommitment) {
      if (!std::strcmp("vkGetDeviceMemoryCommitment", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceMemoryCommitment<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceMemoryOpaqueCaptureAddress = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceMemoryOpaqueCaptureAddress; };
    if constexpr (HasGetDeviceMemoryOpaqueCaptureAddress) {
      if (!std::strcmp("vkGetDeviceMemoryOpaqueCaptureAddress", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceMemoryOpaqueCaptureAddress<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceMemoryOpaqueCaptureAddressKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceMemoryOpaqueCaptureAddressKHR; };
    if constexpr (HasGetDeviceMemoryOpaqueCaptureAddressKHR) {
      if (!std::strcmp("vkGetDeviceMemoryOpaqueCaptureAddressKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceMemoryOpaqueCaptureAddressKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceMicromapCompatibilityEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceMicromapCompatibilityEXT; };
    if constexpr (HasGetDeviceMicromapCompatibilityEXT) {
      if (!std::strcmp("vkGetDeviceMicromapCompatibilityEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceMicromapCompatibilityEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    if (!std::strcmp("vkGetDeviceProcAddr", name))
      return (PFN_vkVoidFunction) &GetDeviceProcAddr<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;

    constexpr bool HasGetDeviceQueue = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceQueue; };
    if constexpr (HasGetDeviceQueue) {
      if (!std::strcmp("vkGetDeviceQueue", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceQueue<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceQueue2 = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceQueue2; };
    if constexpr (HasGetDeviceQueue2) {
      if (!std::strcmp("vkGetDeviceQueue2", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceQueue2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI; };
    if constexpr (HasGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI) {
      if (!std::strcmp("vkGetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceSubpassShadingMaxWorkgroupSizeHUAWEI<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDeviceTensorMemoryRequirementsARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDeviceTensorMemoryRequirementsARM; };
    if constexpr (HasGetDeviceTensorMemoryRequirementsARM) {
      if (!std::strcmp("vkGetDeviceTensorMemoryRequirementsARM", name))
        return (PFN_vkVoidFunction) &wrap_GetDeviceTensorMemoryRequirementsARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetDynamicRenderingTilePropertiesQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetDynamicRenderingTilePropertiesQCOM; };
    if constexpr (HasGetDynamicRenderingTilePropertiesQCOM) {
      if (!std::strcmp("vkGetDynamicRenderingTilePropertiesQCOM", name))
        return (PFN_vkVoidFunction) &wrap_GetDynamicRenderingTilePropertiesQCOM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetEncodedVideoSessionParametersKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetEncodedVideoSessionParametersKHR; };
    if constexpr (HasGetEncodedVideoSessionParametersKHR) {
      if (!std::strcmp("vkGetEncodedVideoSessionParametersKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetEncodedVideoSessionParametersKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetEventStatus = requires(const DeviceOverrides& t) { &DeviceOverrides::GetEventStatus; };
    if constexpr (HasGetEventStatus) {
      if (!std::strcmp("vkGetEventStatus", name))
        return (PFN_vkVoidFunction) &wrap_GetEventStatus<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasGetExecutionGraphPipelineNodeIndexAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::GetExecutionGraphPipelineNodeIndexAMDX; };
    if constexpr (HasGetExecutionGraphPipelineNodeIndexAMDX) {
      if (!std::strcmp("vkGetExecutionGraphPipelineNodeIndexAMDX", name))
        return (PFN_vkVoidFunction) &wrap_GetExecutionGraphPipelineNodeIndexAMDX<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
    constexpr bool HasGetExecutionGraphPipelineScratchSizeAMDX = requires(const DeviceOverrides& t) { &DeviceOverrides::GetExecutionGraphPipelineScratchSizeAMDX; };
    if constexpr (HasGetExecutionGraphPipelineScratchSizeAMDX) {
      if (!std::strcmp("vkGetExecutionGraphPipelineScratchSizeAMDX", name))
        return (PFN_vkVoidFunction) &wrap_GetExecutionGraphPipelineScratchSizeAMDX<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetExternalComputeQueueDataNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetExternalComputeQueueDataNV; };
    if constexpr (HasGetExternalComputeQueueDataNV) {
      if (!std::strcmp("vkGetExternalComputeQueueDataNV", name))
        return (PFN_vkVoidFunction) &wrap_GetExternalComputeQueueDataNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetFenceFdKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetFenceFdKHR; };
    if constexpr (HasGetFenceFdKHR) {
      if (!std::strcmp("vkGetFenceFdKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetFenceFdKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetFenceStatus = requires(const DeviceOverrides& t) { &DeviceOverrides::GetFenceStatus; };
    if constexpr (HasGetFenceStatus) {
      if (!std::strcmp("vkGetFenceStatus", name))
        return (PFN_vkVoidFunction) &wrap_GetFenceStatus<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetFenceWin32HandleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetFenceWin32HandleKHR; };
    if constexpr (HasGetFenceWin32HandleKHR) {
      if (!std::strcmp("vkGetFenceWin32HandleKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetFenceWin32HandleKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetFramebufferTilePropertiesQCOM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetFramebufferTilePropertiesQCOM; };
    if constexpr (HasGetFramebufferTilePropertiesQCOM) {
      if (!std::strcmp("vkGetFramebufferTilePropertiesQCOM", name))
        return (PFN_vkVoidFunction) &wrap_GetFramebufferTilePropertiesQCOM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetGeneratedCommandsMemoryRequirementsEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetGeneratedCommandsMemoryRequirementsEXT; };
    if constexpr (HasGetGeneratedCommandsMemoryRequirementsEXT) {
      if (!std::strcmp("vkGetGeneratedCommandsMemoryRequirementsEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetGeneratedCommandsMemoryRequirementsEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetGeneratedCommandsMemoryRequirementsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetGeneratedCommandsMemoryRequirementsNV; };
    if constexpr (HasGetGeneratedCommandsMemoryRequirementsNV) {
      if (!std::strcmp("vkGetGeneratedCommandsMemoryRequirementsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetGeneratedCommandsMemoryRequirementsNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageDrmFormatModifierPropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageDrmFormatModifierPropertiesEXT; };
    if constexpr (HasGetImageDrmFormatModifierPropertiesEXT) {
      if (!std::strcmp("vkGetImageDrmFormatModifierPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetImageDrmFormatModifierPropertiesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageMemoryRequirements; };
    if constexpr (HasGetImageMemoryRequirements) {
      if (!std::strcmp("vkGetImageMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetImageMemoryRequirements<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageMemoryRequirements2 = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageMemoryRequirements2; };
    if constexpr (HasGetImageMemoryRequirements2) {
      if (!std::strcmp("vkGetImageMemoryRequirements2", name))
        return (PFN_vkVoidFunction) &wrap_GetImageMemoryRequirements2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageMemoryRequirements2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageMemoryRequirements2KHR; };
    if constexpr (HasGetImageMemoryRequirements2KHR) {
      if (!std::strcmp("vkGetImageMemoryRequirements2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetImageMemoryRequirements2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageOpaqueCaptureDescriptorDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageOpaqueCaptureDescriptorDataEXT; };
    if constexpr (HasGetImageOpaqueCaptureDescriptorDataEXT) {
      if (!std::strcmp("vkGetImageOpaqueCaptureDescriptorDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetImageOpaqueCaptureDescriptorDataEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSparseMemoryRequirements = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSparseMemoryRequirements; };
    if constexpr (HasGetImageSparseMemoryRequirements) {
      if (!std::strcmp("vkGetImageSparseMemoryRequirements", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSparseMemoryRequirements<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSparseMemoryRequirements2 = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSparseMemoryRequirements2; };
    if constexpr (HasGetImageSparseMemoryRequirements2) {
      if (!std::strcmp("vkGetImageSparseMemoryRequirements2", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSparseMemoryRequirements2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSparseMemoryRequirements2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSparseMemoryRequirements2KHR; };
    if constexpr (HasGetImageSparseMemoryRequirements2KHR) {
      if (!std::strcmp("vkGetImageSparseMemoryRequirements2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSparseMemoryRequirements2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSubresourceLayout = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSubresourceLayout; };
    if constexpr (HasGetImageSubresourceLayout) {
      if (!std::strcmp("vkGetImageSubresourceLayout", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSubresourceLayout<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSubresourceLayout2EXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSubresourceLayout2EXT; };
    if constexpr (HasGetImageSubresourceLayout2EXT) {
      if (!std::strcmp("vkGetImageSubresourceLayout2EXT", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSubresourceLayout2EXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageSubresourceLayout2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageSubresourceLayout2KHR; };
    if constexpr (HasGetImageSubresourceLayout2KHR) {
      if (!std::strcmp("vkGetImageSubresourceLayout2KHR", name))
        return (PFN_vkVoidFunction) &wrap_GetImageSubresourceLayout2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetImageViewOpaqueCaptureDescriptorDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetImageViewOpaqueCaptureDescriptorDataEXT; };
    if constexpr (HasGetImageViewOpaqueCaptureDescriptorDataEXT) {
      if (!std::strcmp("vkGetImageViewOpaqueCaptureDescriptorDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetImageViewOpaqueCaptureDescriptorDataEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetLatencyTimingsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetLatencyTimingsNV; };
    if constexpr (HasGetLatencyTimingsNV) {
      if (!std::strcmp("vkGetLatencyTimingsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetLatencyTimingsNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
    constexpr bool HasGetMemoryAndroidHardwareBufferANDROID = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryAndroidHardwareBufferANDROID; };
    if constexpr (HasGetMemoryAndroidHardwareBufferANDROID) {
      if (!std::strcmp("vkGetMemoryAndroidHardwareBufferANDROID", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryAndroidHardwareBufferANDROID<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetMemoryFdKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryFdKHR; };
    if constexpr (HasGetMemoryFdKHR) {
      if (!std::strcmp("vkGetMemoryFdKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryFdKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetMemoryFdPropertiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryFdPropertiesKHR; };
    if constexpr (HasGetMemoryFdPropertiesKHR) {
      if (!std::strcmp("vkGetMemoryFdPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryFdPropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetMemoryHostPointerPropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryHostPointerPropertiesEXT; };
    if constexpr (HasGetMemoryHostPointerPropertiesEXT) {
      if (!std::strcmp("vkGetMemoryHostPointerPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryHostPointerPropertiesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_METAL_EXT
    constexpr bool HasGetMemoryMetalHandleEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryMetalHandleEXT; };
    if constexpr (HasGetMemoryMetalHandleEXT) {
      if (!std::strcmp("vkGetMemoryMetalHandleEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryMetalHandleEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
    constexpr bool HasGetMemoryMetalHandlePropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryMetalHandlePropertiesEXT; };
    if constexpr (HasGetMemoryMetalHandlePropertiesEXT) {
      if (!std::strcmp("vkGetMemoryMetalHandlePropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryMetalHandlePropertiesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetMemoryRemoteAddressNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryRemoteAddressNV; };
    if constexpr (HasGetMemoryRemoteAddressNV) {
      if (!std::strcmp("vkGetMemoryRemoteAddressNV", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryRemoteAddressNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetMemoryWin32HandleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryWin32HandleKHR; };
    if constexpr (HasGetMemoryWin32HandleKHR) {
      if (!std::strcmp("vkGetMemoryWin32HandleKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryWin32HandleKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetMemoryWin32HandleNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryWin32HandleNV; };
    if constexpr (HasGetMemoryWin32HandleNV) {
      if (!std::strcmp("vkGetMemoryWin32HandleNV", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryWin32HandleNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetMemoryWin32HandlePropertiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryWin32HandlePropertiesKHR; };
    if constexpr (HasGetMemoryWin32HandlePropertiesKHR) {
      if (!std::strcmp("vkGetMemoryWin32HandlePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryWin32HandlePropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasGetMemoryZirconHandleFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryZirconHandleFUCHSIA; };
    if constexpr (HasGetMemoryZirconHandleFUCHSIA) {
      if (!std::strcmp("vkGetMemoryZirconHandleFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryZirconHandleFUCHSIA<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasGetMemoryZirconHandlePropertiesFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMemoryZirconHandlePropertiesFUCHSIA; };
    if constexpr (HasGetMemoryZirconHandlePropertiesFUCHSIA) {
      if (!std::strcmp("vkGetMemoryZirconHandlePropertiesFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_GetMemoryZirconHandlePropertiesFUCHSIA<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetMicromapBuildSizesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetMicromapBuildSizesEXT; };
    if constexpr (HasGetMicromapBuildSizesEXT) {
      if (!std::strcmp("vkGetMicromapBuildSizesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetMicromapBuildSizesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPartitionedAccelerationStructuresBuildSizesNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPartitionedAccelerationStructuresBuildSizesNV; };
    if constexpr (HasGetPartitionedAccelerationStructuresBuildSizesNV) {
      if (!std::strcmp("vkGetPartitionedAccelerationStructuresBuildSizesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPartitionedAccelerationStructuresBuildSizesNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPastPresentationTimingGOOGLE = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPastPresentationTimingGOOGLE; };
    if constexpr (HasGetPastPresentationTimingGOOGLE) {
      if (!std::strcmp("vkGetPastPresentationTimingGOOGLE", name))
        return (PFN_vkVoidFunction) &wrap_GetPastPresentationTimingGOOGLE<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPerformanceParameterINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPerformanceParameterINTEL; };
    if constexpr (HasGetPerformanceParameterINTEL) {
      if (!std::strcmp("vkGetPerformanceParameterINTEL", name))
        return (PFN_vkVoidFunction) &wrap_GetPerformanceParameterINTEL<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineBinaryDataKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineBinaryDataKHR; };
    if constexpr (HasGetPipelineBinaryDataKHR) {
      if (!std::strcmp("vkGetPipelineBinaryDataKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineBinaryDataKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineCacheData = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineCacheData; };
    if constexpr (HasGetPipelineCacheData) {
      if (!std::strcmp("vkGetPipelineCacheData", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineCacheData<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineExecutableInternalRepresentationsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineExecutableInternalRepresentationsKHR; };
    if constexpr (HasGetPipelineExecutableInternalRepresentationsKHR) {
      if (!std::strcmp("vkGetPipelineExecutableInternalRepresentationsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineExecutableInternalRepresentationsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineExecutablePropertiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineExecutablePropertiesKHR; };
    if constexpr (HasGetPipelineExecutablePropertiesKHR) {
      if (!std::strcmp("vkGetPipelineExecutablePropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineExecutablePropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineExecutableStatisticsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineExecutableStatisticsKHR; };
    if constexpr (HasGetPipelineExecutableStatisticsKHR) {
      if (!std::strcmp("vkGetPipelineExecutableStatisticsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineExecutableStatisticsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineIndirectDeviceAddressNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineIndirectDeviceAddressNV; };
    if constexpr (HasGetPipelineIndirectDeviceAddressNV) {
      if (!std::strcmp("vkGetPipelineIndirectDeviceAddressNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineIndirectDeviceAddressNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineIndirectMemoryRequirementsNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineIndirectMemoryRequirementsNV; };
    if constexpr (HasGetPipelineIndirectMemoryRequirementsNV) {
      if (!std::strcmp("vkGetPipelineIndirectMemoryRequirementsNV", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineIndirectMemoryRequirementsNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelineKeyKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelineKeyKHR; };
    if constexpr (HasGetPipelineKeyKHR) {
      if (!std::strcmp("vkGetPipelineKeyKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelineKeyKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPipelinePropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPipelinePropertiesEXT; };
    if constexpr (HasGetPipelinePropertiesEXT) {
      if (!std::strcmp("vkGetPipelinePropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPipelinePropertiesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPrivateData = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPrivateData; };
    if constexpr (HasGetPrivateData) {
      if (!std::strcmp("vkGetPrivateData", name))
        return (PFN_vkVoidFunction) &wrap_GetPrivateData<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetPrivateDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetPrivateDataEXT; };
    if constexpr (HasGetPrivateDataEXT) {
      if (!std::strcmp("vkGetPrivateDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetPrivateDataEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetQueryPoolResults = requires(const DeviceOverrides& t) { &DeviceOverrides::GetQueryPoolResults; };
    if constexpr (HasGetQueryPoolResults) {
      if (!std::strcmp("vkGetQueryPoolResults", name))
        return (PFN_vkVoidFunction) &wrap_GetQueryPoolResults<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetQueueCheckpointData2NV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetQueueCheckpointData2NV; };
    if constexpr (HasGetQueueCheckpointData2NV) {
      if (!std::strcmp("vkGetQueueCheckpointData2NV", name))
        return (PFN_vkVoidFunction) &wrap_GetQueueCheckpointData2NV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetQueueCheckpointDataNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetQueueCheckpointDataNV; };
    if constexpr (HasGetQueueCheckpointDataNV) {
      if (!std::strcmp("vkGetQueueCheckpointDataNV", name))
        return (PFN_vkVoidFunction) &wrap_GetQueueCheckpointDataNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRayTracingCaptureReplayShaderGroupHandlesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRayTracingCaptureReplayShaderGroupHandlesKHR; };
    if constexpr (HasGetRayTracingCaptureReplayShaderGroupHandlesKHR) {
      if (!std::strcmp("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetRayTracingCaptureReplayShaderGroupHandlesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRayTracingShaderGroupHandlesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRayTracingShaderGroupHandlesKHR; };
    if constexpr (HasGetRayTracingShaderGroupHandlesKHR) {
      if (!std::strcmp("vkGetRayTracingShaderGroupHandlesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetRayTracingShaderGroupHandlesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRayTracingShaderGroupHandlesNV = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRayTracingShaderGroupHandlesNV; };
    if constexpr (HasGetRayTracingShaderGroupHandlesNV) {
      if (!std::strcmp("vkGetRayTracingShaderGroupHandlesNV", name))
        return (PFN_vkVoidFunction) &wrap_GetRayTracingShaderGroupHandlesNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRayTracingShaderGroupStackSizeKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRayTracingShaderGroupStackSizeKHR; };
    if constexpr (HasGetRayTracingShaderGroupStackSizeKHR) {
      if (!std::strcmp("vkGetRayTracingShaderGroupStackSizeKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetRayTracingShaderGroupStackSizeKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRefreshCycleDurationGOOGLE = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRefreshCycleDurationGOOGLE; };
    if constexpr (HasGetRefreshCycleDurationGOOGLE) {
      if (!std::strcmp("vkGetRefreshCycleDurationGOOGLE", name))
        return (PFN_vkVoidFunction) &wrap_GetRefreshCycleDurationGOOGLE<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRenderAreaGranularity = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRenderAreaGranularity; };
    if constexpr (HasGetRenderAreaGranularity) {
      if (!std::strcmp("vkGetRenderAreaGranularity", name))
        return (PFN_vkVoidFunction) &wrap_GetRenderAreaGranularity<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetRenderingAreaGranularityKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetRenderingAreaGranularityKHR; };
    if constexpr (HasGetRenderingAreaGranularityKHR) {
      if (!std::strcmp("vkGetRenderingAreaGranularityKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetRenderingAreaGranularityKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSamplerOpaqueCaptureDescriptorDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSamplerOpaqueCaptureDescriptorDataEXT; };
    if constexpr (HasGetSamplerOpaqueCaptureDescriptorDataEXT) {
      if (!std::strcmp("vkGetSamplerOpaqueCaptureDescriptorDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetSamplerOpaqueCaptureDescriptorDataEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
    constexpr bool HasGetScreenBufferPropertiesQNX = requires(const DeviceOverrides& t) { &DeviceOverrides::GetScreenBufferPropertiesQNX; };
    if constexpr (HasGetScreenBufferPropertiesQNX) {
      if (!std::strcmp("vkGetScreenBufferPropertiesQNX", name))
        return (PFN_vkVoidFunction) &wrap_GetScreenBufferPropertiesQNX<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetSemaphoreCounterValue = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSemaphoreCounterValue; };
    if constexpr (HasGetSemaphoreCounterValue) {
      if (!std::strcmp("vkGetSemaphoreCounterValue", name))
        return (PFN_vkVoidFunction) &wrap_GetSemaphoreCounterValue<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSemaphoreCounterValueKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSemaphoreCounterValueKHR; };
    if constexpr (HasGetSemaphoreCounterValueKHR) {
      if (!std::strcmp("vkGetSemaphoreCounterValueKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetSemaphoreCounterValueKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSemaphoreFdKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSemaphoreFdKHR; };
    if constexpr (HasGetSemaphoreFdKHR) {
      if (!std::strcmp("vkGetSemaphoreFdKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetSemaphoreFdKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasGetSemaphoreWin32HandleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSemaphoreWin32HandleKHR; };
    if constexpr (HasGetSemaphoreWin32HandleKHR) {
      if (!std::strcmp("vkGetSemaphoreWin32HandleKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetSemaphoreWin32HandleKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasGetSemaphoreZirconHandleFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSemaphoreZirconHandleFUCHSIA; };
    if constexpr (HasGetSemaphoreZirconHandleFUCHSIA) {
      if (!std::strcmp("vkGetSemaphoreZirconHandleFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_GetSemaphoreZirconHandleFUCHSIA<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasGetShaderBinaryDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetShaderBinaryDataEXT; };
    if constexpr (HasGetShaderBinaryDataEXT) {
      if (!std::strcmp("vkGetShaderBinaryDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetShaderBinaryDataEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetShaderInfoAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::GetShaderInfoAMD; };
    if constexpr (HasGetShaderInfoAMD) {
      if (!std::strcmp("vkGetShaderInfoAMD", name))
        return (PFN_vkVoidFunction) &wrap_GetShaderInfoAMD<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetShaderModuleCreateInfoIdentifierEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetShaderModuleCreateInfoIdentifierEXT; };
    if constexpr (HasGetShaderModuleCreateInfoIdentifierEXT) {
      if (!std::strcmp("vkGetShaderModuleCreateInfoIdentifierEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetShaderModuleCreateInfoIdentifierEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetShaderModuleIdentifierEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetShaderModuleIdentifierEXT; };
    if constexpr (HasGetShaderModuleIdentifierEXT) {
      if (!std::strcmp("vkGetShaderModuleIdentifierEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetShaderModuleIdentifierEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSwapchainCounterEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSwapchainCounterEXT; };
    if constexpr (HasGetSwapchainCounterEXT) {
      if (!std::strcmp("vkGetSwapchainCounterEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetSwapchainCounterEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSwapchainImagesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSwapchainImagesKHR; };
    if constexpr (HasGetSwapchainImagesKHR) {
      if (!std::strcmp("vkGetSwapchainImagesKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetSwapchainImagesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetSwapchainStatusKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetSwapchainStatusKHR; };
    if constexpr (HasGetSwapchainStatusKHR) {
      if (!std::strcmp("vkGetSwapchainStatusKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetSwapchainStatusKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetTensorMemoryRequirementsARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetTensorMemoryRequirementsARM; };
    if constexpr (HasGetTensorMemoryRequirementsARM) {
      if (!std::strcmp("vkGetTensorMemoryRequirementsARM", name))
        return (PFN_vkVoidFunction) &wrap_GetTensorMemoryRequirementsARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetTensorOpaqueCaptureDescriptorDataARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetTensorOpaqueCaptureDescriptorDataARM; };
    if constexpr (HasGetTensorOpaqueCaptureDescriptorDataARM) {
      if (!std::strcmp("vkGetTensorOpaqueCaptureDescriptorDataARM", name))
        return (PFN_vkVoidFunction) &wrap_GetTensorOpaqueCaptureDescriptorDataARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetTensorViewOpaqueCaptureDescriptorDataARM = requires(const DeviceOverrides& t) { &DeviceOverrides::GetTensorViewOpaqueCaptureDescriptorDataARM; };
    if constexpr (HasGetTensorViewOpaqueCaptureDescriptorDataARM) {
      if (!std::strcmp("vkGetTensorViewOpaqueCaptureDescriptorDataARM", name))
        return (PFN_vkVoidFunction) &wrap_GetTensorViewOpaqueCaptureDescriptorDataARM<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetValidationCacheDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::GetValidationCacheDataEXT; };
    if constexpr (HasGetValidationCacheDataEXT) {
      if (!std::strcmp("vkGetValidationCacheDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_GetValidationCacheDataEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasGetVideoSessionMemoryRequirementsKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::GetVideoSessionMemoryRequirementsKHR; };
    if constexpr (HasGetVideoSessionMemoryRequirementsKHR) {
      if (!std::strcmp("vkGetVideoSessionMemoryRequirementsKHR", name))
        return (PFN_vkVoidFunction) &wrap_GetVideoSessionMemoryRequirementsKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasImportFenceFdKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ImportFenceFdKHR; };
    if constexpr (HasImportFenceFdKHR) {
      if (!std::strcmp("vkImportFenceFdKHR", name))
        return (PFN_vkVoidFunction) &wrap_ImportFenceFdKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasImportFenceWin32HandleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ImportFenceWin32HandleKHR; };
    if constexpr (HasImportFenceWin32HandleKHR) {
      if (!std::strcmp("vkImportFenceWin32HandleKHR", name))
        return (PFN_vkVoidFunction) &wrap_ImportFenceWin32HandleKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasImportSemaphoreFdKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ImportSemaphoreFdKHR; };
    if constexpr (HasImportSemaphoreFdKHR) {
      if (!std::strcmp("vkImportSemaphoreFdKHR", name))
        return (PFN_vkVoidFunction) &wrap_ImportSemaphoreFdKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasImportSemaphoreWin32HandleKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ImportSemaphoreWin32HandleKHR; };
    if constexpr (HasImportSemaphoreWin32HandleKHR) {
      if (!std::strcmp("vkImportSemaphoreWin32HandleKHR", name))
        return (PFN_vkVoidFunction) &wrap_ImportSemaphoreWin32HandleKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasImportSemaphoreZirconHandleFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::ImportSemaphoreZirconHandleFUCHSIA; };
    if constexpr (HasImportSemaphoreZirconHandleFUCHSIA) {
      if (!std::strcmp("vkImportSemaphoreZirconHandleFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_ImportSemaphoreZirconHandleFUCHSIA<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasInitializePerformanceApiINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::InitializePerformanceApiINTEL; };
    if constexpr (HasInitializePerformanceApiINTEL) {
      if (!std::strcmp("vkInitializePerformanceApiINTEL", name))
        return (PFN_vkVoidFunction) &wrap_InitializePerformanceApiINTEL<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasInvalidateMappedMemoryRanges = requires(const DeviceOverrides& t) { &DeviceOverrides::InvalidateMappedMemoryRanges; };
    if constexpr (HasInvalidateMappedMemoryRanges) {
      if (!std::strcmp("vkInvalidateMappedMemoryRanges", name))
        return (PFN_vkVoidFunction) &wrap_InvalidateMappedMemoryRanges<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasLatencySleepNV = requires(const DeviceOverrides& t) { &DeviceOverrides::LatencySleepNV; };
    if constexpr (HasLatencySleepNV) {
      if (!std::strcmp("vkLatencySleepNV", name))
        return (PFN_vkVoidFunction) &wrap_LatencySleepNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasMapMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::MapMemory; };
    if constexpr (HasMapMemory) {
      if (!std::strcmp("vkMapMemory", name))
        return (PFN_vkVoidFunction) &wrap_MapMemory<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasMapMemory2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::MapMemory2KHR; };
    if constexpr (HasMapMemory2KHR) {
      if (!std::strcmp("vkMapMemory2KHR", name))
        return (PFN_vkVoidFunction) &wrap_MapMemory2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasMergePipelineCaches = requires(const DeviceOverrides& t) { &DeviceOverrides::MergePipelineCaches; };
    if constexpr (HasMergePipelineCaches) {
      if (!std::strcmp("vkMergePipelineCaches", name))
        return (PFN_vkVoidFunction) &wrap_MergePipelineCaches<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasMergeValidationCachesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::MergeValidationCachesEXT; };
    if constexpr (HasMergeValidationCachesEXT) {
      if (!std::strcmp("vkMergeValidationCachesEXT", name))
        return (PFN_vkVoidFunction) &wrap_MergeValidationCachesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueBeginDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueBeginDebugUtilsLabelEXT; };
    if constexpr (HasQueueBeginDebugUtilsLabelEXT) {
      if (!std::strcmp("vkQueueBeginDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_QueueBeginDebugUtilsLabelEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueBindSparse = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueBindSparse; };
    if constexpr (HasQueueBindSparse) {
      if (!std::strcmp("vkQueueBindSparse", name))
        return (PFN_vkVoidFunction) &wrap_QueueBindSparse<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueEndDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueEndDebugUtilsLabelEXT; };
    if constexpr (HasQueueEndDebugUtilsLabelEXT) {
      if (!std::strcmp("vkQueueEndDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_QueueEndDebugUtilsLabelEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueInsertDebugUtilsLabelEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueInsertDebugUtilsLabelEXT; };
    if constexpr (HasQueueInsertDebugUtilsLabelEXT) {
      if (!std::strcmp("vkQueueInsertDebugUtilsLabelEXT", name))
        return (PFN_vkVoidFunction) &wrap_QueueInsertDebugUtilsLabelEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueNotifyOutOfBandNV = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueNotifyOutOfBandNV; };
    if constexpr (HasQueueNotifyOutOfBandNV) {
      if (!std::strcmp("vkQueueNotifyOutOfBandNV", name))
        return (PFN_vkVoidFunction) &wrap_QueueNotifyOutOfBandNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueuePresentKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::QueuePresentKHR; };
    if constexpr (HasQueuePresentKHR) {
      if (!std::strcmp("vkQueuePresentKHR", name))
        return (PFN_vkVoidFunction) &wrap_QueuePresentKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueSetPerformanceConfigurationINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueSetPerformanceConfigurationINTEL; };
    if constexpr (HasQueueSetPerformanceConfigurationINTEL) {
      if (!std::strcmp("vkQueueSetPerformanceConfigurationINTEL", name))
        return (PFN_vkVoidFunction) &wrap_QueueSetPerformanceConfigurationINTEL<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueSubmit = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueSubmit; };
    if constexpr (HasQueueSubmit) {
      if (!std::strcmp("vkQueueSubmit", name))
        return (PFN_vkVoidFunction) &wrap_QueueSubmit<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueSubmit2 = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueSubmit2; };
    if constexpr (HasQueueSubmit2) {
      if (!std::strcmp("vkQueueSubmit2", name))
        return (PFN_vkVoidFunction) &wrap_QueueSubmit2<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueSubmit2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueSubmit2KHR; };
    if constexpr (HasQueueSubmit2KHR) {
      if (!std::strcmp("vkQueueSubmit2KHR", name))
        return (PFN_vkVoidFunction) &wrap_QueueSubmit2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasQueueWaitIdle = requires(const DeviceOverrides& t) { &DeviceOverrides::QueueWaitIdle; };
    if constexpr (HasQueueWaitIdle) {
      if (!std::strcmp("vkQueueWaitIdle", name))
        return (PFN_vkVoidFunction) &wrap_QueueWaitIdle<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasRegisterDeviceEventEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::RegisterDeviceEventEXT; };
    if constexpr (HasRegisterDeviceEventEXT) {
      if (!std::strcmp("vkRegisterDeviceEventEXT", name))
        return (PFN_vkVoidFunction) &wrap_RegisterDeviceEventEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasRegisterDisplayEventEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::RegisterDisplayEventEXT; };
    if constexpr (HasRegisterDisplayEventEXT) {
      if (!std::strcmp("vkRegisterDisplayEventEXT", name))
        return (PFN_vkVoidFunction) &wrap_RegisterDisplayEventEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasReleaseCapturedPipelineDataKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleaseCapturedPipelineDataKHR; };
    if constexpr (HasReleaseCapturedPipelineDataKHR) {
      if (!std::strcmp("vkReleaseCapturedPipelineDataKHR", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseCapturedPipelineDataKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    constexpr bool HasReleaseFullScreenExclusiveModeEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleaseFullScreenExclusiveModeEXT; };
    if constexpr (HasReleaseFullScreenExclusiveModeEXT) {
      if (!std::strcmp("vkReleaseFullScreenExclusiveModeEXT", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseFullScreenExclusiveModeEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasReleasePerformanceConfigurationINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleasePerformanceConfigurationINTEL; };
    if constexpr (HasReleasePerformanceConfigurationINTEL) {
      if (!std::strcmp("vkReleasePerformanceConfigurationINTEL", name))
        return (PFN_vkVoidFunction) &wrap_ReleasePerformanceConfigurationINTEL<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasReleaseProfilingLockKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleaseProfilingLockKHR; };
    if constexpr (HasReleaseProfilingLockKHR) {
      if (!std::strcmp("vkReleaseProfilingLockKHR", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseProfilingLockKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasReleaseSwapchainImagesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleaseSwapchainImagesEXT; };
    if constexpr (HasReleaseSwapchainImagesEXT) {
      if (!std::strcmp("vkReleaseSwapchainImagesEXT", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseSwapchainImagesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasReleaseSwapchainImagesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::ReleaseSwapchainImagesKHR; };
    if constexpr (HasReleaseSwapchainImagesKHR) {
      if (!std::strcmp("vkReleaseSwapchainImagesKHR", name))
        return (PFN_vkVoidFunction) &wrap_ReleaseSwapchainImagesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetCommandBuffer = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetCommandBuffer; };
    if constexpr (HasResetCommandBuffer) {
      if (!std::strcmp("vkResetCommandBuffer", name))
        return (PFN_vkVoidFunction) &wrap_ResetCommandBuffer<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetCommandPool = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetCommandPool; };
    if constexpr (HasResetCommandPool) {
      if (!std::strcmp("vkResetCommandPool", name))
        return (PFN_vkVoidFunction) &wrap_ResetCommandPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetDescriptorPool = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetDescriptorPool; };
    if constexpr (HasResetDescriptorPool) {
      if (!std::strcmp("vkResetDescriptorPool", name))
        return (PFN_vkVoidFunction) &wrap_ResetDescriptorPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetEvent; };
    if constexpr (HasResetEvent) {
      if (!std::strcmp("vkResetEvent", name))
        return (PFN_vkVoidFunction) &wrap_ResetEvent<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetFences = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetFences; };
    if constexpr (HasResetFences) {
      if (!std::strcmp("vkResetFences", name))
        return (PFN_vkVoidFunction) &wrap_ResetFences<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetQueryPool = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetQueryPool; };
    if constexpr (HasResetQueryPool) {
      if (!std::strcmp("vkResetQueryPool", name))
        return (PFN_vkVoidFunction) &wrap_ResetQueryPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasResetQueryPoolEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::ResetQueryPoolEXT; };
    if constexpr (HasResetQueryPoolEXT) {
      if (!std::strcmp("vkResetQueryPoolEXT", name))
        return (PFN_vkVoidFunction) &wrap_ResetQueryPoolEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasSetBufferCollectionBufferConstraintsFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::SetBufferCollectionBufferConstraintsFUCHSIA; };
    if constexpr (HasSetBufferCollectionBufferConstraintsFUCHSIA) {
      if (!std::strcmp("vkSetBufferCollectionBufferConstraintsFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_SetBufferCollectionBufferConstraintsFUCHSIA<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
    constexpr bool HasSetBufferCollectionImageConstraintsFUCHSIA = requires(const DeviceOverrides& t) { &DeviceOverrides::SetBufferCollectionImageConstraintsFUCHSIA; };
    if constexpr (HasSetBufferCollectionImageConstraintsFUCHSIA) {
      if (!std::strcmp("vkSetBufferCollectionImageConstraintsFUCHSIA", name))
        return (PFN_vkVoidFunction) &wrap_SetBufferCollectionImageConstraintsFUCHSIA<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }
#endif

    constexpr bool HasSetDebugUtilsObjectNameEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::SetDebugUtilsObjectNameEXT; };
    if constexpr (HasSetDebugUtilsObjectNameEXT) {
      if (!std::strcmp("vkSetDebugUtilsObjectNameEXT", name))
        return (PFN_vkVoidFunction) &wrap_SetDebugUtilsObjectNameEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetDebugUtilsObjectTagEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::SetDebugUtilsObjectTagEXT; };
    if constexpr (HasSetDebugUtilsObjectTagEXT) {
      if (!std::strcmp("vkSetDebugUtilsObjectTagEXT", name))
        return (PFN_vkVoidFunction) &wrap_SetDebugUtilsObjectTagEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetDeviceMemoryPriorityEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::SetDeviceMemoryPriorityEXT; };
    if constexpr (HasSetDeviceMemoryPriorityEXT) {
      if (!std::strcmp("vkSetDeviceMemoryPriorityEXT", name))
        return (PFN_vkVoidFunction) &wrap_SetDeviceMemoryPriorityEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetEvent = requires(const DeviceOverrides& t) { &DeviceOverrides::SetEvent; };
    if constexpr (HasSetEvent) {
      if (!std::strcmp("vkSetEvent", name))
        return (PFN_vkVoidFunction) &wrap_SetEvent<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetHdrMetadataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::SetHdrMetadataEXT; };
    if constexpr (HasSetHdrMetadataEXT) {
      if (!std::strcmp("vkSetHdrMetadataEXT", name))
        return (PFN_vkVoidFunction) &wrap_SetHdrMetadataEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetLatencyMarkerNV = requires(const DeviceOverrides& t) { &DeviceOverrides::SetLatencyMarkerNV; };
    if constexpr (HasSetLatencyMarkerNV) {
      if (!std::strcmp("vkSetLatencyMarkerNV", name))
        return (PFN_vkVoidFunction) &wrap_SetLatencyMarkerNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetLatencySleepModeNV = requires(const DeviceOverrides& t) { &DeviceOverrides::SetLatencySleepModeNV; };
    if constexpr (HasSetLatencySleepModeNV) {
      if (!std::strcmp("vkSetLatencySleepModeNV", name))
        return (PFN_vkVoidFunction) &wrap_SetLatencySleepModeNV<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetLocalDimmingAMD = requires(const DeviceOverrides& t) { &DeviceOverrides::SetLocalDimmingAMD; };
    if constexpr (HasSetLocalDimmingAMD) {
      if (!std::strcmp("vkSetLocalDimmingAMD", name))
        return (PFN_vkVoidFunction) &wrap_SetLocalDimmingAMD<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetPrivateData = requires(const DeviceOverrides& t) { &DeviceOverrides::SetPrivateData; };
    if constexpr (HasSetPrivateData) {
      if (!std::strcmp("vkSetPrivateData", name))
        return (PFN_vkVoidFunction) &wrap_SetPrivateData<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSetPrivateDataEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::SetPrivateDataEXT; };
    if constexpr (HasSetPrivateDataEXT) {
      if (!std::strcmp("vkSetPrivateDataEXT", name))
        return (PFN_vkVoidFunction) &wrap_SetPrivateDataEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSignalSemaphore = requires(const DeviceOverrides& t) { &DeviceOverrides::SignalSemaphore; };
    if constexpr (HasSignalSemaphore) {
      if (!std::strcmp("vkSignalSemaphore", name))
        return (PFN_vkVoidFunction) &wrap_SignalSemaphore<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasSignalSemaphoreKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::SignalSemaphoreKHR; };
    if constexpr (HasSignalSemaphoreKHR) {
      if (!std::strcmp("vkSignalSemaphoreKHR", name))
        return (PFN_vkVoidFunction) &wrap_SignalSemaphoreKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasTransitionImageLayoutEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::TransitionImageLayoutEXT; };
    if constexpr (HasTransitionImageLayoutEXT) {
      if (!std::strcmp("vkTransitionImageLayoutEXT", name))
        return (PFN_vkVoidFunction) &wrap_TransitionImageLayoutEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasTrimCommandPool = requires(const DeviceOverrides& t) { &DeviceOverrides::TrimCommandPool; };
    if constexpr (HasTrimCommandPool) {
      if (!std::strcmp("vkTrimCommandPool", name))
        return (PFN_vkVoidFunction) &wrap_TrimCommandPool<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasTrimCommandPoolKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::TrimCommandPoolKHR; };
    if constexpr (HasTrimCommandPoolKHR) {
      if (!std::strcmp("vkTrimCommandPoolKHR", name))
        return (PFN_vkVoidFunction) &wrap_TrimCommandPoolKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUninitializePerformanceApiINTEL = requires(const DeviceOverrides& t) { &DeviceOverrides::UninitializePerformanceApiINTEL; };
    if constexpr (HasUninitializePerformanceApiINTEL) {
      if (!std::strcmp("vkUninitializePerformanceApiINTEL", name))
        return (PFN_vkVoidFunction) &wrap_UninitializePerformanceApiINTEL<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUnmapMemory = requires(const DeviceOverrides& t) { &DeviceOverrides::UnmapMemory; };
    if constexpr (HasUnmapMemory) {
      if (!std::strcmp("vkUnmapMemory", name))
        return (PFN_vkVoidFunction) &wrap_UnmapMemory<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUnmapMemory2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::UnmapMemory2KHR; };
    if constexpr (HasUnmapMemory2KHR) {
      if (!std::strcmp("vkUnmapMemory2KHR", name))
        return (PFN_vkVoidFunction) &wrap_UnmapMemory2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateDescriptorSetWithTemplate = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateDescriptorSetWithTemplate; };
    if constexpr (HasUpdateDescriptorSetWithTemplate) {
      if (!std::strcmp("vkUpdateDescriptorSetWithTemplate", name))
        return (PFN_vkVoidFunction) &wrap_UpdateDescriptorSetWithTemplate<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateDescriptorSetWithTemplateKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateDescriptorSetWithTemplateKHR; };
    if constexpr (HasUpdateDescriptorSetWithTemplateKHR) {
      if (!std::strcmp("vkUpdateDescriptorSetWithTemplateKHR", name))
        return (PFN_vkVoidFunction) &wrap_UpdateDescriptorSetWithTemplateKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateDescriptorSets = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateDescriptorSets; };
    if constexpr (HasUpdateDescriptorSets) {
      if (!std::strcmp("vkUpdateDescriptorSets", name))
        return (PFN_vkVoidFunction) &wrap_UpdateDescriptorSets<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateIndirectExecutionSetPipelineEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateIndirectExecutionSetPipelineEXT; };
    if constexpr (HasUpdateIndirectExecutionSetPipelineEXT) {
      if (!std::strcmp("vkUpdateIndirectExecutionSetPipelineEXT", name))
        return (PFN_vkVoidFunction) &wrap_UpdateIndirectExecutionSetPipelineEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateIndirectExecutionSetShaderEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateIndirectExecutionSetShaderEXT; };
    if constexpr (HasUpdateIndirectExecutionSetShaderEXT) {
      if (!std::strcmp("vkUpdateIndirectExecutionSetShaderEXT", name))
        return (PFN_vkVoidFunction) &wrap_UpdateIndirectExecutionSetShaderEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasUpdateVideoSessionParametersKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::UpdateVideoSessionParametersKHR; };
    if constexpr (HasUpdateVideoSessionParametersKHR) {
      if (!std::strcmp("vkUpdateVideoSessionParametersKHR", name))
        return (PFN_vkVoidFunction) &wrap_UpdateVideoSessionParametersKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWaitForFences = requires(const DeviceOverrides& t) { &DeviceOverrides::WaitForFences; };
    if constexpr (HasWaitForFences) {
      if (!std::strcmp("vkWaitForFences", name))
        return (PFN_vkVoidFunction) &wrap_WaitForFences<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWaitForPresent2KHR = requires(const DeviceOverrides& t) { &DeviceOverrides::WaitForPresent2KHR; };
    if constexpr (HasWaitForPresent2KHR) {
      if (!std::strcmp("vkWaitForPresent2KHR", name))
        return (PFN_vkVoidFunction) &wrap_WaitForPresent2KHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWaitForPresentKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::WaitForPresentKHR; };
    if constexpr (HasWaitForPresentKHR) {
      if (!std::strcmp("vkWaitForPresentKHR", name))
        return (PFN_vkVoidFunction) &wrap_WaitForPresentKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWaitSemaphores = requires(const DeviceOverrides& t) { &DeviceOverrides::WaitSemaphores; };
    if constexpr (HasWaitSemaphores) {
      if (!std::strcmp("vkWaitSemaphores", name))
        return (PFN_vkVoidFunction) &wrap_WaitSemaphores<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWaitSemaphoresKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::WaitSemaphoresKHR; };
    if constexpr (HasWaitSemaphoresKHR) {
      if (!std::strcmp("vkWaitSemaphoresKHR", name))
        return (PFN_vkVoidFunction) &wrap_WaitSemaphoresKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWriteAccelerationStructuresPropertiesKHR = requires(const DeviceOverrides& t) { &DeviceOverrides::WriteAccelerationStructuresPropertiesKHR; };
    if constexpr (HasWriteAccelerationStructuresPropertiesKHR) {
      if (!std::strcmp("vkWriteAccelerationStructuresPropertiesKHR", name))
        return (PFN_vkVoidFunction) &wrap_WriteAccelerationStructuresPropertiesKHR<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    constexpr bool HasWriteMicromapsPropertiesEXT = requires(const DeviceOverrides& t) { &DeviceOverrides::WriteMicromapsPropertiesEXT; };
    if constexpr (HasWriteMicromapsPropertiesEXT) {
      if (!std::strcmp("vkWriteMicromapsPropertiesEXT", name))
        return (PFN_vkVoidFunction) &wrap_WriteMicromapsPropertiesEXT<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    }

    if (dispatch)
      return dispatch->GetDeviceProcAddr(device, name);
    else
      return NULL;
  }

  namespace helpers {
    template <typename EnumType>
    constexpr const char* enumString(EnumType type);

    template <> constexpr const char* enumString<VkAccelerationStructureBuildTypeKHR>(VkAccelerationStructureBuildTypeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_KHR";
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_DEVICE_KHR";
        case static_cast<uint64_t>(2): return "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_HOST_OR_DEVICE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_BUILD_TYPE_KHR_MAX_ENUM";
        default: return "VkAccelerationStructureBuildTypeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccelerationStructureCompatibilityKHR>(VkAccelerationStructureCompatibilityKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_COMPATIBLE_KHR";
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_INCOMPATIBLE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_COMPATIBILITY_KHR_MAX_ENUM";
        default: return "VkAccelerationStructureCompatibilityKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccelerationStructureCreateFlagBitsKHR>(VkAccelerationStructureCreateFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_CREATE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(8): return "VK_ACCELERATION_STRUCTURE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_ACCELERATION_STRUCTURE_CREATE_MOTION_BIT_NV";
        default: return "VkAccelerationStructureCreateFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccelerationStructureMemoryRequirementsTypeNV>(VkAccelerationStructureMemoryRequirementsTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_OBJECT_NV";
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_BUILD_SCRATCH_NV";
        case static_cast<uint64_t>(2): return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_UPDATE_SCRATCH_NV";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_TYPE_NV_MAX_ENUM";
        default: return "VkAccelerationStructureMemoryRequirementsTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccelerationStructureMotionInstanceTypeNV>(VkAccelerationStructureMotionInstanceTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_STATIC_NV";
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_MATRIX_MOTION_NV";
        case static_cast<uint64_t>(2): return "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_SRT_MOTION_NV";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_MOTION_INSTANCE_TYPE_NV_MAX_ENUM";
        default: return "VkAccelerationStructureMotionInstanceTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccelerationStructureTypeKHR>(VkAccelerationStructureTypeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ACCELERATION_STRUCTURE_TYPE_TOP_LEVEL_KHR";
        case static_cast<uint64_t>(1): return "VK_ACCELERATION_STRUCTURE_TYPE_BOTTOM_LEVEL_KHR";
        case static_cast<uint64_t>(2): return "VK_ACCELERATION_STRUCTURE_TYPE_GENERIC_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_ACCELERATION_STRUCTURE_TYPE_KHR_MAX_ENUM";
        default: return "VkAccelerationStructureTypeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAccessFlagBits>(VkAccessFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_ACCESS_INDIRECT_COMMAND_READ_BIT";
        case static_cast<uint64_t>(2): return "VK_ACCESS_INDEX_READ_BIT";
        case static_cast<uint64_t>(4): return "VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT";
        case static_cast<uint64_t>(8): return "VK_ACCESS_UNIFORM_READ_BIT";
        case static_cast<uint64_t>(16): return "VK_ACCESS_INPUT_ATTACHMENT_READ_BIT";
        case static_cast<uint64_t>(32): return "VK_ACCESS_SHADER_READ_BIT";
        case static_cast<uint64_t>(64): return "VK_ACCESS_SHADER_WRITE_BIT";
        case static_cast<uint64_t>(128): return "VK_ACCESS_COLOR_ATTACHMENT_READ_BIT";
        case static_cast<uint64_t>(256): return "VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT";
        case static_cast<uint64_t>(512): return "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT";
        case static_cast<uint64_t>(1024): return "VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT";
        case static_cast<uint64_t>(2048): return "VK_ACCESS_TRANSFER_READ_BIT";
        case static_cast<uint64_t>(4096): return "VK_ACCESS_TRANSFER_WRITE_BIT";
        case static_cast<uint64_t>(8192): return "VK_ACCESS_HOST_READ_BIT";
        case static_cast<uint64_t>(16384): return "VK_ACCESS_HOST_WRITE_BIT";
        case static_cast<uint64_t>(32768): return "VK_ACCESS_MEMORY_READ_BIT";
        case static_cast<uint64_t>(65536): return "VK_ACCESS_MEMORY_WRITE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_ACCESS_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(0): return "VK_ACCESS_NONE";
        case static_cast<uint64_t>(33554432): return "VK_ACCESS_TRANSFORM_FEEDBACK_WRITE_BIT_EXT";
        case static_cast<uint64_t>(67108864): return "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_READ_BIT_EXT";
        case static_cast<uint64_t>(134217728): return "VK_ACCESS_TRANSFORM_FEEDBACK_COUNTER_WRITE_BIT_EXT";
        case static_cast<uint64_t>(1048576): return "VK_ACCESS_CONDITIONAL_RENDERING_READ_BIT_EXT";
        case static_cast<uint64_t>(524288): return "VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT";
        case static_cast<uint64_t>(16777216): return "VK_ACCESS_FRAGMENT_DENSITY_MAP_READ_BIT_EXT";
        case static_cast<uint64_t>(8388608): return "VK_ACCESS_FRAGMENT_SHADING_RATE_ATTACHMENT_READ_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_ACCESS_COMMAND_PREPROCESS_READ_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_ACCESS_COMMAND_PREPROCESS_WRITE_BIT_EXT";
        case static_cast<uint64_t>(2097152): return "VK_ACCESS_ACCELERATION_STRUCTURE_READ_BIT_KHR";
        case static_cast<uint64_t>(4194304): return "VK_ACCESS_ACCELERATION_STRUCTURE_WRITE_BIT_KHR";
        default: return "VkAccessFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAntiLagModeAMD>(VkAntiLagModeAMD type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ANTI_LAG_MODE_DRIVER_CONTROL_AMD";
        case static_cast<uint64_t>(1): return "VK_ANTI_LAG_MODE_ON_AMD";
        case static_cast<uint64_t>(2): return "VK_ANTI_LAG_MODE_OFF_AMD";
        case static_cast<uint64_t>(2147483647): return "VK_ANTI_LAG_MODE_AMD_MAX_ENUM";
        default: return "VkAntiLagModeAMD_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAntiLagStageAMD>(VkAntiLagStageAMD type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ANTI_LAG_STAGE_INPUT_AMD";
        case static_cast<uint64_t>(1): return "VK_ANTI_LAG_STAGE_PRESENT_AMD";
        case static_cast<uint64_t>(2147483647): return "VK_ANTI_LAG_STAGE_AMD_MAX_ENUM";
        default: return "VkAntiLagStageAMD_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAttachmentDescriptionFlagBits>(VkAttachmentDescriptionFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM";
        default: return "VkAttachmentDescriptionFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAttachmentLoadOp>(VkAttachmentLoadOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ATTACHMENT_LOAD_OP_LOAD";
        case static_cast<uint64_t>(1): return "VK_ATTACHMENT_LOAD_OP_CLEAR";
        case static_cast<uint64_t>(2): return "VK_ATTACHMENT_LOAD_OP_DONT_CARE";
        case static_cast<uint64_t>(2147483647): return "VK_ATTACHMENT_LOAD_OP_MAX_ENUM";
        case static_cast<uint64_t>(1000400000): return "VK_ATTACHMENT_LOAD_OP_NONE";
        default: return "VkAttachmentLoadOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkAttachmentStoreOp>(VkAttachmentStoreOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_ATTACHMENT_STORE_OP_STORE";
        case static_cast<uint64_t>(1): return "VK_ATTACHMENT_STORE_OP_DONT_CARE";
        case static_cast<uint64_t>(2147483647): return "VK_ATTACHMENT_STORE_OP_MAX_ENUM";
        case static_cast<uint64_t>(1000301000): return "VK_ATTACHMENT_STORE_OP_NONE";
        default: return "VkAttachmentStoreOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBlendFactor>(VkBlendFactor type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BLEND_FACTOR_ZERO";
        case static_cast<uint64_t>(1): return "VK_BLEND_FACTOR_ONE";
        case static_cast<uint64_t>(2): return "VK_BLEND_FACTOR_SRC_COLOR";
        case static_cast<uint64_t>(3): return "VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR";
        case static_cast<uint64_t>(4): return "VK_BLEND_FACTOR_DST_COLOR";
        case static_cast<uint64_t>(5): return "VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR";
        case static_cast<uint64_t>(6): return "VK_BLEND_FACTOR_SRC_ALPHA";
        case static_cast<uint64_t>(7): return "VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA";
        case static_cast<uint64_t>(8): return "VK_BLEND_FACTOR_DST_ALPHA";
        case static_cast<uint64_t>(9): return "VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA";
        case static_cast<uint64_t>(10): return "VK_BLEND_FACTOR_CONSTANT_COLOR";
        case static_cast<uint64_t>(11): return "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR";
        case static_cast<uint64_t>(12): return "VK_BLEND_FACTOR_CONSTANT_ALPHA";
        case static_cast<uint64_t>(13): return "VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA";
        case static_cast<uint64_t>(14): return "VK_BLEND_FACTOR_SRC_ALPHA_SATURATE";
        case static_cast<uint64_t>(15): return "VK_BLEND_FACTOR_SRC1_COLOR";
        case static_cast<uint64_t>(16): return "VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR";
        case static_cast<uint64_t>(17): return "VK_BLEND_FACTOR_SRC1_ALPHA";
        case static_cast<uint64_t>(18): return "VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA";
        case static_cast<uint64_t>(2147483647): return "VK_BLEND_FACTOR_MAX_ENUM";
        default: return "VkBlendFactor_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBlendOp>(VkBlendOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BLEND_OP_ADD";
        case static_cast<uint64_t>(1): return "VK_BLEND_OP_SUBTRACT";
        case static_cast<uint64_t>(2): return "VK_BLEND_OP_REVERSE_SUBTRACT";
        case static_cast<uint64_t>(3): return "VK_BLEND_OP_MIN";
        case static_cast<uint64_t>(4): return "VK_BLEND_OP_MAX";
        case static_cast<uint64_t>(2147483647): return "VK_BLEND_OP_MAX_ENUM";
        case static_cast<uint64_t>(1000148000): return "VK_BLEND_OP_ZERO_EXT";
        case static_cast<uint64_t>(1000148001): return "VK_BLEND_OP_SRC_EXT";
        case static_cast<uint64_t>(1000148002): return "VK_BLEND_OP_DST_EXT";
        case static_cast<uint64_t>(1000148003): return "VK_BLEND_OP_SRC_OVER_EXT";
        case static_cast<uint64_t>(1000148004): return "VK_BLEND_OP_DST_OVER_EXT";
        case static_cast<uint64_t>(1000148005): return "VK_BLEND_OP_SRC_IN_EXT";
        case static_cast<uint64_t>(1000148006): return "VK_BLEND_OP_DST_IN_EXT";
        case static_cast<uint64_t>(1000148007): return "VK_BLEND_OP_SRC_OUT_EXT";
        case static_cast<uint64_t>(1000148008): return "VK_BLEND_OP_DST_OUT_EXT";
        case static_cast<uint64_t>(1000148009): return "VK_BLEND_OP_SRC_ATOP_EXT";
        case static_cast<uint64_t>(1000148010): return "VK_BLEND_OP_DST_ATOP_EXT";
        case static_cast<uint64_t>(1000148011): return "VK_BLEND_OP_XOR_EXT";
        case static_cast<uint64_t>(1000148012): return "VK_BLEND_OP_MULTIPLY_EXT";
        case static_cast<uint64_t>(1000148013): return "VK_BLEND_OP_SCREEN_EXT";
        case static_cast<uint64_t>(1000148014): return "VK_BLEND_OP_OVERLAY_EXT";
        case static_cast<uint64_t>(1000148015): return "VK_BLEND_OP_DARKEN_EXT";
        case static_cast<uint64_t>(1000148016): return "VK_BLEND_OP_LIGHTEN_EXT";
        case static_cast<uint64_t>(1000148017): return "VK_BLEND_OP_COLORDODGE_EXT";
        case static_cast<uint64_t>(1000148018): return "VK_BLEND_OP_COLORBURN_EXT";
        case static_cast<uint64_t>(1000148019): return "VK_BLEND_OP_HARDLIGHT_EXT";
        case static_cast<uint64_t>(1000148020): return "VK_BLEND_OP_SOFTLIGHT_EXT";
        case static_cast<uint64_t>(1000148021): return "VK_BLEND_OP_DIFFERENCE_EXT";
        case static_cast<uint64_t>(1000148022): return "VK_BLEND_OP_EXCLUSION_EXT";
        case static_cast<uint64_t>(1000148023): return "VK_BLEND_OP_INVERT_EXT";
        case static_cast<uint64_t>(1000148024): return "VK_BLEND_OP_INVERT_RGB_EXT";
        case static_cast<uint64_t>(1000148025): return "VK_BLEND_OP_LINEARDODGE_EXT";
        case static_cast<uint64_t>(1000148026): return "VK_BLEND_OP_LINEARBURN_EXT";
        case static_cast<uint64_t>(1000148027): return "VK_BLEND_OP_VIVIDLIGHT_EXT";
        case static_cast<uint64_t>(1000148028): return "VK_BLEND_OP_LINEARLIGHT_EXT";
        case static_cast<uint64_t>(1000148029): return "VK_BLEND_OP_PINLIGHT_EXT";
        case static_cast<uint64_t>(1000148030): return "VK_BLEND_OP_HARDMIX_EXT";
        case static_cast<uint64_t>(1000148031): return "VK_BLEND_OP_HSL_HUE_EXT";
        case static_cast<uint64_t>(1000148032): return "VK_BLEND_OP_HSL_SATURATION_EXT";
        case static_cast<uint64_t>(1000148033): return "VK_BLEND_OP_HSL_COLOR_EXT";
        case static_cast<uint64_t>(1000148034): return "VK_BLEND_OP_HSL_LUMINOSITY_EXT";
        case static_cast<uint64_t>(1000148035): return "VK_BLEND_OP_PLUS_EXT";
        case static_cast<uint64_t>(1000148036): return "VK_BLEND_OP_PLUS_CLAMPED_EXT";
        case static_cast<uint64_t>(1000148037): return "VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT";
        case static_cast<uint64_t>(1000148038): return "VK_BLEND_OP_PLUS_DARKER_EXT";
        case static_cast<uint64_t>(1000148039): return "VK_BLEND_OP_MINUS_EXT";
        case static_cast<uint64_t>(1000148040): return "VK_BLEND_OP_MINUS_CLAMPED_EXT";
        case static_cast<uint64_t>(1000148041): return "VK_BLEND_OP_CONTRAST_EXT";
        case static_cast<uint64_t>(1000148042): return "VK_BLEND_OP_INVERT_OVG_EXT";
        case static_cast<uint64_t>(1000148043): return "VK_BLEND_OP_RED_EXT";
        case static_cast<uint64_t>(1000148044): return "VK_BLEND_OP_GREEN_EXT";
        case static_cast<uint64_t>(1000148045): return "VK_BLEND_OP_BLUE_EXT";
        default: return "VkBlendOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBlendOverlapEXT>(VkBlendOverlapEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BLEND_OVERLAP_UNCORRELATED_EXT";
        case static_cast<uint64_t>(1): return "VK_BLEND_OVERLAP_DISJOINT_EXT";
        case static_cast<uint64_t>(2): return "VK_BLEND_OVERLAP_CONJOINT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_BLEND_OVERLAP_EXT_MAX_ENUM";
        default: return "VkBlendOverlapEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBlockMatchWindowCompareModeQCOM>(VkBlockMatchWindowCompareModeQCOM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MIN_QCOM";
        case static_cast<uint64_t>(1): return "VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_MAX_QCOM";
        case static_cast<uint64_t>(2147483647): return "VK_BLOCK_MATCH_WINDOW_COMPARE_MODE_QCOM_MAX_ENUM";
        default: return "VkBlockMatchWindowCompareModeQCOM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBorderColor>(VkBorderColor type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK";
        case static_cast<uint64_t>(1): return "VK_BORDER_COLOR_INT_TRANSPARENT_BLACK";
        case static_cast<uint64_t>(2): return "VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK";
        case static_cast<uint64_t>(3): return "VK_BORDER_COLOR_INT_OPAQUE_BLACK";
        case static_cast<uint64_t>(4): return "VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE";
        case static_cast<uint64_t>(5): return "VK_BORDER_COLOR_INT_OPAQUE_WHITE";
        case static_cast<uint64_t>(2147483647): return "VK_BORDER_COLOR_MAX_ENUM";
        case static_cast<uint64_t>(1000287003): return "VK_BORDER_COLOR_FLOAT_CUSTOM_EXT";
        case static_cast<uint64_t>(1000287004): return "VK_BORDER_COLOR_INT_CUSTOM_EXT";
        default: return "VkBorderColor_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBufferCreateFlagBits>(VkBufferCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_BUFFER_CREATE_SPARSE_BINDING_BIT";
        case static_cast<uint64_t>(2): return "VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT";
        case static_cast<uint64_t>(4): return "VK_BUFFER_CREATE_SPARSE_ALIASED_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(8): return "VK_BUFFER_CREATE_PROTECTED_BIT";
        case static_cast<uint64_t>(16): return "VK_BUFFER_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT";
        case static_cast<uint64_t>(32): return "VK_BUFFER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_BUFFER_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR";
        default: return "VkBufferCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBufferUsageFlagBits>(VkBufferUsageFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_BUFFER_USAGE_TRANSFER_SRC_BIT";
        case static_cast<uint64_t>(2): return "VK_BUFFER_USAGE_TRANSFER_DST_BIT";
        case static_cast<uint64_t>(4): return "VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT";
        case static_cast<uint64_t>(8): return "VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT";
        case static_cast<uint64_t>(16): return "VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT";
        case static_cast<uint64_t>(32): return "VK_BUFFER_USAGE_STORAGE_BUFFER_BIT";
        case static_cast<uint64_t>(64): return "VK_BUFFER_USAGE_INDEX_BUFFER_BIT";
        case static_cast<uint64_t>(128): return "VK_BUFFER_USAGE_VERTEX_BUFFER_BIT";
        case static_cast<uint64_t>(256): return "VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(131072): return "VK_BUFFER_USAGE_SHADER_DEVICE_ADDRESS_BIT";
        case static_cast<uint64_t>(8192): return "VK_BUFFER_USAGE_VIDEO_DECODE_SRC_BIT_KHR";
        case static_cast<uint64_t>(16384): return "VK_BUFFER_USAGE_VIDEO_DECODE_DST_BIT_KHR";
        case static_cast<uint64_t>(2048): return "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(4096): return "VK_BUFFER_USAGE_TRANSFORM_FEEDBACK_COUNTER_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(512): return "VK_BUFFER_USAGE_CONDITIONAL_RENDERING_BIT_EXT";
        case static_cast<uint64_t>(33554432): return "VK_BUFFER_USAGE_EXECUTION_GRAPH_SCRATCH_BIT_AMDX";
        case static_cast<uint64_t>(32768): return "VK_BUFFER_USAGE_VIDEO_ENCODE_DST_BIT_KHR";
        case static_cast<uint64_t>(65536): return "VK_BUFFER_USAGE_VIDEO_ENCODE_SRC_BIT_KHR";
        case static_cast<uint64_t>(2097152): return "VK_BUFFER_USAGE_SAMPLER_DESCRIPTOR_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(4194304): return "VK_BUFFER_USAGE_RESOURCE_DESCRIPTOR_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(67108864): return "VK_BUFFER_USAGE_PUSH_DESCRIPTORS_DESCRIPTOR_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(8388608): return "VK_BUFFER_USAGE_MICROMAP_BUILD_INPUT_READ_ONLY_BIT_EXT";
        case static_cast<uint64_t>(16777216): return "VK_BUFFER_USAGE_MICROMAP_STORAGE_BIT_EXT";
        case static_cast<uint64_t>(134217728): return "VK_BUFFER_USAGE_TILE_MEMORY_BIT_QCOM";
        case static_cast<uint64_t>(524288): return "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_BUILD_INPUT_READ_ONLY_BIT_KHR";
        case static_cast<uint64_t>(1048576): return "VK_BUFFER_USAGE_ACCELERATION_STRUCTURE_STORAGE_BIT_KHR";
        case static_cast<uint64_t>(1024): return "VK_BUFFER_USAGE_SHADER_BINDING_TABLE_BIT_KHR";
        default: return "VkBufferUsageFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBuildAccelerationStructureFlagBitsKHR>(VkBuildAccelerationStructureFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_UPDATE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_COMPACTION_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_TRACE_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_BUILD_ACCELERATION_STRUCTURE_PREFER_FAST_BUILD_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_BUILD_ACCELERATION_STRUCTURE_LOW_MEMORY_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_BUILD_ACCELERATION_STRUCTURE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(32): return "VK_BUILD_ACCELERATION_STRUCTURE_MOTION_BIT_NV";
        case static_cast<uint64_t>(64): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_UPDATE_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISABLE_OPACITY_MICROMAPS_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_OPACITY_MICROMAP_DATA_UPDATE_BIT_EXT";
        case static_cast<uint64_t>(512): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DISPLACEMENT_MICROMAP_UPDATE_BIT_NV";
        case static_cast<uint64_t>(2048): return "VK_BUILD_ACCELERATION_STRUCTURE_ALLOW_DATA_ACCESS_BIT_KHR";
        default: return "VkBuildAccelerationStructureFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBuildAccelerationStructureModeKHR>(VkBuildAccelerationStructureModeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BUILD_ACCELERATION_STRUCTURE_MODE_BUILD_KHR";
        case static_cast<uint64_t>(1): return "VK_BUILD_ACCELERATION_STRUCTURE_MODE_UPDATE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_BUILD_ACCELERATION_STRUCTURE_MODE_KHR_MAX_ENUM";
        default: return "VkBuildAccelerationStructureModeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBuildMicromapFlagBitsEXT>(VkBuildMicromapFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_BUILD_MICROMAP_PREFER_FAST_TRACE_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_BUILD_MICROMAP_PREFER_FAST_BUILD_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_BUILD_MICROMAP_ALLOW_COMPACTION_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_BUILD_MICROMAP_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkBuildMicromapFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkBuildMicromapModeEXT>(VkBuildMicromapModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_BUILD_MICROMAP_MODE_BUILD_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_BUILD_MICROMAP_MODE_EXT_MAX_ENUM";
        default: return "VkBuildMicromapModeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkChromaLocation>(VkChromaLocation type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CHROMA_LOCATION_COSITED_EVEN";
        case static_cast<uint64_t>(1): return "VK_CHROMA_LOCATION_MIDPOINT";
        case static_cast<uint64_t>(2147483647): return "VK_CHROMA_LOCATION_MAX_ENUM";
        default: return "VkChromaLocation_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureAddressResolutionFlagBitsNV>(VkClusterAccelerationStructureAddressResolutionFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_NONE_NV";
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_IMPLICIT_DATA_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SCRATCH_DATA_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_ADDRESS_ARRAY_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_DST_SIZES_ARRAY_BIT_NV";
        case static_cast<uint64_t>(16): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_ARRAY_BIT_NV";
        case static_cast<uint64_t>(32): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_INDIRECTED_SRC_INFOS_COUNT_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_ADDRESS_RESOLUTION_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureAddressResolutionFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureClusterFlagBitsNV>(VkClusterAccelerationStructureClusterFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_ALLOW_DISABLE_OPACITY_MICROMAPS_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_CLUSTER_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureClusterFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureGeometryFlagBitsNV>(VkClusterAccelerationStructureGeometryFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_CULL_DISABLE_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_NO_DUPLICATE_ANYHIT_INVOCATION_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_OPAQUE_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_GEOMETRY_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureGeometryFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureIndexFormatFlagBitsNV>(VkClusterAccelerationStructureIndexFormatFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_8BIT_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_16BIT_NV";
        case static_cast<uint64_t>(4): return "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_32BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_INDEX_FORMAT_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureIndexFormatFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureOpModeNV>(VkClusterAccelerationStructureOpModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_IMPLICIT_DESTINATIONS_NV";
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_EXPLICIT_DESTINATIONS_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_COMPUTE_SIZES_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_MODE_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureOpModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureOpTypeNV>(VkClusterAccelerationStructureOpTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_MOVE_OBJECTS_NV";
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_CLUSTERS_BOTTOM_LEVEL_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_NV";
        case static_cast<uint64_t>(3): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_BUILD_TRIANGLE_CLUSTER_TEMPLATE_NV";
        case static_cast<uint64_t>(4): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_INSTANTIATE_TRIANGLE_CLUSTER_NV";
        case static_cast<uint64_t>(5): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_GET_CLUSTER_TEMPLATE_INDICES_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_OP_TYPE_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureOpTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkClusterAccelerationStructureTypeNV>(VkClusterAccelerationStructureTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_CLUSTERS_BOTTOM_LEVEL_NV";
        case static_cast<uint64_t>(1): return "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_NV";
        case static_cast<uint64_t>(2): return "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_TRIANGLE_CLUSTER_TEMPLATE_NV";
        case static_cast<uint64_t>(2147483647): return "VK_CLUSTER_ACCELERATION_STRUCTURE_TYPE_NV_MAX_ENUM";
        default: return "VkClusterAccelerationStructureTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCoarseSampleOrderTypeNV>(VkCoarseSampleOrderTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COARSE_SAMPLE_ORDER_TYPE_DEFAULT_NV";
        case static_cast<uint64_t>(1): return "VK_COARSE_SAMPLE_ORDER_TYPE_CUSTOM_NV";
        case static_cast<uint64_t>(2): return "VK_COARSE_SAMPLE_ORDER_TYPE_PIXEL_MAJOR_NV";
        case static_cast<uint64_t>(3): return "VK_COARSE_SAMPLE_ORDER_TYPE_SAMPLE_MAJOR_NV";
        case static_cast<uint64_t>(2147483647): return "VK_COARSE_SAMPLE_ORDER_TYPE_NV_MAX_ENUM";
        default: return "VkCoarseSampleOrderTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkColorComponentFlagBits>(VkColorComponentFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COLOR_COMPONENT_R_BIT";
        case static_cast<uint64_t>(2): return "VK_COLOR_COMPONENT_G_BIT";
        case static_cast<uint64_t>(4): return "VK_COLOR_COMPONENT_B_BIT";
        case static_cast<uint64_t>(8): return "VK_COLOR_COMPONENT_A_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM";
        default: return "VkColorComponentFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkColorSpaceKHR>(VkColorSpaceKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COLOR_SPACE_SRGB_NONLINEAR_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_COLOR_SPACE_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1000104001): return "VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT";
        case static_cast<uint64_t>(1000104002): return "VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT";
        case static_cast<uint64_t>(1000104003): return "VK_COLOR_SPACE_DISPLAY_P3_LINEAR_EXT";
        case static_cast<uint64_t>(1000104004): return "VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT";
        case static_cast<uint64_t>(1000104005): return "VK_COLOR_SPACE_BT709_LINEAR_EXT";
        case static_cast<uint64_t>(1000104006): return "VK_COLOR_SPACE_BT709_NONLINEAR_EXT";
        case static_cast<uint64_t>(1000104007): return "VK_COLOR_SPACE_BT2020_LINEAR_EXT";
        case static_cast<uint64_t>(1000104008): return "VK_COLOR_SPACE_HDR10_ST2084_EXT";
        case static_cast<uint64_t>(1000104009): return "VK_COLOR_SPACE_DOLBYVISION_EXT";
        case static_cast<uint64_t>(1000104010): return "VK_COLOR_SPACE_HDR10_HLG_EXT";
        case static_cast<uint64_t>(1000104011): return "VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT";
        case static_cast<uint64_t>(1000104012): return "VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT";
        case static_cast<uint64_t>(1000104013): return "VK_COLOR_SPACE_PASS_THROUGH_EXT";
        case static_cast<uint64_t>(1000104014): return "VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT";
        case static_cast<uint64_t>(1000213000): return "VK_COLOR_SPACE_DISPLAY_NATIVE_AMD";
        default: return "VkColorSpaceKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCommandBufferLevel>(VkCommandBufferLevel type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COMMAND_BUFFER_LEVEL_PRIMARY";
        case static_cast<uint64_t>(1): return "VK_COMMAND_BUFFER_LEVEL_SECONDARY";
        case static_cast<uint64_t>(2147483647): return "VK_COMMAND_BUFFER_LEVEL_MAX_ENUM";
        default: return "VkCommandBufferLevel_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCommandBufferResetFlagBits>(VkCommandBufferResetFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM";
        default: return "VkCommandBufferResetFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCommandBufferUsageFlagBits>(VkCommandBufferUsageFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT";
        case static_cast<uint64_t>(2): return "VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT";
        case static_cast<uint64_t>(4): return "VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM";
        default: return "VkCommandBufferUsageFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCommandPoolCreateFlagBits>(VkCommandPoolCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COMMAND_POOL_CREATE_TRANSIENT_BIT";
        case static_cast<uint64_t>(2): return "VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_COMMAND_POOL_CREATE_PROTECTED_BIT";
        default: return "VkCommandPoolCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCommandPoolResetFlagBits>(VkCommandPoolResetFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM";
        default: return "VkCommandPoolResetFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCompareOp>(VkCompareOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COMPARE_OP_NEVER";
        case static_cast<uint64_t>(1): return "VK_COMPARE_OP_LESS";
        case static_cast<uint64_t>(2): return "VK_COMPARE_OP_EQUAL";
        case static_cast<uint64_t>(3): return "VK_COMPARE_OP_LESS_OR_EQUAL";
        case static_cast<uint64_t>(4): return "VK_COMPARE_OP_GREATER";
        case static_cast<uint64_t>(5): return "VK_COMPARE_OP_NOT_EQUAL";
        case static_cast<uint64_t>(6): return "VK_COMPARE_OP_GREATER_OR_EQUAL";
        case static_cast<uint64_t>(7): return "VK_COMPARE_OP_ALWAYS";
        case static_cast<uint64_t>(2147483647): return "VK_COMPARE_OP_MAX_ENUM";
        default: return "VkCompareOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkComponentSwizzle>(VkComponentSwizzle type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COMPONENT_SWIZZLE_IDENTITY";
        case static_cast<uint64_t>(1): return "VK_COMPONENT_SWIZZLE_ZERO";
        case static_cast<uint64_t>(2): return "VK_COMPONENT_SWIZZLE_ONE";
        case static_cast<uint64_t>(3): return "VK_COMPONENT_SWIZZLE_R";
        case static_cast<uint64_t>(4): return "VK_COMPONENT_SWIZZLE_G";
        case static_cast<uint64_t>(5): return "VK_COMPONENT_SWIZZLE_B";
        case static_cast<uint64_t>(6): return "VK_COMPONENT_SWIZZLE_A";
        case static_cast<uint64_t>(2147483647): return "VK_COMPONENT_SWIZZLE_MAX_ENUM";
        default: return "VkComponentSwizzle_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkComponentTypeKHR>(VkComponentTypeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COMPONENT_TYPE_FLOAT16_KHR";
        case static_cast<uint64_t>(1): return "VK_COMPONENT_TYPE_FLOAT32_KHR";
        case static_cast<uint64_t>(2): return "VK_COMPONENT_TYPE_FLOAT64_KHR";
        case static_cast<uint64_t>(3): return "VK_COMPONENT_TYPE_SINT8_KHR";
        case static_cast<uint64_t>(4): return "VK_COMPONENT_TYPE_SINT16_KHR";
        case static_cast<uint64_t>(5): return "VK_COMPONENT_TYPE_SINT32_KHR";
        case static_cast<uint64_t>(6): return "VK_COMPONENT_TYPE_SINT64_KHR";
        case static_cast<uint64_t>(7): return "VK_COMPONENT_TYPE_UINT8_KHR";
        case static_cast<uint64_t>(8): return "VK_COMPONENT_TYPE_UINT16_KHR";
        case static_cast<uint64_t>(9): return "VK_COMPONENT_TYPE_UINT32_KHR";
        case static_cast<uint64_t>(10): return "VK_COMPONENT_TYPE_UINT64_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_COMPONENT_TYPE_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1000141000): return "VK_COMPONENT_TYPE_BFLOAT16_KHR";
        case static_cast<uint64_t>(1000491000): return "VK_COMPONENT_TYPE_SINT8_PACKED_NV";
        case static_cast<uint64_t>(1000491001): return "VK_COMPONENT_TYPE_UINT8_PACKED_NV";
        case static_cast<uint64_t>(1000491002): return "VK_COMPONENT_TYPE_FLOAT8_E4M3_EXT";
        case static_cast<uint64_t>(1000491003): return "VK_COMPONENT_TYPE_FLOAT8_E5M2_EXT";
        default: return "VkComponentTypeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCompositeAlphaFlagBitsKHR>(VkCompositeAlphaFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_COMPOSITE_ALPHA_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkCompositeAlphaFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkConditionalRenderingFlagBitsEXT>(VkConditionalRenderingFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_CONDITIONAL_RENDERING_INVERTED_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_CONDITIONAL_RENDERING_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkConditionalRenderingFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkConservativeRasterizationModeEXT>(VkConservativeRasterizationModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CONSERVATIVE_RASTERIZATION_MODE_DISABLED_EXT";
        case static_cast<uint64_t>(1): return "VK_CONSERVATIVE_RASTERIZATION_MODE_OVERESTIMATE_EXT";
        case static_cast<uint64_t>(2): return "VK_CONSERVATIVE_RASTERIZATION_MODE_UNDERESTIMATE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_CONSERVATIVE_RASTERIZATION_MODE_EXT_MAX_ENUM";
        default: return "VkConservativeRasterizationModeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCooperativeVectorMatrixLayoutNV>(VkCooperativeVectorMatrixLayoutNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_ROW_MAJOR_NV";
        case static_cast<uint64_t>(1): return "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_COLUMN_MAJOR_NV";
        case static_cast<uint64_t>(2): return "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_INFERENCING_OPTIMAL_NV";
        case static_cast<uint64_t>(3): return "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_TRAINING_OPTIMAL_NV";
        case static_cast<uint64_t>(2147483647): return "VK_COOPERATIVE_VECTOR_MATRIX_LAYOUT_NV_MAX_ENUM";
        default: return "VkCooperativeVectorMatrixLayoutNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCopyAccelerationStructureModeKHR>(VkCopyAccelerationStructureModeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COPY_ACCELERATION_STRUCTURE_MODE_CLONE_KHR";
        case static_cast<uint64_t>(1): return "VK_COPY_ACCELERATION_STRUCTURE_MODE_COMPACT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_COPY_ACCELERATION_STRUCTURE_MODE_KHR_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_COPY_ACCELERATION_STRUCTURE_MODE_SERIALIZE_KHR";
        case static_cast<uint64_t>(3): return "VK_COPY_ACCELERATION_STRUCTURE_MODE_DESERIALIZE_KHR";
        default: return "VkCopyAccelerationStructureModeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCopyMicromapModeEXT>(VkCopyMicromapModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COPY_MICROMAP_MODE_CLONE_EXT";
        case static_cast<uint64_t>(1): return "VK_COPY_MICROMAP_MODE_SERIALIZE_EXT";
        case static_cast<uint64_t>(2): return "VK_COPY_MICROMAP_MODE_DESERIALIZE_EXT";
        case static_cast<uint64_t>(3): return "VK_COPY_MICROMAP_MODE_COMPACT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_COPY_MICROMAP_MODE_EXT_MAX_ENUM";
        default: return "VkCopyMicromapModeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCoverageModulationModeNV>(VkCoverageModulationModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COVERAGE_MODULATION_MODE_NONE_NV";
        case static_cast<uint64_t>(1): return "VK_COVERAGE_MODULATION_MODE_RGB_NV";
        case static_cast<uint64_t>(2): return "VK_COVERAGE_MODULATION_MODE_ALPHA_NV";
        case static_cast<uint64_t>(3): return "VK_COVERAGE_MODULATION_MODE_RGBA_NV";
        case static_cast<uint64_t>(2147483647): return "VK_COVERAGE_MODULATION_MODE_NV_MAX_ENUM";
        default: return "VkCoverageModulationModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCoverageReductionModeNV>(VkCoverageReductionModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_COVERAGE_REDUCTION_MODE_MERGE_NV";
        case static_cast<uint64_t>(1): return "VK_COVERAGE_REDUCTION_MODE_TRUNCATE_NV";
        case static_cast<uint64_t>(2147483647): return "VK_COVERAGE_REDUCTION_MODE_NV_MAX_ENUM";
        default: return "VkCoverageReductionModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCubicFilterWeightsQCOM>(VkCubicFilterWeightsQCOM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CUBIC_FILTER_WEIGHTS_CATMULL_ROM_QCOM";
        case static_cast<uint64_t>(1): return "VK_CUBIC_FILTER_WEIGHTS_ZERO_TANGENT_CARDINAL_QCOM";
        case static_cast<uint64_t>(2): return "VK_CUBIC_FILTER_WEIGHTS_B_SPLINE_QCOM";
        case static_cast<uint64_t>(3): return "VK_CUBIC_FILTER_WEIGHTS_MITCHELL_NETRAVALI_QCOM";
        case static_cast<uint64_t>(2147483647): return "VK_CUBIC_FILTER_WEIGHTS_QCOM_MAX_ENUM";
        default: return "VkCubicFilterWeightsQCOM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkCullModeFlagBits>(VkCullModeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_CULL_MODE_NONE";
        case static_cast<uint64_t>(1): return "VK_CULL_MODE_FRONT_BIT";
        case static_cast<uint64_t>(2): return "VK_CULL_MODE_BACK_BIT";
        case static_cast<uint64_t>(3): return "VK_CULL_MODE_FRONT_AND_BACK";
        case static_cast<uint64_t>(2147483647): return "VK_CULL_MODE_FLAG_BITS_MAX_ENUM";
        default: return "VkCullModeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDataGraphPipelinePropertyARM>(VkDataGraphPipelinePropertyARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DATA_GRAPH_PIPELINE_PROPERTY_CREATION_LOG_ARM";
        case static_cast<uint64_t>(1): return "VK_DATA_GRAPH_PIPELINE_PROPERTY_IDENTIFIER_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_DATA_GRAPH_PIPELINE_PROPERTY_ARM_MAX_ENUM";
        default: return "VkDataGraphPipelinePropertyARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDataGraphPipelineSessionBindPointARM>(VkDataGraphPipelineSessionBindPointARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TRANSIENT_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_ARM_MAX_ENUM";
        default: return "VkDataGraphPipelineSessionBindPointARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDataGraphPipelineSessionBindPointTypeARM>(VkDataGraphPipelineSessionBindPointTypeARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_MEMORY_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_TYPE_ARM_MAX_ENUM";
        default: return "VkDataGraphPipelineSessionBindPointTypeARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDebugReportFlagBitsEXT>(VkDebugReportFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEBUG_REPORT_INFORMATION_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_DEBUG_REPORT_WARNING_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_DEBUG_REPORT_ERROR_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_DEBUG_REPORT_DEBUG_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEBUG_REPORT_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkDebugReportFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDebugReportObjectTypeEXT>(VkDebugReportObjectTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT";
        case static_cast<uint64_t>(1): return "VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT";
        case static_cast<uint64_t>(2): return "VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT";
        case static_cast<uint64_t>(3): return "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT";
        case static_cast<uint64_t>(4): return "VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT";
        case static_cast<uint64_t>(5): return "VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT";
        case static_cast<uint64_t>(6): return "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT";
        case static_cast<uint64_t>(7): return "VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT";
        case static_cast<uint64_t>(8): return "VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT";
        case static_cast<uint64_t>(9): return "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT";
        case static_cast<uint64_t>(10): return "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT";
        case static_cast<uint64_t>(11): return "VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT";
        case static_cast<uint64_t>(12): return "VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT";
        case static_cast<uint64_t>(13): return "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT";
        case static_cast<uint64_t>(14): return "VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT";
        case static_cast<uint64_t>(15): return "VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT";
        case static_cast<uint64_t>(16): return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT";
        case static_cast<uint64_t>(17): return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT";
        case static_cast<uint64_t>(18): return "VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT";
        case static_cast<uint64_t>(19): return "VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT";
        case static_cast<uint64_t>(20): return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT";
        case static_cast<uint64_t>(21): return "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT";
        case static_cast<uint64_t>(22): return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT";
        case static_cast<uint64_t>(23): return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT";
        case static_cast<uint64_t>(24): return "VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT";
        case static_cast<uint64_t>(25): return "VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT";
        case static_cast<uint64_t>(26): return "VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT";
        case static_cast<uint64_t>(27): return "VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT";
        case static_cast<uint64_t>(28): return "VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT";
        case static_cast<uint64_t>(29): return "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT";
        case static_cast<uint64_t>(30): return "VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT";
        case static_cast<uint64_t>(33): return "VK_DEBUG_REPORT_OBJECT_TYPE_VALIDATION_CACHE_EXT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEBUG_REPORT_OBJECT_TYPE_EXT_MAX_ENUM";
        case static_cast<uint64_t>(1000156000): return "VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION_EXT";
        case static_cast<uint64_t>(1000085000): return "VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_EXT";
        case static_cast<uint64_t>(1000165000): return "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV_EXT";
        case static_cast<uint64_t>(1000307000): return "VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_MODULE_NV_EXT";
        case static_cast<uint64_t>(1000307001): return "VK_DEBUG_REPORT_OBJECT_TYPE_CUDA_FUNCTION_NV_EXT";
        case static_cast<uint64_t>(1000366000): return "VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA_EXT";
        case static_cast<uint64_t>(1000150000): return "VK_DEBUG_REPORT_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR_EXT";
        default: return "VkDebugReportObjectTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDebugUtilsMessageSeverityFlagBitsEXT>(VkDebugUtilsMessageSeverityFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEBUG_UTILS_MESSAGE_SEVERITY_VERBOSE_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_DEBUG_UTILS_MESSAGE_SEVERITY_INFO_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_DEBUG_UTILS_MESSAGE_SEVERITY_WARNING_BIT_EXT";
        case static_cast<uint64_t>(4096): return "VK_DEBUG_UTILS_MESSAGE_SEVERITY_ERROR_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEBUG_UTILS_MESSAGE_SEVERITY_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkDebugUtilsMessageSeverityFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDebugUtilsMessageTypeFlagBitsEXT>(VkDebugUtilsMessageTypeFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEBUG_UTILS_MESSAGE_TYPE_GENERAL_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_DEBUG_UTILS_MESSAGE_TYPE_VALIDATION_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_DEBUG_UTILS_MESSAGE_TYPE_PERFORMANCE_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEBUG_UTILS_MESSAGE_TYPE_FLAG_BITS_EXT_MAX_ENUM";
        case static_cast<uint64_t>(8): return "VK_DEBUG_UTILS_MESSAGE_TYPE_DEVICE_ADDRESS_BINDING_BIT_EXT";
        default: return "VkDebugUtilsMessageTypeFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDefaultVertexAttributeValueKHR>(VkDefaultVertexAttributeValueKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ZERO_KHR";
        case static_cast<uint64_t>(1): return "VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_ZERO_ZERO_ZERO_ONE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_DEFAULT_VERTEX_ATTRIBUTE_VALUE_KHR_MAX_ENUM";
        default: return "VkDefaultVertexAttributeValueKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDependencyFlagBits>(VkDependencyFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEPENDENCY_BY_REGION_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_DEPENDENCY_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_DEPENDENCY_DEVICE_GROUP_BIT";
        case static_cast<uint64_t>(2): return "VK_DEPENDENCY_VIEW_LOCAL_BIT";
        case static_cast<uint64_t>(8): return "VK_DEPENDENCY_FEEDBACK_LOOP_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_DEPENDENCY_QUEUE_FAMILY_OWNERSHIP_TRANSFER_USE_ALL_STAGES_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_DEPENDENCY_ASYMMETRIC_EVENT_BIT_KHR";
        default: return "VkDependencyFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDepthBiasRepresentationEXT>(VkDepthBiasRepresentationEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORMAT_EXT";
        case static_cast<uint64_t>(1): return "VK_DEPTH_BIAS_REPRESENTATION_LEAST_REPRESENTABLE_VALUE_FORCE_UNORM_EXT";
        case static_cast<uint64_t>(2): return "VK_DEPTH_BIAS_REPRESENTATION_FLOAT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEPTH_BIAS_REPRESENTATION_EXT_MAX_ENUM";
        default: return "VkDepthBiasRepresentationEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDepthClampModeEXT>(VkDepthClampModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEPTH_CLAMP_MODE_VIEWPORT_RANGE_EXT";
        case static_cast<uint64_t>(1): return "VK_DEPTH_CLAMP_MODE_USER_DEFINED_RANGE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEPTH_CLAMP_MODE_EXT_MAX_ENUM";
        default: return "VkDepthClampModeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDescriptorBindingFlagBits>(VkDescriptorBindingFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DESCRIPTOR_BINDING_UPDATE_AFTER_BIND_BIT";
        case static_cast<uint64_t>(2): return "VK_DESCRIPTOR_BINDING_UPDATE_UNUSED_WHILE_PENDING_BIT";
        case static_cast<uint64_t>(4): return "VK_DESCRIPTOR_BINDING_PARTIALLY_BOUND_BIT";
        case static_cast<uint64_t>(8): return "VK_DESCRIPTOR_BINDING_VARIABLE_DESCRIPTOR_COUNT_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_DESCRIPTOR_BINDING_FLAG_BITS_MAX_ENUM";
        default: return "VkDescriptorBindingFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDescriptorPoolCreateFlagBits>(VkDescriptorPoolCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_DESCRIPTOR_POOL_CREATE_UPDATE_AFTER_BIND_BIT";
        case static_cast<uint64_t>(4): return "VK_DESCRIPTOR_POOL_CREATE_HOST_ONLY_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_SETS_BIT_NV";
        case static_cast<uint64_t>(16): return "VK_DESCRIPTOR_POOL_CREATE_ALLOW_OVERALLOCATION_POOLS_BIT_NV";
        default: return "VkDescriptorPoolCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDescriptorSetLayoutCreateFlagBits>(VkDescriptorSetLayoutCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_UPDATE_AFTER_BIND_POOL_BIT";
        case static_cast<uint64_t>(1): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT";
        case static_cast<uint64_t>(16): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_DESCRIPTOR_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_EMBEDDED_IMMUTABLE_SAMPLERS_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_INDIRECT_BINDABLE_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_HOST_ONLY_POOL_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_DESCRIPTOR_SET_LAYOUT_CREATE_PER_STAGE_BIT_NV";
        default: return "VkDescriptorSetLayoutCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDescriptorType>(VkDescriptorType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DESCRIPTOR_TYPE_SAMPLER";
        case static_cast<uint64_t>(1): return "VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER";
        case static_cast<uint64_t>(2): return "VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE";
        case static_cast<uint64_t>(3): return "VK_DESCRIPTOR_TYPE_STORAGE_IMAGE";
        case static_cast<uint64_t>(4): return "VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER";
        case static_cast<uint64_t>(5): return "VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER";
        case static_cast<uint64_t>(6): return "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER";
        case static_cast<uint64_t>(7): return "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER";
        case static_cast<uint64_t>(8): return "VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC";
        case static_cast<uint64_t>(9): return "VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC";
        case static_cast<uint64_t>(10): return "VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT";
        case static_cast<uint64_t>(2147483647): return "VK_DESCRIPTOR_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1000138000): return "VK_DESCRIPTOR_TYPE_INLINE_UNIFORM_BLOCK";
        case static_cast<uint64_t>(1000165000): return "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_NV";
        case static_cast<uint64_t>(1000440000): return "VK_DESCRIPTOR_TYPE_SAMPLE_WEIGHT_IMAGE_QCOM";
        case static_cast<uint64_t>(1000440001): return "VK_DESCRIPTOR_TYPE_BLOCK_MATCH_IMAGE_QCOM";
        case static_cast<uint64_t>(1000460000): return "VK_DESCRIPTOR_TYPE_TENSOR_ARM";
        case static_cast<uint64_t>(1000351000): return "VK_DESCRIPTOR_TYPE_MUTABLE_EXT";
        case static_cast<uint64_t>(1000570000): return "VK_DESCRIPTOR_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_NV";
        case static_cast<uint64_t>(1000150000): return "VK_DESCRIPTOR_TYPE_ACCELERATION_STRUCTURE_KHR";
        default: return "VkDescriptorType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDescriptorUpdateTemplateType>(VkDescriptorUpdateTemplateType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET";
        case static_cast<uint64_t>(2147483647): return "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS";
        default: return "VkDescriptorUpdateTemplateType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceAddressBindingFlagBitsEXT>(VkDeviceAddressBindingFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEVICE_ADDRESS_BINDING_INTERNAL_OBJECT_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_ADDRESS_BINDING_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkDeviceAddressBindingFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceAddressBindingTypeEXT>(VkDeviceAddressBindingTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEVICE_ADDRESS_BINDING_TYPE_BIND_EXT";
        case static_cast<uint64_t>(1): return "VK_DEVICE_ADDRESS_BINDING_TYPE_UNBIND_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_ADDRESS_BINDING_TYPE_EXT_MAX_ENUM";
        default: return "VkDeviceAddressBindingTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceDiagnosticsConfigFlagBitsNV>(VkDeviceDiagnosticsConfigFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_DEBUG_INFO_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_RESOURCE_TRACKING_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_AUTOMATIC_CHECKPOINTS_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_DEVICE_DIAGNOSTICS_CONFIG_ENABLE_SHADER_ERROR_REPORTING_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_DIAGNOSTICS_CONFIG_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkDeviceDiagnosticsConfigFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceEventTypeEXT>(VkDeviceEventTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_EVENT_TYPE_EXT_MAX_ENUM";
        default: return "VkDeviceEventTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceFaultAddressTypeEXT>(VkDeviceFaultAddressTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEVICE_FAULT_ADDRESS_TYPE_NONE_EXT";
        case static_cast<uint64_t>(1): return "VK_DEVICE_FAULT_ADDRESS_TYPE_READ_INVALID_EXT";
        case static_cast<uint64_t>(2): return "VK_DEVICE_FAULT_ADDRESS_TYPE_WRITE_INVALID_EXT";
        case static_cast<uint64_t>(3): return "VK_DEVICE_FAULT_ADDRESS_TYPE_EXECUTE_INVALID_EXT";
        case static_cast<uint64_t>(4): return "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_UNKNOWN_EXT";
        case static_cast<uint64_t>(5): return "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_INVALID_EXT";
        case static_cast<uint64_t>(6): return "VK_DEVICE_FAULT_ADDRESS_TYPE_INSTRUCTION_POINTER_FAULT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_FAULT_ADDRESS_TYPE_EXT_MAX_ENUM";
        default: return "VkDeviceFaultAddressTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceFaultVendorBinaryHeaderVersionEXT>(VkDeviceFaultVendorBinaryHeaderVersionEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_ONE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_FAULT_VENDOR_BINARY_HEADER_VERSION_EXT_MAX_ENUM";
        default: return "VkDeviceFaultVendorBinaryHeaderVersionEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceGroupPresentModeFlagBitsKHR>(VkDeviceGroupPresentModeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkDeviceGroupPresentModeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceMemoryReportEventTypeEXT>(VkDeviceMemoryReportEventTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATE_EXT";
        case static_cast<uint64_t>(1): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_FREE_EXT";
        case static_cast<uint64_t>(2): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_IMPORT_EXT";
        case static_cast<uint64_t>(3): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_UNIMPORT_EXT";
        case static_cast<uint64_t>(4): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_ALLOCATION_FAILED_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_MEMORY_REPORT_EVENT_TYPE_EXT_MAX_ENUM";
        default: return "VkDeviceMemoryReportEventTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDeviceQueueCreateFlagBits>(VkDeviceQueueCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_DEVICE_QUEUE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_DEVICE_QUEUE_CREATE_PROTECTED_BIT";
        default: return "VkDeviceQueueCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDirectDriverLoadingModeLUNARG>(VkDirectDriverLoadingModeLUNARG type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DIRECT_DRIVER_LOADING_MODE_EXCLUSIVE_LUNARG";
        case static_cast<uint64_t>(1): return "VK_DIRECT_DRIVER_LOADING_MODE_INCLUSIVE_LUNARG";
        case static_cast<uint64_t>(2147483647): return "VK_DIRECT_DRIVER_LOADING_MODE_LUNARG_MAX_ENUM";
        default: return "VkDirectDriverLoadingModeLUNARG_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDiscardRectangleModeEXT>(VkDiscardRectangleModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT";
        case static_cast<uint64_t>(1): return "VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DISCARD_RECTANGLE_MODE_EXT_MAX_ENUM";
        default: return "VkDiscardRectangleModeEXT_UNKNOWN";
      }
    }

#ifdef VK_ENABLE_BETA_EXTENSIONS
    template <> constexpr const char* enumString<VkDisplacementMicromapFormatNV>(VkDisplacementMicromapFormatNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DISPLACEMENT_MICROMAP_FORMAT_64_TRIANGLES_64_BYTES_NV";
        case static_cast<uint64_t>(2): return "VK_DISPLACEMENT_MICROMAP_FORMAT_256_TRIANGLES_128_BYTES_NV";
        case static_cast<uint64_t>(3): return "VK_DISPLACEMENT_MICROMAP_FORMAT_1024_TRIANGLES_128_BYTES_NV";
        case static_cast<uint64_t>(2147483647): return "VK_DISPLACEMENT_MICROMAP_FORMAT_NV_MAX_ENUM";
        default: return "VkDisplacementMicromapFormatNV_UNKNOWN";
      }
    }
#endif

    template <> constexpr const char* enumString<VkDisplayEventTypeEXT>(VkDisplayEventTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DISPLAY_EVENT_TYPE_EXT_MAX_ENUM";
        default: return "VkDisplayEventTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDisplayPlaneAlphaFlagBitsKHR>(VkDisplayPlaneAlphaFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkDisplayPlaneAlphaFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDisplayPowerStateEXT>(VkDisplayPowerStateEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DISPLAY_POWER_STATE_OFF_EXT";
        case static_cast<uint64_t>(1): return "VK_DISPLAY_POWER_STATE_SUSPEND_EXT";
        case static_cast<uint64_t>(2): return "VK_DISPLAY_POWER_STATE_ON_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_DISPLAY_POWER_STATE_EXT_MAX_ENUM";
        default: return "VkDisplayPowerStateEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDisplaySurfaceStereoTypeNV>(VkDisplaySurfaceStereoTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DISPLAY_SURFACE_STEREO_TYPE_NONE_NV";
        case static_cast<uint64_t>(1): return "VK_DISPLAY_SURFACE_STEREO_TYPE_ONBOARD_DIN_NV";
        case static_cast<uint64_t>(2): return "VK_DISPLAY_SURFACE_STEREO_TYPE_HDMI_3D_NV";
        case static_cast<uint64_t>(3): return "VK_DISPLAY_SURFACE_STEREO_TYPE_INBAND_DISPLAYPORT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_DISPLAY_SURFACE_STEREO_TYPE_NV_MAX_ENUM";
        default: return "VkDisplaySurfaceStereoTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDriverId>(VkDriverId type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_DRIVER_ID_AMD_PROPRIETARY";
        case static_cast<uint64_t>(2): return "VK_DRIVER_ID_AMD_OPEN_SOURCE";
        case static_cast<uint64_t>(3): return "VK_DRIVER_ID_MESA_RADV";
        case static_cast<uint64_t>(4): return "VK_DRIVER_ID_NVIDIA_PROPRIETARY";
        case static_cast<uint64_t>(5): return "VK_DRIVER_ID_INTEL_PROPRIETARY_WINDOWS";
        case static_cast<uint64_t>(6): return "VK_DRIVER_ID_INTEL_OPEN_SOURCE_MESA";
        case static_cast<uint64_t>(7): return "VK_DRIVER_ID_IMAGINATION_PROPRIETARY";
        case static_cast<uint64_t>(8): return "VK_DRIVER_ID_QUALCOMM_PROPRIETARY";
        case static_cast<uint64_t>(9): return "VK_DRIVER_ID_ARM_PROPRIETARY";
        case static_cast<uint64_t>(10): return "VK_DRIVER_ID_GOOGLE_SWIFTSHADER";
        case static_cast<uint64_t>(11): return "VK_DRIVER_ID_GGP_PROPRIETARY";
        case static_cast<uint64_t>(12): return "VK_DRIVER_ID_BROADCOM_PROPRIETARY";
        case static_cast<uint64_t>(13): return "VK_DRIVER_ID_MESA_LLVMPIPE";
        case static_cast<uint64_t>(14): return "VK_DRIVER_ID_MOLTENVK";
        case static_cast<uint64_t>(15): return "VK_DRIVER_ID_COREAVI_PROPRIETARY";
        case static_cast<uint64_t>(16): return "VK_DRIVER_ID_JUICE_PROPRIETARY";
        case static_cast<uint64_t>(17): return "VK_DRIVER_ID_VERISILICON_PROPRIETARY";
        case static_cast<uint64_t>(18): return "VK_DRIVER_ID_MESA_TURNIP";
        case static_cast<uint64_t>(19): return "VK_DRIVER_ID_MESA_V3DV";
        case static_cast<uint64_t>(20): return "VK_DRIVER_ID_MESA_PANVK";
        case static_cast<uint64_t>(21): return "VK_DRIVER_ID_SAMSUNG_PROPRIETARY";
        case static_cast<uint64_t>(22): return "VK_DRIVER_ID_MESA_VENUS";
        case static_cast<uint64_t>(23): return "VK_DRIVER_ID_MESA_DOZEN";
        case static_cast<uint64_t>(24): return "VK_DRIVER_ID_MESA_NVK";
        case static_cast<uint64_t>(25): return "VK_DRIVER_ID_IMAGINATION_OPEN_SOURCE_MESA";
        case static_cast<uint64_t>(26): return "VK_DRIVER_ID_MESA_HONEYKRISP";
        case static_cast<uint64_t>(27): return "VK_DRIVER_ID_VULKAN_SC_EMULATION_ON_VULKAN";
        case static_cast<uint64_t>(2147483647): return "VK_DRIVER_ID_MAX_ENUM";
        default: return "VkDriverId_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkDynamicState>(VkDynamicState type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_DYNAMIC_STATE_VIEWPORT";
        case static_cast<uint64_t>(1): return "VK_DYNAMIC_STATE_SCISSOR";
        case static_cast<uint64_t>(2): return "VK_DYNAMIC_STATE_LINE_WIDTH";
        case static_cast<uint64_t>(3): return "VK_DYNAMIC_STATE_DEPTH_BIAS";
        case static_cast<uint64_t>(4): return "VK_DYNAMIC_STATE_BLEND_CONSTANTS";
        case static_cast<uint64_t>(5): return "VK_DYNAMIC_STATE_DEPTH_BOUNDS";
        case static_cast<uint64_t>(6): return "VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK";
        case static_cast<uint64_t>(7): return "VK_DYNAMIC_STATE_STENCIL_WRITE_MASK";
        case static_cast<uint64_t>(8): return "VK_DYNAMIC_STATE_STENCIL_REFERENCE";
        case static_cast<uint64_t>(2147483647): return "VK_DYNAMIC_STATE_MAX_ENUM";
        case static_cast<uint64_t>(1000267000): return "VK_DYNAMIC_STATE_CULL_MODE";
        case static_cast<uint64_t>(1000267001): return "VK_DYNAMIC_STATE_FRONT_FACE";
        case static_cast<uint64_t>(1000267002): return "VK_DYNAMIC_STATE_PRIMITIVE_TOPOLOGY";
        case static_cast<uint64_t>(1000267003): return "VK_DYNAMIC_STATE_VIEWPORT_WITH_COUNT";
        case static_cast<uint64_t>(1000267004): return "VK_DYNAMIC_STATE_SCISSOR_WITH_COUNT";
        case static_cast<uint64_t>(1000267005): return "VK_DYNAMIC_STATE_VERTEX_INPUT_BINDING_STRIDE";
        case static_cast<uint64_t>(1000267006): return "VK_DYNAMIC_STATE_DEPTH_TEST_ENABLE";
        case static_cast<uint64_t>(1000267007): return "VK_DYNAMIC_STATE_DEPTH_WRITE_ENABLE";
        case static_cast<uint64_t>(1000267008): return "VK_DYNAMIC_STATE_DEPTH_COMPARE_OP";
        case static_cast<uint64_t>(1000267009): return "VK_DYNAMIC_STATE_DEPTH_BOUNDS_TEST_ENABLE";
        case static_cast<uint64_t>(1000267010): return "VK_DYNAMIC_STATE_STENCIL_TEST_ENABLE";
        case static_cast<uint64_t>(1000267011): return "VK_DYNAMIC_STATE_STENCIL_OP";
        case static_cast<uint64_t>(1000377001): return "VK_DYNAMIC_STATE_RASTERIZER_DISCARD_ENABLE";
        case static_cast<uint64_t>(1000377002): return "VK_DYNAMIC_STATE_DEPTH_BIAS_ENABLE";
        case static_cast<uint64_t>(1000377004): return "VK_DYNAMIC_STATE_PRIMITIVE_RESTART_ENABLE";
        case static_cast<uint64_t>(1000259000): return "VK_DYNAMIC_STATE_LINE_STIPPLE";
        case static_cast<uint64_t>(1000087000): return "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV";
        case static_cast<uint64_t>(1000099000): return "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT";
        case static_cast<uint64_t>(1000099001): return "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_ENABLE_EXT";
        case static_cast<uint64_t>(1000099002): return "VK_DYNAMIC_STATE_DISCARD_RECTANGLE_MODE_EXT";
        case static_cast<uint64_t>(1000143000): return "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_EXT";
        case static_cast<uint64_t>(1000164004): return "VK_DYNAMIC_STATE_VIEWPORT_SHADING_RATE_PALETTE_NV";
        case static_cast<uint64_t>(1000164006): return "VK_DYNAMIC_STATE_VIEWPORT_COARSE_SAMPLE_ORDER_NV";
        case static_cast<uint64_t>(1000205000): return "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_ENABLE_NV";
        case static_cast<uint64_t>(1000205001): return "VK_DYNAMIC_STATE_EXCLUSIVE_SCISSOR_NV";
        case static_cast<uint64_t>(1000226000): return "VK_DYNAMIC_STATE_FRAGMENT_SHADING_RATE_KHR";
        case static_cast<uint64_t>(1000352000): return "VK_DYNAMIC_STATE_VERTEX_INPUT_EXT";
        case static_cast<uint64_t>(1000377000): return "VK_DYNAMIC_STATE_PATCH_CONTROL_POINTS_EXT";
        case static_cast<uint64_t>(1000377003): return "VK_DYNAMIC_STATE_LOGIC_OP_EXT";
        case static_cast<uint64_t>(1000381000): return "VK_DYNAMIC_STATE_COLOR_WRITE_ENABLE_EXT";
        case static_cast<uint64_t>(1000455003): return "VK_DYNAMIC_STATE_DEPTH_CLAMP_ENABLE_EXT";
        case static_cast<uint64_t>(1000455004): return "VK_DYNAMIC_STATE_POLYGON_MODE_EXT";
        case static_cast<uint64_t>(1000455005): return "VK_DYNAMIC_STATE_RASTERIZATION_SAMPLES_EXT";
        case static_cast<uint64_t>(1000455006): return "VK_DYNAMIC_STATE_SAMPLE_MASK_EXT";
        case static_cast<uint64_t>(1000455007): return "VK_DYNAMIC_STATE_ALPHA_TO_COVERAGE_ENABLE_EXT";
        case static_cast<uint64_t>(1000455008): return "VK_DYNAMIC_STATE_ALPHA_TO_ONE_ENABLE_EXT";
        case static_cast<uint64_t>(1000455009): return "VK_DYNAMIC_STATE_LOGIC_OP_ENABLE_EXT";
        case static_cast<uint64_t>(1000455010): return "VK_DYNAMIC_STATE_COLOR_BLEND_ENABLE_EXT";
        case static_cast<uint64_t>(1000455011): return "VK_DYNAMIC_STATE_COLOR_BLEND_EQUATION_EXT";
        case static_cast<uint64_t>(1000455012): return "VK_DYNAMIC_STATE_COLOR_WRITE_MASK_EXT";
        case static_cast<uint64_t>(1000455002): return "VK_DYNAMIC_STATE_TESSELLATION_DOMAIN_ORIGIN_EXT";
        case static_cast<uint64_t>(1000455013): return "VK_DYNAMIC_STATE_RASTERIZATION_STREAM_EXT";
        case static_cast<uint64_t>(1000455014): return "VK_DYNAMIC_STATE_CONSERVATIVE_RASTERIZATION_MODE_EXT";
        case static_cast<uint64_t>(1000455015): return "VK_DYNAMIC_STATE_EXTRA_PRIMITIVE_OVERESTIMATION_SIZE_EXT";
        case static_cast<uint64_t>(1000455016): return "VK_DYNAMIC_STATE_DEPTH_CLIP_ENABLE_EXT";
        case static_cast<uint64_t>(1000455017): return "VK_DYNAMIC_STATE_SAMPLE_LOCATIONS_ENABLE_EXT";
        case static_cast<uint64_t>(1000455018): return "VK_DYNAMIC_STATE_COLOR_BLEND_ADVANCED_EXT";
        case static_cast<uint64_t>(1000455019): return "VK_DYNAMIC_STATE_PROVOKING_VERTEX_MODE_EXT";
        case static_cast<uint64_t>(1000455020): return "VK_DYNAMIC_STATE_LINE_RASTERIZATION_MODE_EXT";
        case static_cast<uint64_t>(1000455021): return "VK_DYNAMIC_STATE_LINE_STIPPLE_ENABLE_EXT";
        case static_cast<uint64_t>(1000455022): return "VK_DYNAMIC_STATE_DEPTH_CLIP_NEGATIVE_ONE_TO_ONE_EXT";
        case static_cast<uint64_t>(1000455023): return "VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_ENABLE_NV";
        case static_cast<uint64_t>(1000455024): return "VK_DYNAMIC_STATE_VIEWPORT_SWIZZLE_NV";
        case static_cast<uint64_t>(1000455025): return "VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_ENABLE_NV";
        case static_cast<uint64_t>(1000455026): return "VK_DYNAMIC_STATE_COVERAGE_TO_COLOR_LOCATION_NV";
        case static_cast<uint64_t>(1000455027): return "VK_DYNAMIC_STATE_COVERAGE_MODULATION_MODE_NV";
        case static_cast<uint64_t>(1000455028): return "VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_ENABLE_NV";
        case static_cast<uint64_t>(1000455029): return "VK_DYNAMIC_STATE_COVERAGE_MODULATION_TABLE_NV";
        case static_cast<uint64_t>(1000455030): return "VK_DYNAMIC_STATE_SHADING_RATE_IMAGE_ENABLE_NV";
        case static_cast<uint64_t>(1000455031): return "VK_DYNAMIC_STATE_REPRESENTATIVE_FRAGMENT_TEST_ENABLE_NV";
        case static_cast<uint64_t>(1000455032): return "VK_DYNAMIC_STATE_COVERAGE_REDUCTION_MODE_NV";
        case static_cast<uint64_t>(1000524000): return "VK_DYNAMIC_STATE_ATTACHMENT_FEEDBACK_LOOP_ENABLE_EXT";
        case static_cast<uint64_t>(1000582000): return "VK_DYNAMIC_STATE_DEPTH_CLAMP_RANGE_EXT";
        case static_cast<uint64_t>(1000347000): return "VK_DYNAMIC_STATE_RAY_TRACING_PIPELINE_STACK_SIZE_KHR";
        default: return "VkDynamicState_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkEventCreateFlagBits>(VkEventCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_EVENT_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_EVENT_CREATE_DEVICE_ONLY_BIT";
        default: return "VkEventCreateFlagBits_UNKNOWN";
      }
    }

#ifdef VK_USE_PLATFORM_METAL_EXT
    template <> constexpr const char* enumString<VkExportMetalObjectTypeFlagBitsEXT>(VkExportMetalObjectTypeFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_DEVICE_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_COMMAND_QUEUE_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_TEXTURE_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_IOSURFACE_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_EXPORT_METAL_OBJECT_TYPE_METAL_SHARED_EVENT_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_EXPORT_METAL_OBJECT_TYPE_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkExportMetalObjectTypeFlagBitsEXT_UNKNOWN";
      }
    }
#endif

    template <> constexpr const char* enumString<VkExternalFenceFeatureFlagBits>(VkExternalFenceFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM";
        default: return "VkExternalFenceFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalFenceHandleTypeFlagBits>(VkExternalFenceHandleTypeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        case static_cast<uint64_t>(8): return "VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM";
        default: return "VkExternalFenceHandleTypeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalMemoryFeatureFlagBits>(VkExternalMemoryFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM";
        default: return "VkExternalMemoryFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalMemoryFeatureFlagBitsNV>(VkExternalMemoryFeatureFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkExternalMemoryFeatureFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalMemoryHandleTypeFlagBits>(VkExternalMemoryHandleTypeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        case static_cast<uint64_t>(8): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT";
        case static_cast<uint64_t>(16): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT";
        case static_cast<uint64_t>(32): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT";
        case static_cast<uint64_t>(64): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(512): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_DMA_BUF_BIT_EXT";
        case static_cast<uint64_t>(1024): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ANDROID_HARDWARE_BUFFER_BIT_ANDROID";
        case static_cast<uint64_t>(128): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_ALLOCATION_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_HOST_MAPPED_FOREIGN_MEMORY_BIT_EXT";
        case static_cast<uint64_t>(2048): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_ZIRCON_VMO_BIT_FUCHSIA";
        case static_cast<uint64_t>(4096): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_RDMA_ADDRESS_BIT_NV";
        case static_cast<uint64_t>(16384): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_SCREEN_BUFFER_BIT_QNX";
        case static_cast<uint64_t>(65536): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLBUFFER_BIT_EXT";
        case static_cast<uint64_t>(131072): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLTEXTURE_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_MTLHEAP_BIT_EXT";
        default: return "VkExternalMemoryHandleTypeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalMemoryHandleTypeFlagBitsNV>(VkExternalMemoryHandleTypeFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkExternalMemoryHandleTypeFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalSemaphoreFeatureFlagBits>(VkExternalSemaphoreFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM";
        default: return "VkExternalSemaphoreFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkExternalSemaphoreHandleTypeFlagBits>(VkExternalSemaphoreHandleTypeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT";
        case static_cast<uint64_t>(2): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT";
        case static_cast<uint64_t>(4): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT";
        case static_cast<uint64_t>(8): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT";
        case static_cast<uint64_t>(16): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(128): return "VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_ZIRCON_EVENT_BIT_FUCHSIA";
        default: return "VkExternalSemaphoreHandleTypeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFenceCreateFlagBits>(VkFenceCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_FENCE_CREATE_SIGNALED_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM";
        default: return "VkFenceCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFenceImportFlagBits>(VkFenceImportFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_FENCE_IMPORT_TEMPORARY_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM";
        default: return "VkFenceImportFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFilter>(VkFilter type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FILTER_NEAREST";
        case static_cast<uint64_t>(1): return "VK_FILTER_LINEAR";
        case static_cast<uint64_t>(2147483647): return "VK_FILTER_MAX_ENUM";
        case static_cast<uint64_t>(1000015000): return "VK_FILTER_CUBIC_EXT";
        default: return "VkFilter_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFormat>(VkFormat type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FORMAT_UNDEFINED";
        case static_cast<uint64_t>(1): return "VK_FORMAT_R4G4_UNORM_PACK8";
        case static_cast<uint64_t>(2): return "VK_FORMAT_R4G4B4A4_UNORM_PACK16";
        case static_cast<uint64_t>(3): return "VK_FORMAT_B4G4R4A4_UNORM_PACK16";
        case static_cast<uint64_t>(4): return "VK_FORMAT_R5G6B5_UNORM_PACK16";
        case static_cast<uint64_t>(5): return "VK_FORMAT_B5G6R5_UNORM_PACK16";
        case static_cast<uint64_t>(6): return "VK_FORMAT_R5G5B5A1_UNORM_PACK16";
        case static_cast<uint64_t>(7): return "VK_FORMAT_B5G5R5A1_UNORM_PACK16";
        case static_cast<uint64_t>(8): return "VK_FORMAT_A1R5G5B5_UNORM_PACK16";
        case static_cast<uint64_t>(9): return "VK_FORMAT_R8_UNORM";
        case static_cast<uint64_t>(10): return "VK_FORMAT_R8_SNORM";
        case static_cast<uint64_t>(11): return "VK_FORMAT_R8_USCALED";
        case static_cast<uint64_t>(12): return "VK_FORMAT_R8_SSCALED";
        case static_cast<uint64_t>(13): return "VK_FORMAT_R8_UINT";
        case static_cast<uint64_t>(14): return "VK_FORMAT_R8_SINT";
        case static_cast<uint64_t>(15): return "VK_FORMAT_R8_SRGB";
        case static_cast<uint64_t>(16): return "VK_FORMAT_R8G8_UNORM";
        case static_cast<uint64_t>(17): return "VK_FORMAT_R8G8_SNORM";
        case static_cast<uint64_t>(18): return "VK_FORMAT_R8G8_USCALED";
        case static_cast<uint64_t>(19): return "VK_FORMAT_R8G8_SSCALED";
        case static_cast<uint64_t>(20): return "VK_FORMAT_R8G8_UINT";
        case static_cast<uint64_t>(21): return "VK_FORMAT_R8G8_SINT";
        case static_cast<uint64_t>(22): return "VK_FORMAT_R8G8_SRGB";
        case static_cast<uint64_t>(23): return "VK_FORMAT_R8G8B8_UNORM";
        case static_cast<uint64_t>(24): return "VK_FORMAT_R8G8B8_SNORM";
        case static_cast<uint64_t>(25): return "VK_FORMAT_R8G8B8_USCALED";
        case static_cast<uint64_t>(26): return "VK_FORMAT_R8G8B8_SSCALED";
        case static_cast<uint64_t>(27): return "VK_FORMAT_R8G8B8_UINT";
        case static_cast<uint64_t>(28): return "VK_FORMAT_R8G8B8_SINT";
        case static_cast<uint64_t>(29): return "VK_FORMAT_R8G8B8_SRGB";
        case static_cast<uint64_t>(30): return "VK_FORMAT_B8G8R8_UNORM";
        case static_cast<uint64_t>(31): return "VK_FORMAT_B8G8R8_SNORM";
        case static_cast<uint64_t>(32): return "VK_FORMAT_B8G8R8_USCALED";
        case static_cast<uint64_t>(33): return "VK_FORMAT_B8G8R8_SSCALED";
        case static_cast<uint64_t>(34): return "VK_FORMAT_B8G8R8_UINT";
        case static_cast<uint64_t>(35): return "VK_FORMAT_B8G8R8_SINT";
        case static_cast<uint64_t>(36): return "VK_FORMAT_B8G8R8_SRGB";
        case static_cast<uint64_t>(37): return "VK_FORMAT_R8G8B8A8_UNORM";
        case static_cast<uint64_t>(38): return "VK_FORMAT_R8G8B8A8_SNORM";
        case static_cast<uint64_t>(39): return "VK_FORMAT_R8G8B8A8_USCALED";
        case static_cast<uint64_t>(40): return "VK_FORMAT_R8G8B8A8_SSCALED";
        case static_cast<uint64_t>(41): return "VK_FORMAT_R8G8B8A8_UINT";
        case static_cast<uint64_t>(42): return "VK_FORMAT_R8G8B8A8_SINT";
        case static_cast<uint64_t>(43): return "VK_FORMAT_R8G8B8A8_SRGB";
        case static_cast<uint64_t>(44): return "VK_FORMAT_B8G8R8A8_UNORM";
        case static_cast<uint64_t>(45): return "VK_FORMAT_B8G8R8A8_SNORM";
        case static_cast<uint64_t>(46): return "VK_FORMAT_B8G8R8A8_USCALED";
        case static_cast<uint64_t>(47): return "VK_FORMAT_B8G8R8A8_SSCALED";
        case static_cast<uint64_t>(48): return "VK_FORMAT_B8G8R8A8_UINT";
        case static_cast<uint64_t>(49): return "VK_FORMAT_B8G8R8A8_SINT";
        case static_cast<uint64_t>(50): return "VK_FORMAT_B8G8R8A8_SRGB";
        case static_cast<uint64_t>(51): return "VK_FORMAT_A8B8G8R8_UNORM_PACK32";
        case static_cast<uint64_t>(52): return "VK_FORMAT_A8B8G8R8_SNORM_PACK32";
        case static_cast<uint64_t>(53): return "VK_FORMAT_A8B8G8R8_USCALED_PACK32";
        case static_cast<uint64_t>(54): return "VK_FORMAT_A8B8G8R8_SSCALED_PACK32";
        case static_cast<uint64_t>(55): return "VK_FORMAT_A8B8G8R8_UINT_PACK32";
        case static_cast<uint64_t>(56): return "VK_FORMAT_A8B8G8R8_SINT_PACK32";
        case static_cast<uint64_t>(57): return "VK_FORMAT_A8B8G8R8_SRGB_PACK32";
        case static_cast<uint64_t>(58): return "VK_FORMAT_A2R10G10B10_UNORM_PACK32";
        case static_cast<uint64_t>(59): return "VK_FORMAT_A2R10G10B10_SNORM_PACK32";
        case static_cast<uint64_t>(60): return "VK_FORMAT_A2R10G10B10_USCALED_PACK32";
        case static_cast<uint64_t>(61): return "VK_FORMAT_A2R10G10B10_SSCALED_PACK32";
        case static_cast<uint64_t>(62): return "VK_FORMAT_A2R10G10B10_UINT_PACK32";
        case static_cast<uint64_t>(63): return "VK_FORMAT_A2R10G10B10_SINT_PACK32";
        case static_cast<uint64_t>(64): return "VK_FORMAT_A2B10G10R10_UNORM_PACK32";
        case static_cast<uint64_t>(65): return "VK_FORMAT_A2B10G10R10_SNORM_PACK32";
        case static_cast<uint64_t>(66): return "VK_FORMAT_A2B10G10R10_USCALED_PACK32";
        case static_cast<uint64_t>(67): return "VK_FORMAT_A2B10G10R10_SSCALED_PACK32";
        case static_cast<uint64_t>(68): return "VK_FORMAT_A2B10G10R10_UINT_PACK32";
        case static_cast<uint64_t>(69): return "VK_FORMAT_A2B10G10R10_SINT_PACK32";
        case static_cast<uint64_t>(70): return "VK_FORMAT_R16_UNORM";
        case static_cast<uint64_t>(71): return "VK_FORMAT_R16_SNORM";
        case static_cast<uint64_t>(72): return "VK_FORMAT_R16_USCALED";
        case static_cast<uint64_t>(73): return "VK_FORMAT_R16_SSCALED";
        case static_cast<uint64_t>(74): return "VK_FORMAT_R16_UINT";
        case static_cast<uint64_t>(75): return "VK_FORMAT_R16_SINT";
        case static_cast<uint64_t>(76): return "VK_FORMAT_R16_SFLOAT";
        case static_cast<uint64_t>(77): return "VK_FORMAT_R16G16_UNORM";
        case static_cast<uint64_t>(78): return "VK_FORMAT_R16G16_SNORM";
        case static_cast<uint64_t>(79): return "VK_FORMAT_R16G16_USCALED";
        case static_cast<uint64_t>(80): return "VK_FORMAT_R16G16_SSCALED";
        case static_cast<uint64_t>(81): return "VK_FORMAT_R16G16_UINT";
        case static_cast<uint64_t>(82): return "VK_FORMAT_R16G16_SINT";
        case static_cast<uint64_t>(83): return "VK_FORMAT_R16G16_SFLOAT";
        case static_cast<uint64_t>(84): return "VK_FORMAT_R16G16B16_UNORM";
        case static_cast<uint64_t>(85): return "VK_FORMAT_R16G16B16_SNORM";
        case static_cast<uint64_t>(86): return "VK_FORMAT_R16G16B16_USCALED";
        case static_cast<uint64_t>(87): return "VK_FORMAT_R16G16B16_SSCALED";
        case static_cast<uint64_t>(88): return "VK_FORMAT_R16G16B16_UINT";
        case static_cast<uint64_t>(89): return "VK_FORMAT_R16G16B16_SINT";
        case static_cast<uint64_t>(90): return "VK_FORMAT_R16G16B16_SFLOAT";
        case static_cast<uint64_t>(91): return "VK_FORMAT_R16G16B16A16_UNORM";
        case static_cast<uint64_t>(92): return "VK_FORMAT_R16G16B16A16_SNORM";
        case static_cast<uint64_t>(93): return "VK_FORMAT_R16G16B16A16_USCALED";
        case static_cast<uint64_t>(94): return "VK_FORMAT_R16G16B16A16_SSCALED";
        case static_cast<uint64_t>(95): return "VK_FORMAT_R16G16B16A16_UINT";
        case static_cast<uint64_t>(96): return "VK_FORMAT_R16G16B16A16_SINT";
        case static_cast<uint64_t>(97): return "VK_FORMAT_R16G16B16A16_SFLOAT";
        case static_cast<uint64_t>(98): return "VK_FORMAT_R32_UINT";
        case static_cast<uint64_t>(99): return "VK_FORMAT_R32_SINT";
        case static_cast<uint64_t>(100): return "VK_FORMAT_R32_SFLOAT";
        case static_cast<uint64_t>(101): return "VK_FORMAT_R32G32_UINT";
        case static_cast<uint64_t>(102): return "VK_FORMAT_R32G32_SINT";
        case static_cast<uint64_t>(103): return "VK_FORMAT_R32G32_SFLOAT";
        case static_cast<uint64_t>(104): return "VK_FORMAT_R32G32B32_UINT";
        case static_cast<uint64_t>(105): return "VK_FORMAT_R32G32B32_SINT";
        case static_cast<uint64_t>(106): return "VK_FORMAT_R32G32B32_SFLOAT";
        case static_cast<uint64_t>(107): return "VK_FORMAT_R32G32B32A32_UINT";
        case static_cast<uint64_t>(108): return "VK_FORMAT_R32G32B32A32_SINT";
        case static_cast<uint64_t>(109): return "VK_FORMAT_R32G32B32A32_SFLOAT";
        case static_cast<uint64_t>(110): return "VK_FORMAT_R64_UINT";
        case static_cast<uint64_t>(111): return "VK_FORMAT_R64_SINT";
        case static_cast<uint64_t>(112): return "VK_FORMAT_R64_SFLOAT";
        case static_cast<uint64_t>(113): return "VK_FORMAT_R64G64_UINT";
        case static_cast<uint64_t>(114): return "VK_FORMAT_R64G64_SINT";
        case static_cast<uint64_t>(115): return "VK_FORMAT_R64G64_SFLOAT";
        case static_cast<uint64_t>(116): return "VK_FORMAT_R64G64B64_UINT";
        case static_cast<uint64_t>(117): return "VK_FORMAT_R64G64B64_SINT";
        case static_cast<uint64_t>(118): return "VK_FORMAT_R64G64B64_SFLOAT";
        case static_cast<uint64_t>(119): return "VK_FORMAT_R64G64B64A64_UINT";
        case static_cast<uint64_t>(120): return "VK_FORMAT_R64G64B64A64_SINT";
        case static_cast<uint64_t>(121): return "VK_FORMAT_R64G64B64A64_SFLOAT";
        case static_cast<uint64_t>(122): return "VK_FORMAT_B10G11R11_UFLOAT_PACK32";
        case static_cast<uint64_t>(123): return "VK_FORMAT_E5B9G9R9_UFLOAT_PACK32";
        case static_cast<uint64_t>(124): return "VK_FORMAT_D16_UNORM";
        case static_cast<uint64_t>(125): return "VK_FORMAT_X8_D24_UNORM_PACK32";
        case static_cast<uint64_t>(126): return "VK_FORMAT_D32_SFLOAT";
        case static_cast<uint64_t>(127): return "VK_FORMAT_S8_UINT";
        case static_cast<uint64_t>(128): return "VK_FORMAT_D16_UNORM_S8_UINT";
        case static_cast<uint64_t>(129): return "VK_FORMAT_D24_UNORM_S8_UINT";
        case static_cast<uint64_t>(130): return "VK_FORMAT_D32_SFLOAT_S8_UINT";
        case static_cast<uint64_t>(131): return "VK_FORMAT_BC1_RGB_UNORM_BLOCK";
        case static_cast<uint64_t>(132): return "VK_FORMAT_BC1_RGB_SRGB_BLOCK";
        case static_cast<uint64_t>(133): return "VK_FORMAT_BC1_RGBA_UNORM_BLOCK";
        case static_cast<uint64_t>(134): return "VK_FORMAT_BC1_RGBA_SRGB_BLOCK";
        case static_cast<uint64_t>(135): return "VK_FORMAT_BC2_UNORM_BLOCK";
        case static_cast<uint64_t>(136): return "VK_FORMAT_BC2_SRGB_BLOCK";
        case static_cast<uint64_t>(137): return "VK_FORMAT_BC3_UNORM_BLOCK";
        case static_cast<uint64_t>(138): return "VK_FORMAT_BC3_SRGB_BLOCK";
        case static_cast<uint64_t>(139): return "VK_FORMAT_BC4_UNORM_BLOCK";
        case static_cast<uint64_t>(140): return "VK_FORMAT_BC4_SNORM_BLOCK";
        case static_cast<uint64_t>(141): return "VK_FORMAT_BC5_UNORM_BLOCK";
        case static_cast<uint64_t>(142): return "VK_FORMAT_BC5_SNORM_BLOCK";
        case static_cast<uint64_t>(143): return "VK_FORMAT_BC6H_UFLOAT_BLOCK";
        case static_cast<uint64_t>(144): return "VK_FORMAT_BC6H_SFLOAT_BLOCK";
        case static_cast<uint64_t>(145): return "VK_FORMAT_BC7_UNORM_BLOCK";
        case static_cast<uint64_t>(146): return "VK_FORMAT_BC7_SRGB_BLOCK";
        case static_cast<uint64_t>(147): return "VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK";
        case static_cast<uint64_t>(148): return "VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK";
        case static_cast<uint64_t>(149): return "VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK";
        case static_cast<uint64_t>(150): return "VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK";
        case static_cast<uint64_t>(151): return "VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK";
        case static_cast<uint64_t>(152): return "VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK";
        case static_cast<uint64_t>(153): return "VK_FORMAT_EAC_R11_UNORM_BLOCK";
        case static_cast<uint64_t>(154): return "VK_FORMAT_EAC_R11_SNORM_BLOCK";
        case static_cast<uint64_t>(155): return "VK_FORMAT_EAC_R11G11_UNORM_BLOCK";
        case static_cast<uint64_t>(156): return "VK_FORMAT_EAC_R11G11_SNORM_BLOCK";
        case static_cast<uint64_t>(157): return "VK_FORMAT_ASTC_4x4_UNORM_BLOCK";
        case static_cast<uint64_t>(158): return "VK_FORMAT_ASTC_4x4_SRGB_BLOCK";
        case static_cast<uint64_t>(159): return "VK_FORMAT_ASTC_5x4_UNORM_BLOCK";
        case static_cast<uint64_t>(160): return "VK_FORMAT_ASTC_5x4_SRGB_BLOCK";
        case static_cast<uint64_t>(161): return "VK_FORMAT_ASTC_5x5_UNORM_BLOCK";
        case static_cast<uint64_t>(162): return "VK_FORMAT_ASTC_5x5_SRGB_BLOCK";
        case static_cast<uint64_t>(163): return "VK_FORMAT_ASTC_6x5_UNORM_BLOCK";
        case static_cast<uint64_t>(164): return "VK_FORMAT_ASTC_6x5_SRGB_BLOCK";
        case static_cast<uint64_t>(165): return "VK_FORMAT_ASTC_6x6_UNORM_BLOCK";
        case static_cast<uint64_t>(166): return "VK_FORMAT_ASTC_6x6_SRGB_BLOCK";
        case static_cast<uint64_t>(167): return "VK_FORMAT_ASTC_8x5_UNORM_BLOCK";
        case static_cast<uint64_t>(168): return "VK_FORMAT_ASTC_8x5_SRGB_BLOCK";
        case static_cast<uint64_t>(169): return "VK_FORMAT_ASTC_8x6_UNORM_BLOCK";
        case static_cast<uint64_t>(170): return "VK_FORMAT_ASTC_8x6_SRGB_BLOCK";
        case static_cast<uint64_t>(171): return "VK_FORMAT_ASTC_8x8_UNORM_BLOCK";
        case static_cast<uint64_t>(172): return "VK_FORMAT_ASTC_8x8_SRGB_BLOCK";
        case static_cast<uint64_t>(173): return "VK_FORMAT_ASTC_10x5_UNORM_BLOCK";
        case static_cast<uint64_t>(174): return "VK_FORMAT_ASTC_10x5_SRGB_BLOCK";
        case static_cast<uint64_t>(175): return "VK_FORMAT_ASTC_10x6_UNORM_BLOCK";
        case static_cast<uint64_t>(176): return "VK_FORMAT_ASTC_10x6_SRGB_BLOCK";
        case static_cast<uint64_t>(177): return "VK_FORMAT_ASTC_10x8_UNORM_BLOCK";
        case static_cast<uint64_t>(178): return "VK_FORMAT_ASTC_10x8_SRGB_BLOCK";
        case static_cast<uint64_t>(179): return "VK_FORMAT_ASTC_10x10_UNORM_BLOCK";
        case static_cast<uint64_t>(180): return "VK_FORMAT_ASTC_10x10_SRGB_BLOCK";
        case static_cast<uint64_t>(181): return "VK_FORMAT_ASTC_12x10_UNORM_BLOCK";
        case static_cast<uint64_t>(182): return "VK_FORMAT_ASTC_12x10_SRGB_BLOCK";
        case static_cast<uint64_t>(183): return "VK_FORMAT_ASTC_12x12_UNORM_BLOCK";
        case static_cast<uint64_t>(184): return "VK_FORMAT_ASTC_12x12_SRGB_BLOCK";
        case static_cast<uint64_t>(2147483647): return "VK_FORMAT_MAX_ENUM";
        case static_cast<uint64_t>(1000156000): return "VK_FORMAT_G8B8G8R8_422_UNORM";
        case static_cast<uint64_t>(1000156001): return "VK_FORMAT_B8G8R8G8_422_UNORM";
        case static_cast<uint64_t>(1000156002): return "VK_FORMAT_G8_B8_R8_3PLANE_420_UNORM";
        case static_cast<uint64_t>(1000156003): return "VK_FORMAT_G8_B8R8_2PLANE_420_UNORM";
        case static_cast<uint64_t>(1000156004): return "VK_FORMAT_G8_B8_R8_3PLANE_422_UNORM";
        case static_cast<uint64_t>(1000156005): return "VK_FORMAT_G8_B8R8_2PLANE_422_UNORM";
        case static_cast<uint64_t>(1000156006): return "VK_FORMAT_G8_B8_R8_3PLANE_444_UNORM";
        case static_cast<uint64_t>(1000156007): return "VK_FORMAT_R10X6_UNORM_PACK16";
        case static_cast<uint64_t>(1000156008): return "VK_FORMAT_R10X6G10X6_UNORM_2PACK16";
        case static_cast<uint64_t>(1000156009): return "VK_FORMAT_R10X6G10X6B10X6A10X6_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156010): return "VK_FORMAT_G10X6B10X6G10X6R10X6_422_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156011): return "VK_FORMAT_B10X6G10X6R10X6G10X6_422_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156012): return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_420_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156013): return "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_420_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156014): return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_422_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156015): return "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_422_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156016): return "VK_FORMAT_G10X6_B10X6_R10X6_3PLANE_444_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156017): return "VK_FORMAT_R12X4_UNORM_PACK16";
        case static_cast<uint64_t>(1000156018): return "VK_FORMAT_R12X4G12X4_UNORM_2PACK16";
        case static_cast<uint64_t>(1000156019): return "VK_FORMAT_R12X4G12X4B12X4A12X4_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156020): return "VK_FORMAT_G12X4B12X4G12X4R12X4_422_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156021): return "VK_FORMAT_B12X4G12X4R12X4G12X4_422_UNORM_4PACK16";
        case static_cast<uint64_t>(1000156022): return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_420_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156023): return "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_420_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156024): return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_422_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156025): return "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_422_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156026): return "VK_FORMAT_G12X4_B12X4_R12X4_3PLANE_444_UNORM_3PACK16";
        case static_cast<uint64_t>(1000156027): return "VK_FORMAT_G16B16G16R16_422_UNORM";
        case static_cast<uint64_t>(1000156028): return "VK_FORMAT_B16G16R16G16_422_UNORM";
        case static_cast<uint64_t>(1000156029): return "VK_FORMAT_G16_B16_R16_3PLANE_420_UNORM";
        case static_cast<uint64_t>(1000156030): return "VK_FORMAT_G16_B16R16_2PLANE_420_UNORM";
        case static_cast<uint64_t>(1000156031): return "VK_FORMAT_G16_B16_R16_3PLANE_422_UNORM";
        case static_cast<uint64_t>(1000156032): return "VK_FORMAT_G16_B16R16_2PLANE_422_UNORM";
        case static_cast<uint64_t>(1000156033): return "VK_FORMAT_G16_B16_R16_3PLANE_444_UNORM";
        case static_cast<uint64_t>(1000330000): return "VK_FORMAT_G8_B8R8_2PLANE_444_UNORM";
        case static_cast<uint64_t>(1000330001): return "VK_FORMAT_G10X6_B10X6R10X6_2PLANE_444_UNORM_3PACK16";
        case static_cast<uint64_t>(1000330002): return "VK_FORMAT_G12X4_B12X4R12X4_2PLANE_444_UNORM_3PACK16";
        case static_cast<uint64_t>(1000330003): return "VK_FORMAT_G16_B16R16_2PLANE_444_UNORM";
        case static_cast<uint64_t>(1000340000): return "VK_FORMAT_A4R4G4B4_UNORM_PACK16";
        case static_cast<uint64_t>(1000340001): return "VK_FORMAT_A4B4G4R4_UNORM_PACK16";
        case static_cast<uint64_t>(1000066000): return "VK_FORMAT_ASTC_4x4_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066001): return "VK_FORMAT_ASTC_5x4_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066002): return "VK_FORMAT_ASTC_5x5_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066003): return "VK_FORMAT_ASTC_6x5_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066004): return "VK_FORMAT_ASTC_6x6_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066005): return "VK_FORMAT_ASTC_8x5_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066006): return "VK_FORMAT_ASTC_8x6_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066007): return "VK_FORMAT_ASTC_8x8_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066008): return "VK_FORMAT_ASTC_10x5_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066009): return "VK_FORMAT_ASTC_10x6_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066010): return "VK_FORMAT_ASTC_10x8_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066011): return "VK_FORMAT_ASTC_10x10_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066012): return "VK_FORMAT_ASTC_12x10_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000066013): return "VK_FORMAT_ASTC_12x12_SFLOAT_BLOCK";
        case static_cast<uint64_t>(1000470000): return "VK_FORMAT_A1B5G5R5_UNORM_PACK16";
        case static_cast<uint64_t>(1000470001): return "VK_FORMAT_A8_UNORM";
        case static_cast<uint64_t>(1000054000): return "VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG";
        case static_cast<uint64_t>(1000054001): return "VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG";
        case static_cast<uint64_t>(1000054002): return "VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG";
        case static_cast<uint64_t>(1000054003): return "VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG";
        case static_cast<uint64_t>(1000054004): return "VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG";
        case static_cast<uint64_t>(1000054005): return "VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG";
        case static_cast<uint64_t>(1000054006): return "VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG";
        case static_cast<uint64_t>(1000054007): return "VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG";
        case static_cast<uint64_t>(1000460000): return "VK_FORMAT_R8_BOOL_ARM";
        case static_cast<uint64_t>(1000464000): return "VK_FORMAT_R16G16_SFIXED5_NV";
        case static_cast<uint64_t>(1000609000): return "VK_FORMAT_R10X6_UINT_PACK16_ARM";
        case static_cast<uint64_t>(1000609001): return "VK_FORMAT_R10X6G10X6_UINT_2PACK16_ARM";
        case static_cast<uint64_t>(1000609002): return "VK_FORMAT_R10X6G10X6B10X6A10X6_UINT_4PACK16_ARM";
        case static_cast<uint64_t>(1000609003): return "VK_FORMAT_R12X4_UINT_PACK16_ARM";
        case static_cast<uint64_t>(1000609004): return "VK_FORMAT_R12X4G12X4_UINT_2PACK16_ARM";
        case static_cast<uint64_t>(1000609005): return "VK_FORMAT_R12X4G12X4B12X4A12X4_UINT_4PACK16_ARM";
        case static_cast<uint64_t>(1000609006): return "VK_FORMAT_R14X2_UINT_PACK16_ARM";
        case static_cast<uint64_t>(1000609007): return "VK_FORMAT_R14X2G14X2_UINT_2PACK16_ARM";
        case static_cast<uint64_t>(1000609008): return "VK_FORMAT_R14X2G14X2B14X2A14X2_UINT_4PACK16_ARM";
        case static_cast<uint64_t>(1000609009): return "VK_FORMAT_R14X2_UNORM_PACK16_ARM";
        case static_cast<uint64_t>(1000609010): return "VK_FORMAT_R14X2G14X2_UNORM_2PACK16_ARM";
        case static_cast<uint64_t>(1000609011): return "VK_FORMAT_R14X2G14X2B14X2A14X2_UNORM_4PACK16_ARM";
        case static_cast<uint64_t>(1000609012): return "VK_FORMAT_G14X2_B14X2R14X2_2PLANE_420_UNORM_3PACK16_ARM";
        case static_cast<uint64_t>(1000609013): return "VK_FORMAT_G14X2_B14X2R14X2_2PLANE_422_UNORM_3PACK16_ARM";
        default: return "VkFormat_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFormatFeatureFlagBits>(VkFormatFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT";
        case static_cast<uint64_t>(2): return "VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT";
        case static_cast<uint64_t>(4): return "VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT";
        case static_cast<uint64_t>(8): return "VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT";
        case static_cast<uint64_t>(16): return "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT";
        case static_cast<uint64_t>(32): return "VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT";
        case static_cast<uint64_t>(64): return "VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT";
        case static_cast<uint64_t>(128): return "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT";
        case static_cast<uint64_t>(256): return "VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT";
        case static_cast<uint64_t>(512): return "VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT";
        case static_cast<uint64_t>(1024): return "VK_FORMAT_FEATURE_BLIT_SRC_BIT";
        case static_cast<uint64_t>(2048): return "VK_FORMAT_FEATURE_BLIT_DST_BIT";
        case static_cast<uint64_t>(4096): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(16384): return "VK_FORMAT_FEATURE_TRANSFER_SRC_BIT";
        case static_cast<uint64_t>(32768): return "VK_FORMAT_FEATURE_TRANSFER_DST_BIT";
        case static_cast<uint64_t>(131072): return "VK_FORMAT_FEATURE_MIDPOINT_CHROMA_SAMPLES_BIT";
        case static_cast<uint64_t>(262144): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_LINEAR_FILTER_BIT";
        case static_cast<uint64_t>(524288): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_SEPARATE_RECONSTRUCTION_FILTER_BIT";
        case static_cast<uint64_t>(1048576): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_BIT";
        case static_cast<uint64_t>(2097152): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_YCBCR_CONVERSION_CHROMA_RECONSTRUCTION_EXPLICIT_FORCEABLE_BIT";
        case static_cast<uint64_t>(4194304): return "VK_FORMAT_FEATURE_DISJOINT_BIT";
        case static_cast<uint64_t>(8388608): return "VK_FORMAT_FEATURE_COSITED_CHROMA_SAMPLES_BIT";
        case static_cast<uint64_t>(65536): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT";
        case static_cast<uint64_t>(33554432): return "VK_FORMAT_FEATURE_VIDEO_DECODE_OUTPUT_BIT_KHR";
        case static_cast<uint64_t>(67108864): return "VK_FORMAT_FEATURE_VIDEO_DECODE_DPB_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_EXT";
        case static_cast<uint64_t>(16777216): return "VK_FORMAT_FEATURE_FRAGMENT_DENSITY_MAP_BIT_EXT";
        case static_cast<uint64_t>(1073741824): return "VK_FORMAT_FEATURE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR";
        case static_cast<uint64_t>(134217728): return "VK_FORMAT_FEATURE_VIDEO_ENCODE_INPUT_BIT_KHR";
        case static_cast<uint64_t>(268435456): return "VK_FORMAT_FEATURE_VIDEO_ENCODE_DPB_BIT_KHR";
        case static_cast<uint64_t>(536870912): return "VK_FORMAT_FEATURE_ACCELERATION_STRUCTURE_VERTEX_BUFFER_BIT_KHR";
        default: return "VkFormatFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFragmentShadingRateCombinerOpKHR>(VkFragmentShadingRateCombinerOpKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KEEP_KHR";
        case static_cast<uint64_t>(1): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_REPLACE_KHR";
        case static_cast<uint64_t>(2): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MIN_KHR";
        case static_cast<uint64_t>(3): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MAX_KHR";
        case static_cast<uint64_t>(4): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_MUL_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_FRAGMENT_SHADING_RATE_COMBINER_OP_KHR_MAX_ENUM";
        default: return "VkFragmentShadingRateCombinerOpKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFragmentShadingRateNV>(VkFragmentShadingRateNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_PIXEL_NV";
        case static_cast<uint64_t>(1): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_1X2_PIXELS_NV";
        case static_cast<uint64_t>(4): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X1_PIXELS_NV";
        case static_cast<uint64_t>(5): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X2_PIXELS_NV";
        case static_cast<uint64_t>(6): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_2X4_PIXELS_NV";
        case static_cast<uint64_t>(9): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X2_PIXELS_NV";
        case static_cast<uint64_t>(10): return "VK_FRAGMENT_SHADING_RATE_1_INVOCATION_PER_4X4_PIXELS_NV";
        case static_cast<uint64_t>(11): return "VK_FRAGMENT_SHADING_RATE_2_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(12): return "VK_FRAGMENT_SHADING_RATE_4_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(13): return "VK_FRAGMENT_SHADING_RATE_8_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(14): return "VK_FRAGMENT_SHADING_RATE_16_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(15): return "VK_FRAGMENT_SHADING_RATE_NO_INVOCATIONS_NV";
        case static_cast<uint64_t>(2147483647): return "VK_FRAGMENT_SHADING_RATE_NV_MAX_ENUM";
        default: return "VkFragmentShadingRateNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFragmentShadingRateTypeNV>(VkFragmentShadingRateTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FRAGMENT_SHADING_RATE_TYPE_FRAGMENT_SIZE_NV";
        case static_cast<uint64_t>(1): return "VK_FRAGMENT_SHADING_RATE_TYPE_ENUMS_NV";
        case static_cast<uint64_t>(2147483647): return "VK_FRAGMENT_SHADING_RATE_TYPE_NV_MAX_ENUM";
        default: return "VkFragmentShadingRateTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFrameBoundaryFlagBitsEXT>(VkFrameBoundaryFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_FRAME_BOUNDARY_FRAME_END_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_FRAME_BOUNDARY_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkFrameBoundaryFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFramebufferCreateFlagBits>(VkFramebufferCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_FRAMEBUFFER_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_FRAMEBUFFER_CREATE_IMAGELESS_BIT";
        default: return "VkFramebufferCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkFrontFace>(VkFrontFace type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FRONT_FACE_COUNTER_CLOCKWISE";
        case static_cast<uint64_t>(1): return "VK_FRONT_FACE_CLOCKWISE";
        case static_cast<uint64_t>(2147483647): return "VK_FRONT_FACE_MAX_ENUM";
        default: return "VkFrontFace_UNKNOWN";
      }
    }

#ifdef VK_USE_PLATFORM_WIN32_KHR
    template <> constexpr const char* enumString<VkFullScreenExclusiveEXT>(VkFullScreenExclusiveEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_FULL_SCREEN_EXCLUSIVE_DEFAULT_EXT";
        case static_cast<uint64_t>(1): return "VK_FULL_SCREEN_EXCLUSIVE_ALLOWED_EXT";
        case static_cast<uint64_t>(2): return "VK_FULL_SCREEN_EXCLUSIVE_DISALLOWED_EXT";
        case static_cast<uint64_t>(3): return "VK_FULL_SCREEN_EXCLUSIVE_APPLICATION_CONTROLLED_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_FULL_SCREEN_EXCLUSIVE_EXT_MAX_ENUM";
        default: return "VkFullScreenExclusiveEXT_UNKNOWN";
      }
    }
#endif

    template <> constexpr const char* enumString<VkGeometryFlagBitsKHR>(VkGeometryFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_GEOMETRY_OPAQUE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_GEOMETRY_NO_DUPLICATE_ANY_HIT_INVOCATION_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_GEOMETRY_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkGeometryFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkGeometryInstanceFlagBitsKHR>(VkGeometryInstanceFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_GEOMETRY_INSTANCE_TRIANGLE_FACING_CULL_DISABLE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_GEOMETRY_INSTANCE_TRIANGLE_FLIP_FACING_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_GEOMETRY_INSTANCE_FORCE_OPAQUE_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_GEOMETRY_INSTANCE_FORCE_NO_OPAQUE_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_GEOMETRY_INSTANCE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(16): return "VK_GEOMETRY_INSTANCE_FORCE_OPACITY_MICROMAP_2_STATE_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_GEOMETRY_INSTANCE_DISABLE_OPACITY_MICROMAPS_BIT_EXT";
        default: return "VkGeometryInstanceFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkGeometryTypeKHR>(VkGeometryTypeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_GEOMETRY_TYPE_TRIANGLES_KHR";
        case static_cast<uint64_t>(1): return "VK_GEOMETRY_TYPE_AABBS_KHR";
        case static_cast<uint64_t>(2): return "VK_GEOMETRY_TYPE_INSTANCES_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_GEOMETRY_TYPE_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1000429004): return "VK_GEOMETRY_TYPE_SPHERES_NV";
        case static_cast<uint64_t>(1000429005): return "VK_GEOMETRY_TYPE_LINEAR_SWEPT_SPHERES_NV";
        default: return "VkGeometryTypeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkGraphicsPipelineLibraryFlagBitsEXT>(VkGraphicsPipelineLibraryFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_GRAPHICS_PIPELINE_LIBRARY_VERTEX_INPUT_INTERFACE_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_GRAPHICS_PIPELINE_LIBRARY_PRE_RASTERIZATION_SHADERS_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_SHADER_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_GRAPHICS_PIPELINE_LIBRARY_FRAGMENT_OUTPUT_INTERFACE_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_GRAPHICS_PIPELINE_LIBRARY_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkGraphicsPipelineLibraryFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkHostImageCopyFlagBits>(VkHostImageCopyFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_HOST_IMAGE_COPY_MEMCPY_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_HOST_IMAGE_COPY_FLAG_BITS_MAX_ENUM";
        default: return "VkHostImageCopyFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageAspectFlagBits>(VkImageAspectFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_IMAGE_ASPECT_COLOR_BIT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_ASPECT_DEPTH_BIT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_ASPECT_STENCIL_BIT";
        case static_cast<uint64_t>(8): return "VK_IMAGE_ASPECT_METADATA_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(16): return "VK_IMAGE_ASPECT_PLANE_0_BIT";
        case static_cast<uint64_t>(32): return "VK_IMAGE_ASPECT_PLANE_1_BIT";
        case static_cast<uint64_t>(64): return "VK_IMAGE_ASPECT_PLANE_2_BIT";
        case static_cast<uint64_t>(0): return "VK_IMAGE_ASPECT_NONE";
        case static_cast<uint64_t>(128): return "VK_IMAGE_ASPECT_MEMORY_PLANE_0_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_IMAGE_ASPECT_MEMORY_PLANE_1_BIT_EXT";
        case static_cast<uint64_t>(512): return "VK_IMAGE_ASPECT_MEMORY_PLANE_2_BIT_EXT";
        case static_cast<uint64_t>(1024): return "VK_IMAGE_ASPECT_MEMORY_PLANE_3_BIT_EXT";
        default: return "VkImageAspectFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageCompressionFixedRateFlagBitsEXT>(VkImageCompressionFixedRateFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_COMPRESSION_FIXED_RATE_NONE_EXT";
        case static_cast<uint64_t>(1): return "VK_IMAGE_COMPRESSION_FIXED_RATE_1BPC_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_COMPRESSION_FIXED_RATE_2BPC_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_COMPRESSION_FIXED_RATE_3BPC_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_IMAGE_COMPRESSION_FIXED_RATE_4BPC_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_IMAGE_COMPRESSION_FIXED_RATE_5BPC_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_IMAGE_COMPRESSION_FIXED_RATE_6BPC_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_IMAGE_COMPRESSION_FIXED_RATE_7BPC_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_IMAGE_COMPRESSION_FIXED_RATE_8BPC_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_IMAGE_COMPRESSION_FIXED_RATE_9BPC_BIT_EXT";
        case static_cast<uint64_t>(512): return "VK_IMAGE_COMPRESSION_FIXED_RATE_10BPC_BIT_EXT";
        case static_cast<uint64_t>(1024): return "VK_IMAGE_COMPRESSION_FIXED_RATE_11BPC_BIT_EXT";
        case static_cast<uint64_t>(2048): return "VK_IMAGE_COMPRESSION_FIXED_RATE_12BPC_BIT_EXT";
        case static_cast<uint64_t>(4096): return "VK_IMAGE_COMPRESSION_FIXED_RATE_13BPC_BIT_EXT";
        case static_cast<uint64_t>(8192): return "VK_IMAGE_COMPRESSION_FIXED_RATE_14BPC_BIT_EXT";
        case static_cast<uint64_t>(16384): return "VK_IMAGE_COMPRESSION_FIXED_RATE_15BPC_BIT_EXT";
        case static_cast<uint64_t>(32768): return "VK_IMAGE_COMPRESSION_FIXED_RATE_16BPC_BIT_EXT";
        case static_cast<uint64_t>(65536): return "VK_IMAGE_COMPRESSION_FIXED_RATE_17BPC_BIT_EXT";
        case static_cast<uint64_t>(131072): return "VK_IMAGE_COMPRESSION_FIXED_RATE_18BPC_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_IMAGE_COMPRESSION_FIXED_RATE_19BPC_BIT_EXT";
        case static_cast<uint64_t>(524288): return "VK_IMAGE_COMPRESSION_FIXED_RATE_20BPC_BIT_EXT";
        case static_cast<uint64_t>(1048576): return "VK_IMAGE_COMPRESSION_FIXED_RATE_21BPC_BIT_EXT";
        case static_cast<uint64_t>(2097152): return "VK_IMAGE_COMPRESSION_FIXED_RATE_22BPC_BIT_EXT";
        case static_cast<uint64_t>(4194304): return "VK_IMAGE_COMPRESSION_FIXED_RATE_23BPC_BIT_EXT";
        case static_cast<uint64_t>(8388608): return "VK_IMAGE_COMPRESSION_FIXED_RATE_24BPC_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_COMPRESSION_FIXED_RATE_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkImageCompressionFixedRateFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageCompressionFlagBitsEXT>(VkImageCompressionFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_COMPRESSION_DEFAULT_EXT";
        case static_cast<uint64_t>(1): return "VK_IMAGE_COMPRESSION_FIXED_RATE_DEFAULT_EXT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_COMPRESSION_FIXED_RATE_EXPLICIT_EXT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_COMPRESSION_DISABLED_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_COMPRESSION_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkImageCompressionFlagBitsEXT_UNKNOWN";
      }
    }

#ifdef VK_USE_PLATFORM_FUCHSIA
    template <> constexpr const char* enumString<VkImageConstraintsInfoFlagBitsFUCHSIA>(VkImageConstraintsInfoFlagBitsFUCHSIA type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_RARELY_FUCHSIA";
        case static_cast<uint64_t>(2): return "VK_IMAGE_CONSTRAINTS_INFO_CPU_READ_OFTEN_FUCHSIA";
        case static_cast<uint64_t>(4): return "VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_RARELY_FUCHSIA";
        case static_cast<uint64_t>(8): return "VK_IMAGE_CONSTRAINTS_INFO_CPU_WRITE_OFTEN_FUCHSIA";
        case static_cast<uint64_t>(16): return "VK_IMAGE_CONSTRAINTS_INFO_PROTECTED_OPTIONAL_FUCHSIA";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_CONSTRAINTS_INFO_FLAG_BITS_FUCHSIA_MAX_ENUM";
        default: return "VkImageConstraintsInfoFlagBitsFUCHSIA_UNKNOWN";
      }
    }
#endif

    template <> constexpr const char* enumString<VkImageCreateFlagBits>(VkImageCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_IMAGE_CREATE_SPARSE_BINDING_BIT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_CREATE_SPARSE_ALIASED_BIT";
        case static_cast<uint64_t>(8): return "VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT";
        case static_cast<uint64_t>(16): return "VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1024): return "VK_IMAGE_CREATE_ALIAS_BIT";
        case static_cast<uint64_t>(64): return "VK_IMAGE_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT";
        case static_cast<uint64_t>(32): return "VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT";
        case static_cast<uint64_t>(128): return "VK_IMAGE_CREATE_BLOCK_TEXEL_VIEW_COMPATIBLE_BIT";
        case static_cast<uint64_t>(256): return "VK_IMAGE_CREATE_EXTENDED_USAGE_BIT";
        case static_cast<uint64_t>(2048): return "VK_IMAGE_CREATE_PROTECTED_BIT";
        case static_cast<uint64_t>(512): return "VK_IMAGE_CREATE_DISJOINT_BIT";
        case static_cast<uint64_t>(8192): return "VK_IMAGE_CREATE_CORNER_SAMPLED_BIT_NV";
        case static_cast<uint64_t>(4096): return "VK_IMAGE_CREATE_SAMPLE_LOCATIONS_COMPATIBLE_DEPTH_BIT_EXT";
        case static_cast<uint64_t>(16384): return "VK_IMAGE_CREATE_SUBSAMPLED_BIT_EXT";
        case static_cast<uint64_t>(65536): return "VK_IMAGE_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_IMAGE_CREATE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_BIT_EXT";
        case static_cast<uint64_t>(131072): return "VK_IMAGE_CREATE_2D_VIEW_COMPATIBLE_BIT_EXT";
        case static_cast<uint64_t>(1048576): return "VK_IMAGE_CREATE_VIDEO_PROFILE_INDEPENDENT_BIT_KHR";
        case static_cast<uint64_t>(32768): return "VK_IMAGE_CREATE_FRAGMENT_DENSITY_MAP_OFFSET_BIT_EXT";
        default: return "VkImageCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageLayout>(VkImageLayout type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_LAYOUT_UNDEFINED";
        case static_cast<uint64_t>(1): return "VK_IMAGE_LAYOUT_GENERAL";
        case static_cast<uint64_t>(2): return "VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(3): return "VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(4): return "VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(5): return "VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(6): return "VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL";
        case static_cast<uint64_t>(7): return "VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL";
        case static_cast<uint64_t>(8): return "VK_IMAGE_LAYOUT_PREINITIALIZED";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_LAYOUT_MAX_ENUM";
        case static_cast<uint64_t>(1000117000): return "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(1000117001): return "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(1000241000): return "VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(1000241001): return "VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(1000241002): return "VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(1000241003): return "VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(1000314000): return "VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL";
        case static_cast<uint64_t>(1000314001): return "VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL";
        case static_cast<uint64_t>(1000232000): return "VK_IMAGE_LAYOUT_RENDERING_LOCAL_READ";
        case static_cast<uint64_t>(1000001002): return "VK_IMAGE_LAYOUT_PRESENT_SRC_KHR";
        case static_cast<uint64_t>(1000024000): return "VK_IMAGE_LAYOUT_VIDEO_DECODE_DST_KHR";
        case static_cast<uint64_t>(1000024001): return "VK_IMAGE_LAYOUT_VIDEO_DECODE_SRC_KHR";
        case static_cast<uint64_t>(1000024002): return "VK_IMAGE_LAYOUT_VIDEO_DECODE_DPB_KHR";
        case static_cast<uint64_t>(1000111000): return "VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR";
        case static_cast<uint64_t>(1000218000): return "VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT";
        case static_cast<uint64_t>(1000164003): return "VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR";
        case static_cast<uint64_t>(1000299000): return "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DST_KHR";
        case static_cast<uint64_t>(1000299001): return "VK_IMAGE_LAYOUT_VIDEO_ENCODE_SRC_KHR";
        case static_cast<uint64_t>(1000299002): return "VK_IMAGE_LAYOUT_VIDEO_ENCODE_DPB_KHR";
        case static_cast<uint64_t>(1000339000): return "VK_IMAGE_LAYOUT_ATTACHMENT_FEEDBACK_LOOP_OPTIMAL_EXT";
        case static_cast<uint64_t>(1000460000): return "VK_IMAGE_LAYOUT_TENSOR_ALIASING_ARM";
        case static_cast<uint64_t>(1000553000): return "VK_IMAGE_LAYOUT_VIDEO_ENCODE_QUANTIZATION_MAP_KHR";
        case static_cast<uint64_t>(1000620000): return "VK_IMAGE_LAYOUT_ZERO_INITIALIZED_EXT";
        default: return "VkImageLayout_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageTiling>(VkImageTiling type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_TILING_OPTIMAL";
        case static_cast<uint64_t>(1): return "VK_IMAGE_TILING_LINEAR";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_TILING_MAX_ENUM";
        case static_cast<uint64_t>(1000158000): return "VK_IMAGE_TILING_DRM_FORMAT_MODIFIER_EXT";
        default: return "VkImageTiling_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageType>(VkImageType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_TYPE_1D";
        case static_cast<uint64_t>(1): return "VK_IMAGE_TYPE_2D";
        case static_cast<uint64_t>(2): return "VK_IMAGE_TYPE_3D";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_TYPE_MAX_ENUM";
        default: return "VkImageType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageUsageFlagBits>(VkImageUsageFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_IMAGE_USAGE_TRANSFER_SRC_BIT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_USAGE_TRANSFER_DST_BIT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_USAGE_SAMPLED_BIT";
        case static_cast<uint64_t>(8): return "VK_IMAGE_USAGE_STORAGE_BIT";
        case static_cast<uint64_t>(16): return "VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT";
        case static_cast<uint64_t>(32): return "VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT";
        case static_cast<uint64_t>(64): return "VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT";
        case static_cast<uint64_t>(128): return "VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(4194304): return "VK_IMAGE_USAGE_HOST_TRANSFER_BIT";
        case static_cast<uint64_t>(1024): return "VK_IMAGE_USAGE_VIDEO_DECODE_DST_BIT_KHR";
        case static_cast<uint64_t>(2048): return "VK_IMAGE_USAGE_VIDEO_DECODE_SRC_BIT_KHR";
        case static_cast<uint64_t>(4096): return "VK_IMAGE_USAGE_VIDEO_DECODE_DPB_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_IMAGE_USAGE_FRAGMENT_DENSITY_MAP_BIT_EXT";
        case static_cast<uint64_t>(256): return "VK_IMAGE_USAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_IMAGE_USAGE_VIDEO_ENCODE_DST_BIT_KHR";
        case static_cast<uint64_t>(16384): return "VK_IMAGE_USAGE_VIDEO_ENCODE_SRC_BIT_KHR";
        case static_cast<uint64_t>(32768): return "VK_IMAGE_USAGE_VIDEO_ENCODE_DPB_BIT_KHR";
        case static_cast<uint64_t>(524288): return "VK_IMAGE_USAGE_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_IMAGE_USAGE_INVOCATION_MASK_BIT_HUAWEI";
        case static_cast<uint64_t>(1048576): return "VK_IMAGE_USAGE_SAMPLE_WEIGHT_BIT_QCOM";
        case static_cast<uint64_t>(2097152): return "VK_IMAGE_USAGE_SAMPLE_BLOCK_MATCH_BIT_QCOM";
        case static_cast<uint64_t>(8388608): return "VK_IMAGE_USAGE_TENSOR_ALIASING_BIT_ARM";
        case static_cast<uint64_t>(134217728): return "VK_IMAGE_USAGE_TILE_MEMORY_BIT_QCOM";
        case static_cast<uint64_t>(33554432): return "VK_IMAGE_USAGE_VIDEO_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR";
        case static_cast<uint64_t>(67108864): return "VK_IMAGE_USAGE_VIDEO_ENCODE_EMPHASIS_MAP_BIT_KHR";
        default: return "VkImageUsageFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageViewCreateFlagBits>(VkImageViewCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_VIEW_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DYNAMIC_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_IMAGE_VIEW_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_IMAGE_VIEW_CREATE_FRAGMENT_DENSITY_MAP_DEFERRED_BIT_EXT";
        default: return "VkImageViewCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkImageViewType>(VkImageViewType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_IMAGE_VIEW_TYPE_1D";
        case static_cast<uint64_t>(1): return "VK_IMAGE_VIEW_TYPE_2D";
        case static_cast<uint64_t>(2): return "VK_IMAGE_VIEW_TYPE_3D";
        case static_cast<uint64_t>(3): return "VK_IMAGE_VIEW_TYPE_CUBE";
        case static_cast<uint64_t>(4): return "VK_IMAGE_VIEW_TYPE_1D_ARRAY";
        case static_cast<uint64_t>(5): return "VK_IMAGE_VIEW_TYPE_2D_ARRAY";
        case static_cast<uint64_t>(6): return "VK_IMAGE_VIEW_TYPE_CUBE_ARRAY";
        case static_cast<uint64_t>(2147483647): return "VK_IMAGE_VIEW_TYPE_MAX_ENUM";
        default: return "VkImageViewType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndexType>(VkIndexType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_INDEX_TYPE_UINT16";
        case static_cast<uint64_t>(1): return "VK_INDEX_TYPE_UINT32";
        case static_cast<uint64_t>(2147483647): return "VK_INDEX_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1000265000): return "VK_INDEX_TYPE_UINT8";
        case static_cast<uint64_t>(1000165000): return "VK_INDEX_TYPE_NONE_KHR";
        default: return "VkIndexType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectCommandsInputModeFlagBitsEXT>(VkIndirectCommandsInputModeFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_INDIRECT_COMMANDS_INPUT_MODE_VULKAN_INDEX_BUFFER_EXT";
        case static_cast<uint64_t>(2): return "VK_INDIRECT_COMMANDS_INPUT_MODE_DXGI_INDEX_BUFFER_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_COMMANDS_INPUT_MODE_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkIndirectCommandsInputModeFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectCommandsLayoutUsageFlagBitsEXT>(VkIndirectCommandsLayoutUsageFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkIndirectCommandsLayoutUsageFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectCommandsLayoutUsageFlagBitsNV>(VkIndirectCommandsLayoutUsageFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EXPLICIT_PREPROCESS_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkIndirectCommandsLayoutUsageFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectCommandsTokenTypeEXT>(VkIndirectCommandsTokenTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXECUTION_SET_EXT";
        case static_cast<uint64_t>(1): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_EXT";
        case static_cast<uint64_t>(2): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_SEQUENCE_INDEX_EXT";
        case static_cast<uint64_t>(3): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_EXT";
        case static_cast<uint64_t>(4): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_EXT";
        case static_cast<uint64_t>(5): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_EXT";
        case static_cast<uint64_t>(6): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_EXT";
        case static_cast<uint64_t>(7): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_COUNT_EXT";
        case static_cast<uint64_t>(8): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_COUNT_EXT";
        case static_cast<uint64_t>(9): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_EXT_MAX_ENUM";
        case static_cast<uint64_t>(1000202002): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV_EXT";
        case static_cast<uint64_t>(1000202003): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_NV_EXT";
        case static_cast<uint64_t>(1000386004): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_TRACE_RAYS2_EXT";
        case static_cast<uint64_t>(1000328000): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_EXT";
        case static_cast<uint64_t>(1000328001): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_COUNT_EXT";
        default: return "VkIndirectCommandsTokenTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectCommandsTokenTypeNV>(VkIndirectCommandsTokenTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_SHADER_GROUP_NV";
        case static_cast<uint64_t>(1): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_STATE_FLAGS_NV";
        case static_cast<uint64_t>(2): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NV";
        case static_cast<uint64_t>(3): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NV";
        case static_cast<uint64_t>(4): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NV";
        case static_cast<uint64_t>(5): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NV";
        case static_cast<uint64_t>(6): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NV";
        case static_cast<uint64_t>(7): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_TASKS_NV";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_NV_MAX_ENUM";
        case static_cast<uint64_t>(1000428003): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NV";
        case static_cast<uint64_t>(1000428004): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NV";
        case static_cast<uint64_t>(1000328000): return "VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_MESH_TASKS_NV";
        default: return "VkIndirectCommandsTokenTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectExecutionSetInfoTypeEXT>(VkIndirectExecutionSetInfoTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_INDIRECT_EXECUTION_SET_INFO_TYPE_PIPELINES_EXT";
        case static_cast<uint64_t>(1): return "VK_INDIRECT_EXECUTION_SET_INFO_TYPE_SHADER_OBJECTS_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_EXECUTION_SET_INFO_TYPE_EXT_MAX_ENUM";
        default: return "VkIndirectExecutionSetInfoTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkIndirectStateFlagBitsNV>(VkIndirectStateFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_INDIRECT_STATE_FLAG_FRONTFACE_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_INDIRECT_STATE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkIndirectStateFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkInstanceCreateFlagBits>(VkInstanceCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_INSTANCE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_INSTANCE_CREATE_ENUMERATE_PORTABILITY_BIT_KHR";
        default: return "VkInstanceCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkInternalAllocationType>(VkInternalAllocationType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE";
        case static_cast<uint64_t>(2147483647): return "VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM";
        default: return "VkInternalAllocationType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkLatencyMarkerNV>(VkLatencyMarkerNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_LATENCY_MARKER_SIMULATION_START_NV";
        case static_cast<uint64_t>(1): return "VK_LATENCY_MARKER_SIMULATION_END_NV";
        case static_cast<uint64_t>(2): return "VK_LATENCY_MARKER_RENDERSUBMIT_START_NV";
        case static_cast<uint64_t>(3): return "VK_LATENCY_MARKER_RENDERSUBMIT_END_NV";
        case static_cast<uint64_t>(4): return "VK_LATENCY_MARKER_PRESENT_START_NV";
        case static_cast<uint64_t>(5): return "VK_LATENCY_MARKER_PRESENT_END_NV";
        case static_cast<uint64_t>(6): return "VK_LATENCY_MARKER_INPUT_SAMPLE_NV";
        case static_cast<uint64_t>(7): return "VK_LATENCY_MARKER_TRIGGER_FLASH_NV";
        case static_cast<uint64_t>(8): return "VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_START_NV";
        case static_cast<uint64_t>(9): return "VK_LATENCY_MARKER_OUT_OF_BAND_RENDERSUBMIT_END_NV";
        case static_cast<uint64_t>(10): return "VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_START_NV";
        case static_cast<uint64_t>(11): return "VK_LATENCY_MARKER_OUT_OF_BAND_PRESENT_END_NV";
        case static_cast<uint64_t>(2147483647): return "VK_LATENCY_MARKER_NV_MAX_ENUM";
        default: return "VkLatencyMarkerNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkLayerSettingTypeEXT>(VkLayerSettingTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_LAYER_SETTING_TYPE_BOOL32_EXT";
        case static_cast<uint64_t>(1): return "VK_LAYER_SETTING_TYPE_INT32_EXT";
        case static_cast<uint64_t>(2): return "VK_LAYER_SETTING_TYPE_INT64_EXT";
        case static_cast<uint64_t>(3): return "VK_LAYER_SETTING_TYPE_UINT32_EXT";
        case static_cast<uint64_t>(4): return "VK_LAYER_SETTING_TYPE_UINT64_EXT";
        case static_cast<uint64_t>(5): return "VK_LAYER_SETTING_TYPE_FLOAT32_EXT";
        case static_cast<uint64_t>(6): return "VK_LAYER_SETTING_TYPE_FLOAT64_EXT";
        case static_cast<uint64_t>(7): return "VK_LAYER_SETTING_TYPE_STRING_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_LAYER_SETTING_TYPE_EXT_MAX_ENUM";
        default: return "VkLayerSettingTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkLayeredDriverUnderlyingApiMSFT>(VkLayeredDriverUnderlyingApiMSFT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_LAYERED_DRIVER_UNDERLYING_API_NONE_MSFT";
        case static_cast<uint64_t>(1): return "VK_LAYERED_DRIVER_UNDERLYING_API_D3D12_MSFT";
        case static_cast<uint64_t>(2147483647): return "VK_LAYERED_DRIVER_UNDERLYING_API_MSFT_MAX_ENUM";
        default: return "VkLayeredDriverUnderlyingApiMSFT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkLineRasterizationMode>(VkLineRasterizationMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_LINE_RASTERIZATION_MODE_DEFAULT";
        case static_cast<uint64_t>(1): return "VK_LINE_RASTERIZATION_MODE_RECTANGULAR";
        case static_cast<uint64_t>(2): return "VK_LINE_RASTERIZATION_MODE_BRESENHAM";
        case static_cast<uint64_t>(3): return "VK_LINE_RASTERIZATION_MODE_RECTANGULAR_SMOOTH";
        case static_cast<uint64_t>(2147483647): return "VK_LINE_RASTERIZATION_MODE_MAX_ENUM";
        default: return "VkLineRasterizationMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkLogicOp>(VkLogicOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_LOGIC_OP_CLEAR";
        case static_cast<uint64_t>(1): return "VK_LOGIC_OP_AND";
        case static_cast<uint64_t>(2): return "VK_LOGIC_OP_AND_REVERSE";
        case static_cast<uint64_t>(3): return "VK_LOGIC_OP_COPY";
        case static_cast<uint64_t>(4): return "VK_LOGIC_OP_AND_INVERTED";
        case static_cast<uint64_t>(5): return "VK_LOGIC_OP_NO_OP";
        case static_cast<uint64_t>(6): return "VK_LOGIC_OP_XOR";
        case static_cast<uint64_t>(7): return "VK_LOGIC_OP_OR";
        case static_cast<uint64_t>(8): return "VK_LOGIC_OP_NOR";
        case static_cast<uint64_t>(9): return "VK_LOGIC_OP_EQUIVALENT";
        case static_cast<uint64_t>(10): return "VK_LOGIC_OP_INVERT";
        case static_cast<uint64_t>(11): return "VK_LOGIC_OP_OR_REVERSE";
        case static_cast<uint64_t>(12): return "VK_LOGIC_OP_COPY_INVERTED";
        case static_cast<uint64_t>(13): return "VK_LOGIC_OP_OR_INVERTED";
        case static_cast<uint64_t>(14): return "VK_LOGIC_OP_NAND";
        case static_cast<uint64_t>(15): return "VK_LOGIC_OP_SET";
        case static_cast<uint64_t>(2147483647): return "VK_LOGIC_OP_MAX_ENUM";
        default: return "VkLogicOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryAllocateFlagBits>(VkMemoryAllocateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_BIT";
        case static_cast<uint64_t>(4): return "VK_MEMORY_ALLOCATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT";
        case static_cast<uint64_t>(8): return "VK_MEMORY_ALLOCATE_ZERO_INITIALIZE_BIT_EXT";
        default: return "VkMemoryAllocateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryHeapFlagBits>(VkMemoryHeapFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_MEMORY_HEAP_DEVICE_LOCAL_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_MEMORY_HEAP_MULTI_INSTANCE_BIT";
        case static_cast<uint64_t>(8): return "VK_MEMORY_HEAP_TILE_MEMORY_BIT_QCOM";
        default: return "VkMemoryHeapFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryMapFlagBits>(VkMemoryMapFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_MAP_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_MEMORY_MAP_PLACED_BIT_EXT";
        default: return "VkMemoryMapFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryOverallocationBehaviorAMD>(VkMemoryOverallocationBehaviorAMD type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DEFAULT_AMD";
        case static_cast<uint64_t>(1): return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_ALLOWED_AMD";
        case static_cast<uint64_t>(2): return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_DISALLOWED_AMD";
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_OVERALLOCATION_BEHAVIOR_AMD_MAX_ENUM";
        default: return "VkMemoryOverallocationBehaviorAMD_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryPropertyFlagBits>(VkMemoryPropertyFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT";
        case static_cast<uint64_t>(2): return "VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT";
        case static_cast<uint64_t>(4): return "VK_MEMORY_PROPERTY_HOST_COHERENT_BIT";
        case static_cast<uint64_t>(8): return "VK_MEMORY_PROPERTY_HOST_CACHED_BIT";
        case static_cast<uint64_t>(16): return "VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(32): return "VK_MEMORY_PROPERTY_PROTECTED_BIT";
        case static_cast<uint64_t>(64): return "VK_MEMORY_PROPERTY_DEVICE_COHERENT_BIT_AMD";
        case static_cast<uint64_t>(128): return "VK_MEMORY_PROPERTY_DEVICE_UNCACHED_BIT_AMD";
        case static_cast<uint64_t>(256): return "VK_MEMORY_PROPERTY_RDMA_CAPABLE_BIT_NV";
        default: return "VkMemoryPropertyFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMemoryUnmapFlagBits>(VkMemoryUnmapFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_MEMORY_UNMAP_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_MEMORY_UNMAP_RESERVE_BIT_EXT";
        default: return "VkMemoryUnmapFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMicromapCreateFlagBitsEXT>(VkMicromapCreateFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_MICROMAP_CREATE_DEVICE_ADDRESS_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_MICROMAP_CREATE_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkMicromapCreateFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkMicromapTypeEXT>(VkMicromapTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_MICROMAP_TYPE_OPACITY_MICROMAP_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_MICROMAP_TYPE_EXT_MAX_ENUM";
        case static_cast<uint64_t>(1000397000): return "VK_MICROMAP_TYPE_DISPLACEMENT_MICROMAP_NV";
        default: return "VkMicromapTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkObjectType>(VkObjectType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OBJECT_TYPE_UNKNOWN";
        case static_cast<uint64_t>(1): return "VK_OBJECT_TYPE_INSTANCE";
        case static_cast<uint64_t>(2): return "VK_OBJECT_TYPE_PHYSICAL_DEVICE";
        case static_cast<uint64_t>(3): return "VK_OBJECT_TYPE_DEVICE";
        case static_cast<uint64_t>(4): return "VK_OBJECT_TYPE_QUEUE";
        case static_cast<uint64_t>(5): return "VK_OBJECT_TYPE_SEMAPHORE";
        case static_cast<uint64_t>(6): return "VK_OBJECT_TYPE_COMMAND_BUFFER";
        case static_cast<uint64_t>(7): return "VK_OBJECT_TYPE_FENCE";
        case static_cast<uint64_t>(8): return "VK_OBJECT_TYPE_DEVICE_MEMORY";
        case static_cast<uint64_t>(9): return "VK_OBJECT_TYPE_BUFFER";
        case static_cast<uint64_t>(10): return "VK_OBJECT_TYPE_IMAGE";
        case static_cast<uint64_t>(11): return "VK_OBJECT_TYPE_EVENT";
        case static_cast<uint64_t>(12): return "VK_OBJECT_TYPE_QUERY_POOL";
        case static_cast<uint64_t>(13): return "VK_OBJECT_TYPE_BUFFER_VIEW";
        case static_cast<uint64_t>(14): return "VK_OBJECT_TYPE_IMAGE_VIEW";
        case static_cast<uint64_t>(15): return "VK_OBJECT_TYPE_SHADER_MODULE";
        case static_cast<uint64_t>(16): return "VK_OBJECT_TYPE_PIPELINE_CACHE";
        case static_cast<uint64_t>(17): return "VK_OBJECT_TYPE_PIPELINE_LAYOUT";
        case static_cast<uint64_t>(18): return "VK_OBJECT_TYPE_RENDER_PASS";
        case static_cast<uint64_t>(19): return "VK_OBJECT_TYPE_PIPELINE";
        case static_cast<uint64_t>(20): return "VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT";
        case static_cast<uint64_t>(21): return "VK_OBJECT_TYPE_SAMPLER";
        case static_cast<uint64_t>(22): return "VK_OBJECT_TYPE_DESCRIPTOR_POOL";
        case static_cast<uint64_t>(23): return "VK_OBJECT_TYPE_DESCRIPTOR_SET";
        case static_cast<uint64_t>(24): return "VK_OBJECT_TYPE_FRAMEBUFFER";
        case static_cast<uint64_t>(25): return "VK_OBJECT_TYPE_COMMAND_POOL";
        case static_cast<uint64_t>(2147483647): return "VK_OBJECT_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1000156000): return "VK_OBJECT_TYPE_SAMPLER_YCBCR_CONVERSION";
        case static_cast<uint64_t>(1000085000): return "VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE";
        case static_cast<uint64_t>(1000295000): return "VK_OBJECT_TYPE_PRIVATE_DATA_SLOT";
        case static_cast<uint64_t>(1000000000): return "VK_OBJECT_TYPE_SURFACE_KHR";
        case static_cast<uint64_t>(1000001000): return "VK_OBJECT_TYPE_SWAPCHAIN_KHR";
        case static_cast<uint64_t>(1000002000): return "VK_OBJECT_TYPE_DISPLAY_KHR";
        case static_cast<uint64_t>(1000002001): return "VK_OBJECT_TYPE_DISPLAY_MODE_KHR";
        case static_cast<uint64_t>(1000011000): return "VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT";
        case static_cast<uint64_t>(1000023000): return "VK_OBJECT_TYPE_VIDEO_SESSION_KHR";
        case static_cast<uint64_t>(1000023001): return "VK_OBJECT_TYPE_VIDEO_SESSION_PARAMETERS_KHR";
        case static_cast<uint64_t>(1000128000): return "VK_OBJECT_TYPE_DEBUG_UTILS_MESSENGER_EXT";
        case static_cast<uint64_t>(1000160000): return "VK_OBJECT_TYPE_VALIDATION_CACHE_EXT";
        case static_cast<uint64_t>(1000165000): return "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV";
        case static_cast<uint64_t>(1000210000): return "VK_OBJECT_TYPE_PERFORMANCE_CONFIGURATION_INTEL";
        case static_cast<uint64_t>(1000268000): return "VK_OBJECT_TYPE_DEFERRED_OPERATION_KHR";
        case static_cast<uint64_t>(1000277000): return "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NV";
        case static_cast<uint64_t>(1000307000): return "VK_OBJECT_TYPE_CUDA_MODULE_NV";
        case static_cast<uint64_t>(1000307001): return "VK_OBJECT_TYPE_CUDA_FUNCTION_NV";
        case static_cast<uint64_t>(1000366000): return "VK_OBJECT_TYPE_BUFFER_COLLECTION_FUCHSIA";
        case static_cast<uint64_t>(1000396000): return "VK_OBJECT_TYPE_MICROMAP_EXT";
        case static_cast<uint64_t>(1000460000): return "VK_OBJECT_TYPE_TENSOR_ARM";
        case static_cast<uint64_t>(1000460001): return "VK_OBJECT_TYPE_TENSOR_VIEW_ARM";
        case static_cast<uint64_t>(1000464000): return "VK_OBJECT_TYPE_OPTICAL_FLOW_SESSION_NV";
        case static_cast<uint64_t>(1000482000): return "VK_OBJECT_TYPE_SHADER_EXT";
        case static_cast<uint64_t>(1000483000): return "VK_OBJECT_TYPE_PIPELINE_BINARY_KHR";
        case static_cast<uint64_t>(1000507000): return "VK_OBJECT_TYPE_DATA_GRAPH_PIPELINE_SESSION_ARM";
        case static_cast<uint64_t>(1000556000): return "VK_OBJECT_TYPE_EXTERNAL_COMPUTE_QUEUE_NV";
        case static_cast<uint64_t>(1000572000): return "VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_EXT";
        case static_cast<uint64_t>(1000572001): return "VK_OBJECT_TYPE_INDIRECT_EXECUTION_SET_EXT";
        case static_cast<uint64_t>(1000150000): return "VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR";
        default: return "VkObjectType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpacityMicromapFormatEXT>(VkOpacityMicromapFormatEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_OPACITY_MICROMAP_FORMAT_2_STATE_EXT";
        case static_cast<uint64_t>(2): return "VK_OPACITY_MICROMAP_FORMAT_4_STATE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_OPACITY_MICROMAP_FORMAT_EXT_MAX_ENUM";
        default: return "VkOpacityMicromapFormatEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpacityMicromapSpecialIndexEXT>(VkOpacityMicromapSpecialIndexEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(-1): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_TRANSPARENT_EXT";
        case static_cast<uint64_t>(-2): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_OPAQUE_EXT";
        case static_cast<uint64_t>(-3): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_TRANSPARENT_EXT";
        case static_cast<uint64_t>(-4): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_FULLY_UNKNOWN_OPAQUE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_EXT_MAX_ENUM";
        case static_cast<uint64_t>(-5): return "VK_OPACITY_MICROMAP_SPECIAL_INDEX_CLUSTER_GEOMETRY_DISABLE_OPACITY_MICROMAP_NV";
        default: return "VkOpacityMicromapSpecialIndexEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowExecuteFlagBitsNV>(VkOpticalFlowExecuteFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_EXECUTE_DISABLE_TEMPORAL_HINTS_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_EXECUTE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkOpticalFlowExecuteFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowGridSizeFlagBitsNV>(VkOpticalFlowGridSizeFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OPTICAL_FLOW_GRID_SIZE_UNKNOWN_NV";
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_GRID_SIZE_1X1_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_OPTICAL_FLOW_GRID_SIZE_2X2_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_OPTICAL_FLOW_GRID_SIZE_4X4_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_OPTICAL_FLOW_GRID_SIZE_8X8_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_GRID_SIZE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkOpticalFlowGridSizeFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowPerformanceLevelNV>(VkOpticalFlowPerformanceLevelNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_UNKNOWN_NV";
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_SLOW_NV";
        case static_cast<uint64_t>(2): return "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_MEDIUM_NV";
        case static_cast<uint64_t>(3): return "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_FAST_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_PERFORMANCE_LEVEL_NV_MAX_ENUM";
        default: return "VkOpticalFlowPerformanceLevelNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowSessionBindingPointNV>(VkOpticalFlowSessionBindingPointNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_UNKNOWN_NV";
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_INPUT_NV";
        case static_cast<uint64_t>(2): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_REFERENCE_NV";
        case static_cast<uint64_t>(3): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_HINT_NV";
        case static_cast<uint64_t>(4): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_FLOW_VECTOR_NV";
        case static_cast<uint64_t>(5): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_FLOW_VECTOR_NV";
        case static_cast<uint64_t>(6): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_COST_NV";
        case static_cast<uint64_t>(7): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_BACKWARD_COST_NV";
        case static_cast<uint64_t>(8): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_GLOBAL_FLOW_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_SESSION_BINDING_POINT_NV_MAX_ENUM";
        default: return "VkOpticalFlowSessionBindingPointNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowSessionCreateFlagBitsNV>(VkOpticalFlowSessionCreateFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_HINT_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_COST_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_OPTICAL_FLOW_SESSION_CREATE_ENABLE_GLOBAL_FLOW_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_OPTICAL_FLOW_SESSION_CREATE_ALLOW_REGIONS_BIT_NV";
        case static_cast<uint64_t>(16): return "VK_OPTICAL_FLOW_SESSION_CREATE_BOTH_DIRECTIONS_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_SESSION_CREATE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkOpticalFlowSessionCreateFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOpticalFlowUsageFlagBitsNV>(VkOpticalFlowUsageFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OPTICAL_FLOW_USAGE_UNKNOWN_NV";
        case static_cast<uint64_t>(1): return "VK_OPTICAL_FLOW_USAGE_INPUT_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_OPTICAL_FLOW_USAGE_OUTPUT_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_OPTICAL_FLOW_USAGE_HINT_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_OPTICAL_FLOW_USAGE_COST_BIT_NV";
        case static_cast<uint64_t>(16): return "VK_OPTICAL_FLOW_USAGE_GLOBAL_FLOW_BIT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OPTICAL_FLOW_USAGE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkOpticalFlowUsageFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkOutOfBandQueueTypeNV>(VkOutOfBandQueueTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_OUT_OF_BAND_QUEUE_TYPE_RENDER_NV";
        case static_cast<uint64_t>(1): return "VK_OUT_OF_BAND_QUEUE_TYPE_PRESENT_NV";
        case static_cast<uint64_t>(2147483647): return "VK_OUT_OF_BAND_QUEUE_TYPE_NV_MAX_ENUM";
        default: return "VkOutOfBandQueueTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPartitionedAccelerationStructureInstanceFlagBitsNV>(VkPartitionedAccelerationStructureInstanceFlagBitsNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FACING_CULL_DISABLE_BIT_NV";
        case static_cast<uint64_t>(2): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_TRIANGLE_FLIP_FACING_BIT_NV";
        case static_cast<uint64_t>(4): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_OPAQUE_BIT_NV";
        case static_cast<uint64_t>(8): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_FORCE_NO_OPAQUE_BIT_NV";
        case static_cast<uint64_t>(16): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_ENABLE_EXPLICIT_BOUNDING_BOX_NV";
        case static_cast<uint64_t>(2147483647): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCE_FLAG_BITS_NV_MAX_ENUM";
        default: return "VkPartitionedAccelerationStructureInstanceFlagBitsNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPartitionedAccelerationStructureOpTypeNV>(VkPartitionedAccelerationStructureOpTypeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_INSTANCE_NV";
        case static_cast<uint64_t>(1): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_UPDATE_INSTANCE_NV";
        case static_cast<uint64_t>(2): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_WRITE_PARTITION_TRANSLATION_NV";
        case static_cast<uint64_t>(2147483647): return "VK_PARTITIONED_ACCELERATION_STRUCTURE_OP_TYPE_NV_MAX_ENUM";
        default: return "VkPartitionedAccelerationStructureOpTypeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPeerMemoryFeatureFlagBits>(VkPeerMemoryFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT";
        case static_cast<uint64_t>(2): return "VK_PEER_MEMORY_FEATURE_COPY_DST_BIT";
        case static_cast<uint64_t>(4): return "VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT";
        case static_cast<uint64_t>(8): return "VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM";
        default: return "VkPeerMemoryFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceConfigurationTypeINTEL>(VkPerformanceConfigurationTypeINTEL type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_CONFIGURATION_TYPE_COMMAND_QUEUE_METRICS_DISCOVERY_ACTIVATED_INTEL";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_CONFIGURATION_TYPE_INTEL_MAX_ENUM";
        default: return "VkPerformanceConfigurationTypeINTEL_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceCounterDescriptionFlagBitsKHR>(VkPerformanceCounterDescriptionFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_COUNTER_DESCRIPTION_PERFORMANCE_IMPACTING_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_PERFORMANCE_COUNTER_DESCRIPTION_CONCURRENTLY_IMPACTED_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_COUNTER_DESCRIPTION_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkPerformanceCounterDescriptionFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceCounterScopeKHR>(VkPerformanceCounterScopeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_BUFFER_KHR";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_COUNTER_SCOPE_RENDER_PASS_KHR";
        case static_cast<uint64_t>(2): return "VK_PERFORMANCE_COUNTER_SCOPE_COMMAND_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_COUNTER_SCOPE_KHR_MAX_ENUM";
        default: return "VkPerformanceCounterScopeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceCounterStorageKHR>(VkPerformanceCounterStorageKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_COUNTER_STORAGE_INT32_KHR";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_COUNTER_STORAGE_INT64_KHR";
        case static_cast<uint64_t>(2): return "VK_PERFORMANCE_COUNTER_STORAGE_UINT32_KHR";
        case static_cast<uint64_t>(3): return "VK_PERFORMANCE_COUNTER_STORAGE_UINT64_KHR";
        case static_cast<uint64_t>(4): return "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT32_KHR";
        case static_cast<uint64_t>(5): return "VK_PERFORMANCE_COUNTER_STORAGE_FLOAT64_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_COUNTER_STORAGE_KHR_MAX_ENUM";
        default: return "VkPerformanceCounterStorageKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceCounterUnitKHR>(VkPerformanceCounterUnitKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_COUNTER_UNIT_GENERIC_KHR";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_COUNTER_UNIT_PERCENTAGE_KHR";
        case static_cast<uint64_t>(2): return "VK_PERFORMANCE_COUNTER_UNIT_NANOSECONDS_KHR";
        case static_cast<uint64_t>(3): return "VK_PERFORMANCE_COUNTER_UNIT_BYTES_KHR";
        case static_cast<uint64_t>(4): return "VK_PERFORMANCE_COUNTER_UNIT_BYTES_PER_SECOND_KHR";
        case static_cast<uint64_t>(5): return "VK_PERFORMANCE_COUNTER_UNIT_KELVIN_KHR";
        case static_cast<uint64_t>(6): return "VK_PERFORMANCE_COUNTER_UNIT_WATTS_KHR";
        case static_cast<uint64_t>(7): return "VK_PERFORMANCE_COUNTER_UNIT_VOLTS_KHR";
        case static_cast<uint64_t>(8): return "VK_PERFORMANCE_COUNTER_UNIT_AMPS_KHR";
        case static_cast<uint64_t>(9): return "VK_PERFORMANCE_COUNTER_UNIT_HERTZ_KHR";
        case static_cast<uint64_t>(10): return "VK_PERFORMANCE_COUNTER_UNIT_CYCLES_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_COUNTER_UNIT_KHR_MAX_ENUM";
        default: return "VkPerformanceCounterUnitKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceOverrideTypeINTEL>(VkPerformanceOverrideTypeINTEL type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_OVERRIDE_TYPE_NULL_HARDWARE_INTEL";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_OVERRIDE_TYPE_FLUSH_GPU_CACHES_INTEL";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_OVERRIDE_TYPE_INTEL_MAX_ENUM";
        default: return "VkPerformanceOverrideTypeINTEL_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceParameterTypeINTEL>(VkPerformanceParameterTypeINTEL type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_PARAMETER_TYPE_HW_COUNTERS_SUPPORTED_INTEL";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_PARAMETER_TYPE_STREAM_MARKER_VALID_BITS_INTEL";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_PARAMETER_TYPE_INTEL_MAX_ENUM";
        default: return "VkPerformanceParameterTypeINTEL_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPerformanceValueTypeINTEL>(VkPerformanceValueTypeINTEL type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PERFORMANCE_VALUE_TYPE_UINT32_INTEL";
        case static_cast<uint64_t>(1): return "VK_PERFORMANCE_VALUE_TYPE_UINT64_INTEL";
        case static_cast<uint64_t>(2): return "VK_PERFORMANCE_VALUE_TYPE_FLOAT_INTEL";
        case static_cast<uint64_t>(3): return "VK_PERFORMANCE_VALUE_TYPE_BOOL_INTEL";
        case static_cast<uint64_t>(4): return "VK_PERFORMANCE_VALUE_TYPE_STRING_INTEL";
        case static_cast<uint64_t>(2147483647): return "VK_PERFORMANCE_VALUE_TYPE_INTEL_MAX_ENUM";
        default: return "VkPerformanceValueTypeINTEL_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPhysicalDeviceDataGraphOperationTypeARM>(VkPhysicalDeviceDataGraphOperationTypeARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_SPIRV_EXTENDED_INSTRUCTION_SET_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_PHYSICAL_DEVICE_DATA_GRAPH_OPERATION_TYPE_ARM_MAX_ENUM";
        default: return "VkPhysicalDeviceDataGraphOperationTypeARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPhysicalDeviceDataGraphProcessingEngineTypeARM>(VkPhysicalDeviceDataGraphProcessingEngineTypeARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_DEFAULT_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_PHYSICAL_DEVICE_DATA_GRAPH_PROCESSING_ENGINE_TYPE_ARM_MAX_ENUM";
        default: return "VkPhysicalDeviceDataGraphProcessingEngineTypeARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPhysicalDeviceLayeredApiKHR>(VkPhysicalDeviceLayeredApiKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PHYSICAL_DEVICE_LAYERED_API_VULKAN_KHR";
        case static_cast<uint64_t>(1): return "VK_PHYSICAL_DEVICE_LAYERED_API_D3D12_KHR";
        case static_cast<uint64_t>(2): return "VK_PHYSICAL_DEVICE_LAYERED_API_METAL_KHR";
        case static_cast<uint64_t>(3): return "VK_PHYSICAL_DEVICE_LAYERED_API_OPENGL_KHR";
        case static_cast<uint64_t>(4): return "VK_PHYSICAL_DEVICE_LAYERED_API_OPENGLES_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PHYSICAL_DEVICE_LAYERED_API_KHR_MAX_ENUM";
        default: return "VkPhysicalDeviceLayeredApiKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPhysicalDeviceType>(VkPhysicalDeviceType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PHYSICAL_DEVICE_TYPE_OTHER";
        case static_cast<uint64_t>(1): return "VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU";
        case static_cast<uint64_t>(2): return "VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU";
        case static_cast<uint64_t>(3): return "VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU";
        case static_cast<uint64_t>(4): return "VK_PHYSICAL_DEVICE_TYPE_CPU";
        case static_cast<uint64_t>(2147483647): return "VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM";
        default: return "VkPhysicalDeviceType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineBindPoint>(VkPipelineBindPoint type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PIPELINE_BIND_POINT_GRAPHICS";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_BIND_POINT_COMPUTE";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_BIND_POINT_MAX_ENUM";
        case static_cast<uint64_t>(1000134000): return "VK_PIPELINE_BIND_POINT_EXECUTION_GRAPH_AMDX";
        case static_cast<uint64_t>(1000369003): return "VK_PIPELINE_BIND_POINT_SUBPASS_SHADING_HUAWEI";
        case static_cast<uint64_t>(1000507000): return "VK_PIPELINE_BIND_POINT_DATA_GRAPH_ARM";
        case static_cast<uint64_t>(1000165000): return "VK_PIPELINE_BIND_POINT_RAY_TRACING_KHR";
        default: return "VkPipelineBindPoint_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineCacheCreateFlagBits>(VkPipelineCacheCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_CACHE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_CACHE_CREATE_EXTERNALLY_SYNCHRONIZED_BIT";
        case static_cast<uint64_t>(8): return "VK_PIPELINE_CACHE_CREATE_INTERNALLY_SYNCHRONIZED_MERGE_BIT_KHR";
        default: return "VkPipelineCacheCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineCacheHeaderVersion>(VkPipelineCacheHeaderVersion type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PIPELINE_CACHE_HEADER_VERSION_ONE";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM";
        default: return "VkPipelineCacheHeaderVersion_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineColorBlendStateCreateFlagBits>(VkPipelineColorBlendStateCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_COLOR_BLEND_STATE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_COLOR_BLEND_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_BIT_EXT";
        default: return "VkPipelineColorBlendStateCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineCreateFlagBits>(VkPipelineCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT";
        case static_cast<uint64_t>(4): return "VK_PIPELINE_CREATE_DERIVATIVE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(8): return "VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT";
        case static_cast<uint64_t>(16): return "VK_PIPELINE_CREATE_DISPATCH_BASE_BIT";
        case static_cast<uint64_t>(256): return "VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT";
        case static_cast<uint64_t>(512): return "VK_PIPELINE_CREATE_EARLY_RETURN_ON_FAILURE_BIT";
        case static_cast<uint64_t>(134217728): return "VK_PIPELINE_CREATE_NO_PROTECTED_ACCESS_BIT";
        case static_cast<uint64_t>(1073741824): return "VK_PIPELINE_CREATE_PROTECTED_ACCESS_ONLY_BIT";
        case static_cast<uint64_t>(32): return "VK_PIPELINE_CREATE_DEFER_COMPILE_BIT_NV";
        case static_cast<uint64_t>(4194304): return "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT";
        case static_cast<uint64_t>(2097152): return "VK_PIPELINE_CREATE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_PIPELINE_CREATE_CAPTURE_STATISTICS_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_PIPELINE_CREATE_CAPTURE_INTERNAL_REPRESENTATIONS_BIT_KHR";
        case static_cast<uint64_t>(262144): return "VK_PIPELINE_CREATE_INDIRECT_BINDABLE_BIT_NV";
        case static_cast<uint64_t>(2048): return "VK_PIPELINE_CREATE_LIBRARY_BIT_KHR";
        case static_cast<uint64_t>(536870912): return "VK_PIPELINE_CREATE_DESCRIPTOR_BUFFER_BIT_EXT";
        case static_cast<uint64_t>(8388608): return "VK_PIPELINE_CREATE_RETAIN_LINK_TIME_OPTIMIZATION_INFO_BIT_EXT";
        case static_cast<uint64_t>(1024): return "VK_PIPELINE_CREATE_LINK_TIME_OPTIMIZATION_BIT_EXT";
        case static_cast<uint64_t>(1048576): return "VK_PIPELINE_CREATE_RAY_TRACING_ALLOW_MOTION_BIT_NV";
        case static_cast<uint64_t>(33554432): return "VK_PIPELINE_CREATE_COLOR_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT";
        case static_cast<uint64_t>(67108864): return "VK_PIPELINE_CREATE_DEPTH_STENCIL_ATTACHMENT_FEEDBACK_LOOP_BIT_EXT";
        case static_cast<uint64_t>(16777216): return "VK_PIPELINE_CREATE_RAY_TRACING_OPACITY_MICROMAP_BIT_EXT";
        case static_cast<uint64_t>(268435456): return "VK_PIPELINE_CREATE_RAY_TRACING_DISPLACEMENT_MICROMAP_BIT_NV";
        case static_cast<uint64_t>(16384): return "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_ANY_HIT_SHADERS_BIT_KHR";
        case static_cast<uint64_t>(32768): return "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_CLOSEST_HIT_SHADERS_BIT_KHR";
        case static_cast<uint64_t>(65536): return "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_MISS_SHADERS_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_PIPELINE_CREATE_RAY_TRACING_NO_NULL_INTERSECTION_SHADERS_BIT_KHR";
        case static_cast<uint64_t>(4096): return "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_TRIANGLES_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_PIPELINE_CREATE_RAY_TRACING_SKIP_AABBS_BIT_KHR";
        case static_cast<uint64_t>(524288): return "VK_PIPELINE_CREATE_RAY_TRACING_SHADER_GROUP_HANDLE_CAPTURE_REPLAY_BIT_KHR";
        default: return "VkPipelineCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineCreationFeedbackFlagBits>(VkPipelineCreationFeedbackFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PIPELINE_CREATION_FEEDBACK_VALID_BIT";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_CREATION_FEEDBACK_APPLICATION_PIPELINE_CACHE_HIT_BIT";
        case static_cast<uint64_t>(4): return "VK_PIPELINE_CREATION_FEEDBACK_BASE_PIPELINE_ACCELERATION_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_CREATION_FEEDBACK_FLAG_BITS_MAX_ENUM";
        default: return "VkPipelineCreationFeedbackFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineDepthStencilStateCreateFlagBits>(VkPipelineDepthStencilStateCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_DEPTH_STENCIL_STATE_CREATE_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT";
        default: return "VkPipelineDepthStencilStateCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineExecutableStatisticFormatKHR>(VkPipelineExecutableStatisticFormatKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_BOOL32_KHR";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_INT64_KHR";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_UINT64_KHR";
        case static_cast<uint64_t>(3): return "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_FLOAT64_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_EXECUTABLE_STATISTIC_FORMAT_KHR_MAX_ENUM";
        default: return "VkPipelineExecutableStatisticFormatKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineLayoutCreateFlagBits>(VkPipelineLayoutCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_LAYOUT_CREATE_INDEPENDENT_SETS_BIT_EXT";
        default: return "VkPipelineLayoutCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineRobustnessBufferBehavior>(VkPipelineRobustnessBufferBehavior type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DEVICE_DEFAULT";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_DISABLED";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS";
        case static_cast<uint64_t>(3): return "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_ROBUST_BUFFER_ACCESS_2";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_ROBUSTNESS_BUFFER_BEHAVIOR_MAX_ENUM";
        default: return "VkPipelineRobustnessBufferBehavior_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineRobustnessImageBehavior>(VkPipelineRobustnessImageBehavior type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DEVICE_DEFAULT";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_DISABLED";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS";
        case static_cast<uint64_t>(3): return "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_ROBUST_IMAGE_ACCESS_2";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_ROBUSTNESS_IMAGE_BEHAVIOR_MAX_ENUM";
        default: return "VkPipelineRobustnessImageBehavior_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineShaderStageCreateFlagBits>(VkPipelineShaderStageCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_SHADER_STAGE_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_PIPELINE_SHADER_STAGE_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_SHADER_STAGE_CREATE_REQUIRE_FULL_SUBGROUPS_BIT";
        default: return "VkPipelineShaderStageCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPipelineStageFlagBits>(VkPipelineStageFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT";
        case static_cast<uint64_t>(2): return "VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT";
        case static_cast<uint64_t>(4): return "VK_PIPELINE_STAGE_VERTEX_INPUT_BIT";
        case static_cast<uint64_t>(8): return "VK_PIPELINE_STAGE_VERTEX_SHADER_BIT";
        case static_cast<uint64_t>(16): return "VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT";
        case static_cast<uint64_t>(32): return "VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT";
        case static_cast<uint64_t>(64): return "VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT";
        case static_cast<uint64_t>(128): return "VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT";
        case static_cast<uint64_t>(256): return "VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT";
        case static_cast<uint64_t>(512): return "VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT";
        case static_cast<uint64_t>(1024): return "VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT";
        case static_cast<uint64_t>(2048): return "VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT";
        case static_cast<uint64_t>(4096): return "VK_PIPELINE_STAGE_TRANSFER_BIT";
        case static_cast<uint64_t>(8192): return "VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT";
        case static_cast<uint64_t>(16384): return "VK_PIPELINE_STAGE_HOST_BIT";
        case static_cast<uint64_t>(32768): return "VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT";
        case static_cast<uint64_t>(65536): return "VK_PIPELINE_STAGE_ALL_COMMANDS_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(0): return "VK_PIPELINE_STAGE_NONE";
        case static_cast<uint64_t>(16777216): return "VK_PIPELINE_STAGE_TRANSFORM_FEEDBACK_BIT_EXT";
        case static_cast<uint64_t>(262144): return "VK_PIPELINE_STAGE_CONDITIONAL_RENDERING_BIT_EXT";
        case static_cast<uint64_t>(8388608): return "VK_PIPELINE_STAGE_FRAGMENT_DENSITY_PROCESS_BIT_EXT";
        case static_cast<uint64_t>(4194304): return "VK_PIPELINE_STAGE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_PIPELINE_STAGE_COMMAND_PREPROCESS_BIT_EXT";
        case static_cast<uint64_t>(33554432): return "VK_PIPELINE_STAGE_ACCELERATION_STRUCTURE_BUILD_BIT_KHR";
        case static_cast<uint64_t>(2097152): return "VK_PIPELINE_STAGE_RAY_TRACING_SHADER_BIT_KHR";
        case static_cast<uint64_t>(524288): return "VK_PIPELINE_STAGE_TASK_SHADER_BIT_EXT";
        case static_cast<uint64_t>(1048576): return "VK_PIPELINE_STAGE_MESH_SHADER_BIT_EXT";
        default: return "VkPipelineStageFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPointClippingBehavior>(VkPointClippingBehavior type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_POINT_CLIPPING_BEHAVIOR_ALL_CLIP_PLANES";
        case static_cast<uint64_t>(1): return "VK_POINT_CLIPPING_BEHAVIOR_USER_CLIP_PLANES_ONLY";
        case static_cast<uint64_t>(2147483647): return "VK_POINT_CLIPPING_BEHAVIOR_MAX_ENUM";
        default: return "VkPointClippingBehavior_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPolygonMode>(VkPolygonMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_POLYGON_MODE_FILL";
        case static_cast<uint64_t>(1): return "VK_POLYGON_MODE_LINE";
        case static_cast<uint64_t>(2): return "VK_POLYGON_MODE_POINT";
        case static_cast<uint64_t>(2147483647): return "VK_POLYGON_MODE_MAX_ENUM";
        case static_cast<uint64_t>(1000153000): return "VK_POLYGON_MODE_FILL_RECTANGLE_NV";
        default: return "VkPolygonMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPresentGravityFlagBitsKHR>(VkPresentGravityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PRESENT_GRAVITY_MIN_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_PRESENT_GRAVITY_MAX_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_PRESENT_GRAVITY_CENTERED_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PRESENT_GRAVITY_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkPresentGravityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPresentModeKHR>(VkPresentModeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PRESENT_MODE_IMMEDIATE_KHR";
        case static_cast<uint64_t>(1): return "VK_PRESENT_MODE_MAILBOX_KHR";
        case static_cast<uint64_t>(2): return "VK_PRESENT_MODE_FIFO_KHR";
        case static_cast<uint64_t>(3): return "VK_PRESENT_MODE_FIFO_RELAXED_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PRESENT_MODE_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1000111000): return "VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR";
        case static_cast<uint64_t>(1000111001): return "VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR";
        case static_cast<uint64_t>(1000361000): return "VK_PRESENT_MODE_FIFO_LATEST_READY_KHR";
        default: return "VkPresentModeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPresentScalingFlagBitsKHR>(VkPresentScalingFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_PRESENT_SCALING_ONE_TO_ONE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_PRESENT_SCALING_ASPECT_RATIO_STRETCH_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_PRESENT_SCALING_STRETCH_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_PRESENT_SCALING_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkPresentScalingFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkPrimitiveTopology>(VkPrimitiveTopology type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PRIMITIVE_TOPOLOGY_POINT_LIST";
        case static_cast<uint64_t>(1): return "VK_PRIMITIVE_TOPOLOGY_LINE_LIST";
        case static_cast<uint64_t>(2): return "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP";
        case static_cast<uint64_t>(3): return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST";
        case static_cast<uint64_t>(4): return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP";
        case static_cast<uint64_t>(5): return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN";
        case static_cast<uint64_t>(6): return "VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY";
        case static_cast<uint64_t>(7): return "VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY";
        case static_cast<uint64_t>(8): return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY";
        case static_cast<uint64_t>(9): return "VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY";
        case static_cast<uint64_t>(10): return "VK_PRIMITIVE_TOPOLOGY_PATCH_LIST";
        case static_cast<uint64_t>(2147483647): return "VK_PRIMITIVE_TOPOLOGY_MAX_ENUM";
        default: return "VkPrimitiveTopology_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkProvokingVertexModeEXT>(VkProvokingVertexModeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_PROVOKING_VERTEX_MODE_FIRST_VERTEX_EXT";
        case static_cast<uint64_t>(1): return "VK_PROVOKING_VERTEX_MODE_LAST_VERTEX_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_PROVOKING_VERTEX_MODE_EXT_MAX_ENUM";
        default: return "VkProvokingVertexModeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryControlFlagBits>(VkQueryControlFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_QUERY_CONTROL_PRECISE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM";
        default: return "VkQueryControlFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryPipelineStatisticFlagBits>(VkQueryPipelineStatisticFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT";
        case static_cast<uint64_t>(2): return "VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT";
        case static_cast<uint64_t>(4): return "VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT";
        case static_cast<uint64_t>(8): return "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT";
        case static_cast<uint64_t>(16): return "VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT";
        case static_cast<uint64_t>(32): return "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT";
        case static_cast<uint64_t>(64): return "VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT";
        case static_cast<uint64_t>(128): return "VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT";
        case static_cast<uint64_t>(256): return "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT";
        case static_cast<uint64_t>(512): return "VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT";
        case static_cast<uint64_t>(1024): return "VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(8192): return "VK_QUERY_PIPELINE_STATISTIC_CLUSTER_CULLING_SHADER_INVOCATIONS_BIT_HUAWEI";
        case static_cast<uint64_t>(2048): return "VK_QUERY_PIPELINE_STATISTIC_TASK_SHADER_INVOCATIONS_BIT_EXT";
        case static_cast<uint64_t>(4096): return "VK_QUERY_PIPELINE_STATISTIC_MESH_SHADER_INVOCATIONS_BIT_EXT";
        default: return "VkQueryPipelineStatisticFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryPoolCreateFlagBits>(VkQueryPoolCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_POOL_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_QUERY_POOL_CREATE_RESET_BIT_KHR";
        default: return "VkQueryPoolCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryPoolSamplingModeINTEL>(VkQueryPoolSamplingModeINTEL type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_QUERY_POOL_SAMPLING_MODE_MANUAL_INTEL";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_POOL_SAMPLING_MODE_INTEL_MAX_ENUM";
        default: return "VkQueryPoolSamplingModeINTEL_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryResultFlagBits>(VkQueryResultFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_QUERY_RESULT_64_BIT";
        case static_cast<uint64_t>(2): return "VK_QUERY_RESULT_WAIT_BIT";
        case static_cast<uint64_t>(4): return "VK_QUERY_RESULT_WITH_AVAILABILITY_BIT";
        case static_cast<uint64_t>(8): return "VK_QUERY_RESULT_PARTIAL_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(16): return "VK_QUERY_RESULT_WITH_STATUS_BIT_KHR";
        default: return "VkQueryResultFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryResultStatusKHR>(VkQueryResultStatusKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(-1): return "VK_QUERY_RESULT_STATUS_ERROR_KHR";
        case static_cast<uint64_t>(0): return "VK_QUERY_RESULT_STATUS_NOT_READY_KHR";
        case static_cast<uint64_t>(1): return "VK_QUERY_RESULT_STATUS_COMPLETE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_RESULT_STATUS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(-1000299000): return "VK_QUERY_RESULT_STATUS_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_KHR";
        default: return "VkQueryResultStatusKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueryType>(VkQueryType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_QUERY_TYPE_OCCLUSION";
        case static_cast<uint64_t>(1): return "VK_QUERY_TYPE_PIPELINE_STATISTICS";
        case static_cast<uint64_t>(2): return "VK_QUERY_TYPE_TIMESTAMP";
        case static_cast<uint64_t>(2147483647): return "VK_QUERY_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1000023000): return "VK_QUERY_TYPE_RESULT_STATUS_ONLY_KHR";
        case static_cast<uint64_t>(1000028004): return "VK_QUERY_TYPE_TRANSFORM_FEEDBACK_STREAM_EXT";
        case static_cast<uint64_t>(1000116000): return "VK_QUERY_TYPE_PERFORMANCE_QUERY_KHR";
        case static_cast<uint64_t>(1000165000): return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_NV";
        case static_cast<uint64_t>(1000210000): return "VK_QUERY_TYPE_PERFORMANCE_QUERY_INTEL";
        case static_cast<uint64_t>(1000299000): return "VK_QUERY_TYPE_VIDEO_ENCODE_FEEDBACK_KHR";
        case static_cast<uint64_t>(1000382000): return "VK_QUERY_TYPE_PRIMITIVES_GENERATED_EXT";
        case static_cast<uint64_t>(1000386000): return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_BOTTOM_LEVEL_POINTERS_KHR";
        case static_cast<uint64_t>(1000386001): return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SIZE_KHR";
        case static_cast<uint64_t>(1000396000): return "VK_QUERY_TYPE_MICROMAP_SERIALIZATION_SIZE_EXT";
        case static_cast<uint64_t>(1000396001): return "VK_QUERY_TYPE_MICROMAP_COMPACTED_SIZE_EXT";
        case static_cast<uint64_t>(1000150000): return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_COMPACTED_SIZE_KHR";
        case static_cast<uint64_t>(1000150001): return "VK_QUERY_TYPE_ACCELERATION_STRUCTURE_SERIALIZATION_SIZE_KHR";
        case static_cast<uint64_t>(1000328000): return "VK_QUERY_TYPE_MESH_PRIMITIVES_GENERATED_EXT";
        default: return "VkQueryType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueueFlagBits>(VkQueueFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_QUEUE_GRAPHICS_BIT";
        case static_cast<uint64_t>(2): return "VK_QUEUE_COMPUTE_BIT";
        case static_cast<uint64_t>(4): return "VK_QUEUE_TRANSFER_BIT";
        case static_cast<uint64_t>(8): return "VK_QUEUE_SPARSE_BINDING_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_QUEUE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(16): return "VK_QUEUE_PROTECTED_BIT";
        case static_cast<uint64_t>(32): return "VK_QUEUE_VIDEO_DECODE_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_QUEUE_VIDEO_ENCODE_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_QUEUE_OPTICAL_FLOW_BIT_NV";
        case static_cast<uint64_t>(1024): return "VK_QUEUE_DATA_GRAPH_BIT_ARM";
        default: return "VkQueueFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkQueueGlobalPriority>(VkQueueGlobalPriority type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(128): return "VK_QUEUE_GLOBAL_PRIORITY_LOW";
        case static_cast<uint64_t>(256): return "VK_QUEUE_GLOBAL_PRIORITY_MEDIUM";
        case static_cast<uint64_t>(512): return "VK_QUEUE_GLOBAL_PRIORITY_HIGH";
        case static_cast<uint64_t>(1024): return "VK_QUEUE_GLOBAL_PRIORITY_REALTIME";
        case static_cast<uint64_t>(2147483647): return "VK_QUEUE_GLOBAL_PRIORITY_MAX_ENUM";
        default: return "VkQueueGlobalPriority_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRasterizationOrderAMD>(VkRasterizationOrderAMD type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RASTERIZATION_ORDER_STRICT_AMD";
        case static_cast<uint64_t>(1): return "VK_RASTERIZATION_ORDER_RELAXED_AMD";
        case static_cast<uint64_t>(2147483647): return "VK_RASTERIZATION_ORDER_AMD_MAX_ENUM";
        default: return "VkRasterizationOrderAMD_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRayTracingInvocationReorderModeNV>(VkRayTracingInvocationReorderModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RAY_TRACING_INVOCATION_REORDER_MODE_NONE_NV";
        case static_cast<uint64_t>(1): return "VK_RAY_TRACING_INVOCATION_REORDER_MODE_REORDER_NV";
        case static_cast<uint64_t>(2147483647): return "VK_RAY_TRACING_INVOCATION_REORDER_MODE_NV_MAX_ENUM";
        default: return "VkRayTracingInvocationReorderModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRayTracingLssIndexingModeNV>(VkRayTracingLssIndexingModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RAY_TRACING_LSS_INDEXING_MODE_LIST_NV";
        case static_cast<uint64_t>(1): return "VK_RAY_TRACING_LSS_INDEXING_MODE_SUCCESSIVE_NV";
        case static_cast<uint64_t>(2147483647): return "VK_RAY_TRACING_LSS_INDEXING_MODE_NV_MAX_ENUM";
        default: return "VkRayTracingLssIndexingModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRayTracingLssPrimitiveEndCapsModeNV>(VkRayTracingLssPrimitiveEndCapsModeNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NONE_NV";
        case static_cast<uint64_t>(1): return "VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_CHAINED_NV";
        case static_cast<uint64_t>(2147483647): return "VK_RAY_TRACING_LSS_PRIMITIVE_END_CAPS_MODE_NV_MAX_ENUM";
        default: return "VkRayTracingLssPrimitiveEndCapsModeNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRayTracingShaderGroupTypeKHR>(VkRayTracingShaderGroupTypeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RAY_TRACING_SHADER_GROUP_TYPE_GENERAL_KHR";
        case static_cast<uint64_t>(1): return "VK_RAY_TRACING_SHADER_GROUP_TYPE_TRIANGLES_HIT_GROUP_KHR";
        case static_cast<uint64_t>(2): return "VK_RAY_TRACING_SHADER_GROUP_TYPE_PROCEDURAL_HIT_GROUP_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_RAY_TRACING_SHADER_GROUP_TYPE_KHR_MAX_ENUM";
        default: return "VkRayTracingShaderGroupTypeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRenderPassCreateFlagBits>(VkRenderPassCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_RENDER_PASS_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_RENDER_PASS_CREATE_TRANSFORM_BIT_QCOM";
        case static_cast<uint64_t>(4): return "VK_RENDER_PASS_CREATE_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE";
        default: return "VkRenderPassCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkRenderingFlagBits>(VkRenderingFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_RENDERING_CONTENTS_SECONDARY_COMMAND_BUFFERS_BIT";
        case static_cast<uint64_t>(2): return "VK_RENDERING_SUSPENDING_BIT";
        case static_cast<uint64_t>(4): return "VK_RENDERING_RESUMING_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_RENDERING_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(8): return "VK_RENDERING_ENABLE_LEGACY_DITHERING_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_RENDERING_CONTENTS_INLINE_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_RENDERING_PER_LAYER_FRAGMENT_DENSITY_BIT_VALVE";
        default: return "VkRenderingFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkResolveModeFlagBits>(VkResolveModeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_RESOLVE_MODE_NONE";
        case static_cast<uint64_t>(1): return "VK_RESOLVE_MODE_SAMPLE_ZERO_BIT";
        case static_cast<uint64_t>(2): return "VK_RESOLVE_MODE_AVERAGE_BIT";
        case static_cast<uint64_t>(4): return "VK_RESOLVE_MODE_MIN_BIT";
        case static_cast<uint64_t>(8): return "VK_RESOLVE_MODE_MAX_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_RESOLVE_MODE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(16): return "VK_RESOLVE_MODE_EXTERNAL_FORMAT_DOWNSAMPLE_BIT_ANDROID";
        default: return "VkResolveModeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkResult>(VkResult type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SUCCESS";
        case static_cast<uint64_t>(1): return "VK_NOT_READY";
        case static_cast<uint64_t>(2): return "VK_TIMEOUT";
        case static_cast<uint64_t>(3): return "VK_EVENT_SET";
        case static_cast<uint64_t>(4): return "VK_EVENT_RESET";
        case static_cast<uint64_t>(5): return "VK_INCOMPLETE";
        case static_cast<uint64_t>(-1): return "VK_ERROR_OUT_OF_HOST_MEMORY";
        case static_cast<uint64_t>(-2): return "VK_ERROR_OUT_OF_DEVICE_MEMORY";
        case static_cast<uint64_t>(-3): return "VK_ERROR_INITIALIZATION_FAILED";
        case static_cast<uint64_t>(-4): return "VK_ERROR_DEVICE_LOST";
        case static_cast<uint64_t>(-5): return "VK_ERROR_MEMORY_MAP_FAILED";
        case static_cast<uint64_t>(-6): return "VK_ERROR_LAYER_NOT_PRESENT";
        case static_cast<uint64_t>(-7): return "VK_ERROR_EXTENSION_NOT_PRESENT";
        case static_cast<uint64_t>(-8): return "VK_ERROR_FEATURE_NOT_PRESENT";
        case static_cast<uint64_t>(-9): return "VK_ERROR_INCOMPATIBLE_DRIVER";
        case static_cast<uint64_t>(-10): return "VK_ERROR_TOO_MANY_OBJECTS";
        case static_cast<uint64_t>(-11): return "VK_ERROR_FORMAT_NOT_SUPPORTED";
        case static_cast<uint64_t>(-12): return "VK_ERROR_FRAGMENTED_POOL";
        case static_cast<uint64_t>(-13): return "VK_ERROR_UNKNOWN";
        case static_cast<uint64_t>(2147483647): return "VK_RESULT_MAX_ENUM";
        case static_cast<uint64_t>(-1000069000): return "VK_ERROR_OUT_OF_POOL_MEMORY";
        case static_cast<uint64_t>(-1000072003): return "VK_ERROR_INVALID_EXTERNAL_HANDLE";
        case static_cast<uint64_t>(-1000161000): return "VK_ERROR_FRAGMENTATION";
        case static_cast<uint64_t>(-1000257000): return "VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS";
        case static_cast<uint64_t>(1000297000): return "VK_PIPELINE_COMPILE_REQUIRED";
        case static_cast<uint64_t>(-1000174001): return "VK_ERROR_NOT_PERMITTED";
        case static_cast<uint64_t>(-1000000000): return "VK_ERROR_SURFACE_LOST_KHR";
        case static_cast<uint64_t>(-1000000001): return "VK_ERROR_NATIVE_WINDOW_IN_USE_KHR";
        case static_cast<uint64_t>(1000001003): return "VK_SUBOPTIMAL_KHR";
        case static_cast<uint64_t>(-1000001004): return "VK_ERROR_OUT_OF_DATE_KHR";
        case static_cast<uint64_t>(-1000003001): return "VK_ERROR_INCOMPATIBLE_DISPLAY_KHR";
        case static_cast<uint64_t>(-1000011001): return "VK_ERROR_VALIDATION_FAILED_EXT";
        case static_cast<uint64_t>(-1000012000): return "VK_ERROR_INVALID_SHADER_NV";
        case static_cast<uint64_t>(-1000023000): return "VK_ERROR_IMAGE_USAGE_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000023001): return "VK_ERROR_VIDEO_PICTURE_LAYOUT_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000023002): return "VK_ERROR_VIDEO_PROFILE_OPERATION_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000023003): return "VK_ERROR_VIDEO_PROFILE_FORMAT_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000023004): return "VK_ERROR_VIDEO_PROFILE_CODEC_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000023005): return "VK_ERROR_VIDEO_STD_VERSION_NOT_SUPPORTED_KHR";
        case static_cast<uint64_t>(-1000158000): return "VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT";
        case static_cast<uint64_t>(-1000255000): return "VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT";
        case static_cast<uint64_t>(1000268000): return "VK_THREAD_IDLE_KHR";
        case static_cast<uint64_t>(1000268001): return "VK_THREAD_DONE_KHR";
        case static_cast<uint64_t>(1000268002): return "VK_OPERATION_DEFERRED_KHR";
        case static_cast<uint64_t>(1000268003): return "VK_OPERATION_NOT_DEFERRED_KHR";
        case static_cast<uint64_t>(-1000299000): return "VK_ERROR_INVALID_VIDEO_STD_PARAMETERS_KHR";
        case static_cast<uint64_t>(-1000338000): return "VK_ERROR_COMPRESSION_EXHAUSTED_EXT";
        case static_cast<uint64_t>(1000482000): return "VK_INCOMPATIBLE_SHADER_BINARY_EXT";
        case static_cast<uint64_t>(1000483000): return "VK_PIPELINE_BINARY_MISSING_KHR";
        case static_cast<uint64_t>(-1000483000): return "VK_ERROR_NOT_ENOUGH_SPACE_KHR";
        default: return "VkResult_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSampleCountFlagBits>(VkSampleCountFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SAMPLE_COUNT_1_BIT";
        case static_cast<uint64_t>(2): return "VK_SAMPLE_COUNT_2_BIT";
        case static_cast<uint64_t>(4): return "VK_SAMPLE_COUNT_4_BIT";
        case static_cast<uint64_t>(8): return "VK_SAMPLE_COUNT_8_BIT";
        case static_cast<uint64_t>(16): return "VK_SAMPLE_COUNT_16_BIT";
        case static_cast<uint64_t>(32): return "VK_SAMPLE_COUNT_32_BIT";
        case static_cast<uint64_t>(64): return "VK_SAMPLE_COUNT_64_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM";
        default: return "VkSampleCountFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerAddressMode>(VkSamplerAddressMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SAMPLER_ADDRESS_MODE_REPEAT";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT";
        case static_cast<uint64_t>(2): return "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE";
        case static_cast<uint64_t>(3): return "VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_ADDRESS_MODE_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE";
        default: return "VkSamplerAddressMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerCreateFlagBits>(VkSamplerCreateFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_CREATE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_CREATE_SUBSAMPLED_BIT_EXT";
        case static_cast<uint64_t>(2): return "VK_SAMPLER_CREATE_SUBSAMPLED_COARSE_RECONSTRUCTION_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_SAMPLER_CREATE_DESCRIPTOR_BUFFER_CAPTURE_REPLAY_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_SAMPLER_CREATE_NON_SEAMLESS_CUBE_MAP_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_SAMPLER_CREATE_IMAGE_PROCESSING_BIT_QCOM";
        default: return "VkSamplerCreateFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerMipmapMode>(VkSamplerMipmapMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SAMPLER_MIPMAP_MODE_NEAREST";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_MIPMAP_MODE_LINEAR";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_MIPMAP_MODE_MAX_ENUM";
        default: return "VkSamplerMipmapMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerReductionMode>(VkSamplerReductionMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_REDUCTION_MODE_MIN";
        case static_cast<uint64_t>(2): return "VK_SAMPLER_REDUCTION_MODE_MAX";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_REDUCTION_MODE_MAX_ENUM";
        case static_cast<uint64_t>(1000521000): return "VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_RANGECLAMP_QCOM";
        default: return "VkSamplerReductionMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerYcbcrModelConversion>(VkSamplerYcbcrModelConversion type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_RGB_IDENTITY";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_IDENTITY";
        case static_cast<uint64_t>(2): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_709";
        case static_cast<uint64_t>(3): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_601";
        case static_cast<uint64_t>(4): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_YCBCR_2020";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_YCBCR_MODEL_CONVERSION_MAX_ENUM";
        default: return "VkSamplerYcbcrModelConversion_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSamplerYcbcrRange>(VkSamplerYcbcrRange type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SAMPLER_YCBCR_RANGE_ITU_FULL";
        case static_cast<uint64_t>(1): return "VK_SAMPLER_YCBCR_RANGE_ITU_NARROW";
        case static_cast<uint64_t>(2147483647): return "VK_SAMPLER_YCBCR_RANGE_MAX_ENUM";
        default: return "VkSamplerYcbcrRange_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkScopeKHR>(VkScopeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SCOPE_DEVICE_KHR";
        case static_cast<uint64_t>(2): return "VK_SCOPE_WORKGROUP_KHR";
        case static_cast<uint64_t>(3): return "VK_SCOPE_SUBGROUP_KHR";
        case static_cast<uint64_t>(5): return "VK_SCOPE_QUEUE_FAMILY_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_SCOPE_KHR_MAX_ENUM";
        default: return "VkScopeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSemaphoreImportFlagBits>(VkSemaphoreImportFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SEMAPHORE_IMPORT_TEMPORARY_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM";
        default: return "VkSemaphoreImportFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSemaphoreType>(VkSemaphoreType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SEMAPHORE_TYPE_BINARY";
        case static_cast<uint64_t>(1): return "VK_SEMAPHORE_TYPE_TIMELINE";
        case static_cast<uint64_t>(2147483647): return "VK_SEMAPHORE_TYPE_MAX_ENUM";
        default: return "VkSemaphoreType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSemaphoreWaitFlagBits>(VkSemaphoreWaitFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SEMAPHORE_WAIT_ANY_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SEMAPHORE_WAIT_FLAG_BITS_MAX_ENUM";
        default: return "VkSemaphoreWaitFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderCodeTypeEXT>(VkShaderCodeTypeEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHADER_CODE_TYPE_BINARY_EXT";
        case static_cast<uint64_t>(1): return "VK_SHADER_CODE_TYPE_SPIRV_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_CODE_TYPE_EXT_MAX_ENUM";
        default: return "VkShaderCodeTypeEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderCreateFlagBitsEXT>(VkShaderCreateFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SHADER_CREATE_LINK_STAGE_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_CREATE_FLAG_BITS_EXT_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_SHADER_CREATE_ALLOW_VARYING_SUBGROUP_SIZE_BIT_EXT";
        case static_cast<uint64_t>(4): return "VK_SHADER_CREATE_REQUIRE_FULL_SUBGROUPS_BIT_EXT";
        case static_cast<uint64_t>(8): return "VK_SHADER_CREATE_NO_TASK_SHADER_BIT_EXT";
        case static_cast<uint64_t>(16): return "VK_SHADER_CREATE_DISPATCH_BASE_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_SHADER_CREATE_FRAGMENT_SHADING_RATE_ATTACHMENT_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_SHADER_CREATE_FRAGMENT_DENSITY_MAP_ATTACHMENT_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_SHADER_CREATE_INDIRECT_BINDABLE_BIT_EXT";
        default: return "VkShaderCreateFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderFloatControlsIndependence>(VkShaderFloatControlsIndependence type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_32_BIT_ONLY";
        case static_cast<uint64_t>(1): return "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_ALL";
        case static_cast<uint64_t>(2): return "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_NONE";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_FLOAT_CONTROLS_INDEPENDENCE_MAX_ENUM";
        default: return "VkShaderFloatControlsIndependence_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderGroupShaderKHR>(VkShaderGroupShaderKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHADER_GROUP_SHADER_GENERAL_KHR";
        case static_cast<uint64_t>(1): return "VK_SHADER_GROUP_SHADER_CLOSEST_HIT_KHR";
        case static_cast<uint64_t>(2): return "VK_SHADER_GROUP_SHADER_ANY_HIT_KHR";
        case static_cast<uint64_t>(3): return "VK_SHADER_GROUP_SHADER_INTERSECTION_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_GROUP_SHADER_KHR_MAX_ENUM";
        default: return "VkShaderGroupShaderKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderInfoTypeAMD>(VkShaderInfoTypeAMD type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHADER_INFO_TYPE_STATISTICS_AMD";
        case static_cast<uint64_t>(1): return "VK_SHADER_INFO_TYPE_BINARY_AMD";
        case static_cast<uint64_t>(2): return "VK_SHADER_INFO_TYPE_DISASSEMBLY_AMD";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_INFO_TYPE_AMD_MAX_ENUM";
        default: return "VkShaderInfoTypeAMD_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShaderStageFlagBits>(VkShaderStageFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SHADER_STAGE_VERTEX_BIT";
        case static_cast<uint64_t>(2): return "VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT";
        case static_cast<uint64_t>(4): return "VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT";
        case static_cast<uint64_t>(8): return "VK_SHADER_STAGE_GEOMETRY_BIT";
        case static_cast<uint64_t>(16): return "VK_SHADER_STAGE_FRAGMENT_BIT";
        case static_cast<uint64_t>(32): return "VK_SHADER_STAGE_COMPUTE_BIT";
        case static_cast<uint64_t>(31): return "VK_SHADER_STAGE_ALL_GRAPHICS";
        case static_cast<uint64_t>(2147483647): return "VK_SHADER_STAGE_ALL";
        case static_cast<uint64_t>(16384): return "VK_SHADER_STAGE_SUBPASS_SHADING_BIT_HUAWEI";
        case static_cast<uint64_t>(524288): return "VK_SHADER_STAGE_CLUSTER_CULLING_BIT_HUAWEI";
        case static_cast<uint64_t>(256): return "VK_SHADER_STAGE_RAYGEN_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_SHADER_STAGE_ANY_HIT_BIT_KHR";
        case static_cast<uint64_t>(1024): return "VK_SHADER_STAGE_CLOSEST_HIT_BIT_KHR";
        case static_cast<uint64_t>(2048): return "VK_SHADER_STAGE_MISS_BIT_KHR";
        case static_cast<uint64_t>(4096): return "VK_SHADER_STAGE_INTERSECTION_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_SHADER_STAGE_CALLABLE_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_SHADER_STAGE_TASK_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_SHADER_STAGE_MESH_BIT_EXT";
        default: return "VkShaderStageFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkShadingRatePaletteEntryNV>(VkShadingRatePaletteEntryNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHADING_RATE_PALETTE_ENTRY_NO_INVOCATIONS_NV";
        case static_cast<uint64_t>(1): return "VK_SHADING_RATE_PALETTE_ENTRY_16_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(2): return "VK_SHADING_RATE_PALETTE_ENTRY_8_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(3): return "VK_SHADING_RATE_PALETTE_ENTRY_4_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(4): return "VK_SHADING_RATE_PALETTE_ENTRY_2_INVOCATIONS_PER_PIXEL_NV";
        case static_cast<uint64_t>(5): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_PIXEL_NV";
        case static_cast<uint64_t>(6): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X1_PIXELS_NV";
        case static_cast<uint64_t>(7): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_1X2_PIXELS_NV";
        case static_cast<uint64_t>(8): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X2_PIXELS_NV";
        case static_cast<uint64_t>(9): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X2_PIXELS_NV";
        case static_cast<uint64_t>(10): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_2X4_PIXELS_NV";
        case static_cast<uint64_t>(11): return "VK_SHADING_RATE_PALETTE_ENTRY_1_INVOCATION_PER_4X4_PIXELS_NV";
        case static_cast<uint64_t>(2147483647): return "VK_SHADING_RATE_PALETTE_ENTRY_NV_MAX_ENUM";
        default: return "VkShadingRatePaletteEntryNV_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSharingMode>(VkSharingMode type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SHARING_MODE_EXCLUSIVE";
        case static_cast<uint64_t>(1): return "VK_SHARING_MODE_CONCURRENT";
        case static_cast<uint64_t>(2147483647): return "VK_SHARING_MODE_MAX_ENUM";
        default: return "VkSharingMode_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSparseImageFormatFlagBits>(VkSparseImageFormatFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT";
        case static_cast<uint64_t>(2): return "VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT";
        case static_cast<uint64_t>(4): return "VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM";
        default: return "VkSparseImageFormatFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSparseMemoryBindFlagBits>(VkSparseMemoryBindFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SPARSE_MEMORY_BIND_METADATA_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM";
        default: return "VkSparseMemoryBindFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkStencilFaceFlagBits>(VkStencilFaceFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_STENCIL_FACE_FRONT_BIT";
        case static_cast<uint64_t>(2): return "VK_STENCIL_FACE_BACK_BIT";
        case static_cast<uint64_t>(3): return "VK_STENCIL_FACE_FRONT_AND_BACK";
        case static_cast<uint64_t>(2147483647): return "VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM";
        default: return "VkStencilFaceFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkStencilOp>(VkStencilOp type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_STENCIL_OP_KEEP";
        case static_cast<uint64_t>(1): return "VK_STENCIL_OP_ZERO";
        case static_cast<uint64_t>(2): return "VK_STENCIL_OP_REPLACE";
        case static_cast<uint64_t>(3): return "VK_STENCIL_OP_INCREMENT_AND_CLAMP";
        case static_cast<uint64_t>(4): return "VK_STENCIL_OP_DECREMENT_AND_CLAMP";
        case static_cast<uint64_t>(5): return "VK_STENCIL_OP_INVERT";
        case static_cast<uint64_t>(6): return "VK_STENCIL_OP_INCREMENT_AND_WRAP";
        case static_cast<uint64_t>(7): return "VK_STENCIL_OP_DECREMENT_AND_WRAP";
        case static_cast<uint64_t>(2147483647): return "VK_STENCIL_OP_MAX_ENUM";
        default: return "VkStencilOp_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkStructureType>(VkStructureType type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_STRUCTURE_TYPE_APPLICATION_INFO";
        case static_cast<uint64_t>(1): return "VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO";
        case static_cast<uint64_t>(2): return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO";
        case static_cast<uint64_t>(3): return "VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO";
        case static_cast<uint64_t>(4): return "VK_STRUCTURE_TYPE_SUBMIT_INFO";
        case static_cast<uint64_t>(5): return "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO";
        case static_cast<uint64_t>(6): return "VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE";
        case static_cast<uint64_t>(7): return "VK_STRUCTURE_TYPE_BIND_SPARSE_INFO";
        case static_cast<uint64_t>(8): return "VK_STRUCTURE_TYPE_FENCE_CREATE_INFO";
        case static_cast<uint64_t>(9): return "VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO";
        case static_cast<uint64_t>(10): return "VK_STRUCTURE_TYPE_EVENT_CREATE_INFO";
        case static_cast<uint64_t>(11): return "VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO";
        case static_cast<uint64_t>(12): return "VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO";
        case static_cast<uint64_t>(13): return "VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO";
        case static_cast<uint64_t>(14): return "VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO";
        case static_cast<uint64_t>(15): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO";
        case static_cast<uint64_t>(16): return "VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO";
        case static_cast<uint64_t>(17): return "VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO";
        case static_cast<uint64_t>(18): return "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO";
        case static_cast<uint64_t>(19): return "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO";
        case static_cast<uint64_t>(20): return "VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO";
        case static_cast<uint64_t>(21): return "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO";
        case static_cast<uint64_t>(22): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO";
        case static_cast<uint64_t>(23): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO";
        case static_cast<uint64_t>(24): return "VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO";
        case static_cast<uint64_t>(25): return "VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO";
        case static_cast<uint64_t>(26): return "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO";
        case static_cast<uint64_t>(27): return "VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO";
        case static_cast<uint64_t>(28): return "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO";
        case static_cast<uint64_t>(29): return "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO";
        case static_cast<uint64_t>(30): return "VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO";
        case static_cast<uint64_t>(31): return "VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO";
        case static_cast<uint64_t>(32): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO";
        case static_cast<uint64_t>(33): return "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO";
        case static_cast<uint64_t>(34): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO";
        case static_cast<uint64_t>(35): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET";
        case static_cast<uint64_t>(36): return "VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET";
        case static_cast<uint64_t>(37): return "VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO";
        case static_cast<uint64_t>(38): return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO";
        case static_cast<uint64_t>(39): return "VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO";
        case static_cast<uint64_t>(40): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO";
        case static_cast<uint64_t>(41): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO";
        case static_cast<uint64_t>(42): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO";
        case static_cast<uint64_t>(43): return "VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO";
        case static_cast<uint64_t>(44): return "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER";
        case static_cast<uint64_t>(45): return "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER";
        case static_cast<uint64_t>(46): return "VK_STRUCTURE_TYPE_MEMORY_BARRIER";
        case static_cast<uint64_t>(47): return "VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO";
        case static_cast<uint64_t>(48): return "VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO";
        case static_cast<uint64_t>(2147483647): return "VK_STRUCTURE_TYPE_MAX_ENUM";
        case static_cast<uint64_t>(1000094000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES";
        case static_cast<uint64_t>(1000157000): return "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO";
        case static_cast<uint64_t>(1000157001): return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO";
        case static_cast<uint64_t>(1000083000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES";
        case static_cast<uint64_t>(1000127000): return "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS";
        case static_cast<uint64_t>(1000127001): return "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO";
        case static_cast<uint64_t>(1000060000): return "VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO";
        case static_cast<uint64_t>(1000060003): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO";
        case static_cast<uint64_t>(1000060004): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO";
        case static_cast<uint64_t>(1000060005): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO";
        case static_cast<uint64_t>(1000060006): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO";
        case static_cast<uint64_t>(1000060013): return "VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO";
        case static_cast<uint64_t>(1000060014): return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO";
        case static_cast<uint64_t>(1000070000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES";
        case static_cast<uint64_t>(1000070001): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO";
        case static_cast<uint64_t>(1000146000): return "VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2";
        case static_cast<uint64_t>(1000146001): return "VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2";
        case static_cast<uint64_t>(1000146002): return "VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2";
        case static_cast<uint64_t>(1000146003): return "VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2";
        case static_cast<uint64_t>(1000146004): return "VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2";
        case static_cast<uint64_t>(1000059000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2";
        case static_cast<uint64_t>(1000059001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2";
        case static_cast<uint64_t>(1000059002): return "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2";
        case static_cast<uint64_t>(1000059003): return "VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2";
        case static_cast<uint64_t>(1000059004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2";
        case static_cast<uint64_t>(1000059005): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2";
        case static_cast<uint64_t>(1000059006): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2";
        case static_cast<uint64_t>(1000059007): return "VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2";
        case static_cast<uint64_t>(1000059008): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2";
        case static_cast<uint64_t>(1000117000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES";
        case static_cast<uint64_t>(1000117001): return "VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO";
        case static_cast<uint64_t>(1000117002): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO";
        case static_cast<uint64_t>(1000117003): return "VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO";
        case static_cast<uint64_t>(1000053000): return "VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO";
        case static_cast<uint64_t>(1000053001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES";
        case static_cast<uint64_t>(1000053002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES";
        case static_cast<uint64_t>(1000120000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES";
        case static_cast<uint64_t>(1000145000): return "VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO";
        case static_cast<uint64_t>(1000145001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES";
        case static_cast<uint64_t>(1000145002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES";
        case static_cast<uint64_t>(1000145003): return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2";
        case static_cast<uint64_t>(1000156000): return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO";
        case static_cast<uint64_t>(1000156001): return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO";
        case static_cast<uint64_t>(1000156002): return "VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO";
        case static_cast<uint64_t>(1000156003): return "VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO";
        case static_cast<uint64_t>(1000156004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES";
        case static_cast<uint64_t>(1000156005): return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES";
        case static_cast<uint64_t>(1000085000): return "VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO";
        case static_cast<uint64_t>(1000071000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO";
        case static_cast<uint64_t>(1000071001): return "VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES";
        case static_cast<uint64_t>(1000071002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO";
        case static_cast<uint64_t>(1000071003): return "VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES";
        case static_cast<uint64_t>(1000071004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES";
        case static_cast<uint64_t>(1000072000): return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO";
        case static_cast<uint64_t>(1000072001): return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO";
        case static_cast<uint64_t>(1000072002): return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO";
        case static_cast<uint64_t>(1000112000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO";
        case static_cast<uint64_t>(1000112001): return "VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES";
        case static_cast<uint64_t>(1000113000): return "VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO";
        case static_cast<uint64_t>(1000077000): return "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO";
        case static_cast<uint64_t>(1000076000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO";
        case static_cast<uint64_t>(1000076001): return "VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES";
        case static_cast<uint64_t>(1000168000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES";
        case static_cast<uint64_t>(1000168001): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT";
        case static_cast<uint64_t>(1000063000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES";
        case static_cast<uint64_t>(49): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES";
        case static_cast<uint64_t>(50): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES";
        case static_cast<uint64_t>(51): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES";
        case static_cast<uint64_t>(52): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES";
        case static_cast<uint64_t>(1000147000): return "VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO";
        case static_cast<uint64_t>(1000109000): return "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2";
        case static_cast<uint64_t>(1000109001): return "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2";
        case static_cast<uint64_t>(1000109002): return "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2";
        case static_cast<uint64_t>(1000109003): return "VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2";
        case static_cast<uint64_t>(1000109004): return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2";
        case static_cast<uint64_t>(1000109005): return "VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO";
        case static_cast<uint64_t>(1000109006): return "VK_STRUCTURE_TYPE_SUBPASS_END_INFO";
        case static_cast<uint64_t>(1000177000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES";
        case static_cast<uint64_t>(1000196000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES";
        case static_cast<uint64_t>(1000180000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES";
        case static_cast<uint64_t>(1000082000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES";
        case static_cast<uint64_t>(1000197000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES";
        case static_cast<uint64_t>(1000161000): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO";
        case static_cast<uint64_t>(1000161001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES";
        case static_cast<uint64_t>(1000161002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES";
        case static_cast<uint64_t>(1000161003): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO";
        case static_cast<uint64_t>(1000161004): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT";
        case static_cast<uint64_t>(1000199000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES";
        case static_cast<uint64_t>(1000199001): return "VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE";
        case static_cast<uint64_t>(1000221000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES";
        case static_cast<uint64_t>(1000246000): return "VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO";
        case static_cast<uint64_t>(1000130000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES";
        case static_cast<uint64_t>(1000130001): return "VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO";
        case static_cast<uint64_t>(1000211000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES";
        case static_cast<uint64_t>(1000108000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES";
        case static_cast<uint64_t>(1000108001): return "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO";
        case static_cast<uint64_t>(1000108002): return "VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO";
        case static_cast<uint64_t>(1000108003): return "VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO";
        case static_cast<uint64_t>(1000253000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES";
        case static_cast<uint64_t>(1000175000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES";
        case static_cast<uint64_t>(1000241000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES";
        case static_cast<uint64_t>(1000241001): return "VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT";
        case static_cast<uint64_t>(1000241002): return "VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT";
        case static_cast<uint64_t>(1000261000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES";
        case static_cast<uint64_t>(1000207000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES";
        case static_cast<uint64_t>(1000207001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES";
        case static_cast<uint64_t>(1000207002): return "VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO";
        case static_cast<uint64_t>(1000207003): return "VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO";
        case static_cast<uint64_t>(1000207004): return "VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO";
        case static_cast<uint64_t>(1000207005): return "VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO";
        case static_cast<uint64_t>(1000257000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES";
        case static_cast<uint64_t>(1000244001): return "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO";
        case static_cast<uint64_t>(1000257002): return "VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO";
        case static_cast<uint64_t>(1000257003): return "VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO";
        case static_cast<uint64_t>(1000257004): return "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO";
        case static_cast<uint64_t>(53): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES";
        case static_cast<uint64_t>(54): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES";
        case static_cast<uint64_t>(1000192000): return "VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO";
        case static_cast<uint64_t>(1000215000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES";
        case static_cast<uint64_t>(1000245000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES";
        case static_cast<uint64_t>(1000276000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES";
        case static_cast<uint64_t>(1000295000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES";
        case static_cast<uint64_t>(1000295001): return "VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO";
        case static_cast<uint64_t>(1000295002): return "VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO";
        case static_cast<uint64_t>(1000297000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES";
        case static_cast<uint64_t>(1000314000): return "VK_STRUCTURE_TYPE_MEMORY_BARRIER_2";
        case static_cast<uint64_t>(1000314001): return "VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2";
        case static_cast<uint64_t>(1000314002): return "VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2";
        case static_cast<uint64_t>(1000314003): return "VK_STRUCTURE_TYPE_DEPENDENCY_INFO";
        case static_cast<uint64_t>(1000314004): return "VK_STRUCTURE_TYPE_SUBMIT_INFO_2";
        case static_cast<uint64_t>(1000314005): return "VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO";
        case static_cast<uint64_t>(1000314006): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO";
        case static_cast<uint64_t>(1000314007): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES";
        case static_cast<uint64_t>(1000325000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES";
        case static_cast<uint64_t>(1000335000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES";
        case static_cast<uint64_t>(1000337000): return "VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2";
        case static_cast<uint64_t>(1000337001): return "VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2";
        case static_cast<uint64_t>(1000337002): return "VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2";
        case static_cast<uint64_t>(1000337003): return "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2";
        case static_cast<uint64_t>(1000337004): return "VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2";
        case static_cast<uint64_t>(1000337005): return "VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2";
        case static_cast<uint64_t>(1000337006): return "VK_STRUCTURE_TYPE_BUFFER_COPY_2";
        case static_cast<uint64_t>(1000337007): return "VK_STRUCTURE_TYPE_IMAGE_COPY_2";
        case static_cast<uint64_t>(1000337008): return "VK_STRUCTURE_TYPE_IMAGE_BLIT_2";
        case static_cast<uint64_t>(1000337009): return "VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2";
        case static_cast<uint64_t>(1000337010): return "VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2";
        case static_cast<uint64_t>(1000225000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES";
        case static_cast<uint64_t>(1000225001): return "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO";
        case static_cast<uint64_t>(1000225002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES";
        case static_cast<uint64_t>(1000138000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES";
        case static_cast<uint64_t>(1000138001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES";
        case static_cast<uint64_t>(1000138002): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK";
        case static_cast<uint64_t>(1000138003): return "VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO";
        case static_cast<uint64_t>(1000066000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES";
        case static_cast<uint64_t>(1000044000): return "VK_STRUCTURE_TYPE_RENDERING_INFO";
        case static_cast<uint64_t>(1000044001): return "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO";
        case static_cast<uint64_t>(1000044002): return "VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO";
        case static_cast<uint64_t>(1000044003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES";
        case static_cast<uint64_t>(1000044004): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO";
        case static_cast<uint64_t>(1000280000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES";
        case static_cast<uint64_t>(1000280001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES";
        case static_cast<uint64_t>(1000281001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES";
        case static_cast<uint64_t>(1000360000): return "VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3";
        case static_cast<uint64_t>(1000413000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES";
        case static_cast<uint64_t>(1000413001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES";
        case static_cast<uint64_t>(1000413002): return "VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS";
        case static_cast<uint64_t>(1000413003): return "VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS";
        case static_cast<uint64_t>(55): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES";
        case static_cast<uint64_t>(56): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES";
        case static_cast<uint64_t>(1000174000): return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO";
        case static_cast<uint64_t>(1000388000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES";
        case static_cast<uint64_t>(1000388001): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES";
        case static_cast<uint64_t>(1000416000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES";
        case static_cast<uint64_t>(1000528000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES";
        case static_cast<uint64_t>(1000544000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES";
        case static_cast<uint64_t>(1000259000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES";
        case static_cast<uint64_t>(1000259001): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO";
        case static_cast<uint64_t>(1000259002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES";
        case static_cast<uint64_t>(1000525000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES";
        case static_cast<uint64_t>(1000190001): return "VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO";
        case static_cast<uint64_t>(1000190002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES";
        case static_cast<uint64_t>(1000265000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES";
        case static_cast<uint64_t>(1000271000): return "VK_STRUCTURE_TYPE_MEMORY_MAP_INFO";
        case static_cast<uint64_t>(1000271001): return "VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO";
        case static_cast<uint64_t>(1000470000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES";
        case static_cast<uint64_t>(1000470001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES";
        case static_cast<uint64_t>(1000470003): return "VK_STRUCTURE_TYPE_RENDERING_AREA_INFO";
        case static_cast<uint64_t>(1000470004): return "VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO";
        case static_cast<uint64_t>(1000338002): return "VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2";
        case static_cast<uint64_t>(1000338003): return "VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2";
        case static_cast<uint64_t>(1000470005): return "VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO";
        case static_cast<uint64_t>(1000470006): return "VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO";
        case static_cast<uint64_t>(1000080000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES";
        case static_cast<uint64_t>(1000232000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES";
        case static_cast<uint64_t>(1000232001): return "VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO";
        case static_cast<uint64_t>(1000232002): return "VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO";
        case static_cast<uint64_t>(1000545000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES";
        case static_cast<uint64_t>(1000545001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES";
        case static_cast<uint64_t>(1000545002): return "VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS";
        case static_cast<uint64_t>(1000545003): return "VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO";
        case static_cast<uint64_t>(1000545004): return "VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO";
        case static_cast<uint64_t>(1000545005): return "VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO";
        case static_cast<uint64_t>(1000545006): return "VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO";
        case static_cast<uint64_t>(1000466000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES";
        case static_cast<uint64_t>(1000068000): return "VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO";
        case static_cast<uint64_t>(1000068001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES";
        case static_cast<uint64_t>(1000068002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES";
        case static_cast<uint64_t>(1000270000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES";
        case static_cast<uint64_t>(1000270001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES";
        case static_cast<uint64_t>(1000270002): return "VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY";
        case static_cast<uint64_t>(1000270003): return "VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY";
        case static_cast<uint64_t>(1000270004): return "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO";
        case static_cast<uint64_t>(1000270005): return "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO";
        case static_cast<uint64_t>(1000270006): return "VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO";
        case static_cast<uint64_t>(1000270007): return "VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO";
        case static_cast<uint64_t>(1000270008): return "VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE";
        case static_cast<uint64_t>(1000270009): return "VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY";
        case static_cast<uint64_t>(1000001000): return "VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000001001): return "VK_STRUCTURE_TYPE_PRESENT_INFO_KHR";
        case static_cast<uint64_t>(1000060007): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000060008): return "VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000060009): return "VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR";
        case static_cast<uint64_t>(1000060010): return "VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR";
        case static_cast<uint64_t>(1000060011): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR";
        case static_cast<uint64_t>(1000060012): return "VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000002000): return "VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000002001): return "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000003000): return "VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR";
        case static_cast<uint64_t>(1000004000): return "VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000005000): return "VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000006000): return "VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000008000): return "VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000009000): return "VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000011000): return "VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000018000): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD";
        case static_cast<uint64_t>(1000022000): return "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT";
        case static_cast<uint64_t>(1000022001): return "VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT";
        case static_cast<uint64_t>(1000022002): return "VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT";
        case static_cast<uint64_t>(1000023000): return "VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000023001): return "VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000023002): return "VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR";
        case static_cast<uint64_t>(1000023003): return "VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR";
        case static_cast<uint64_t>(1000023004): return "VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR";
        case static_cast<uint64_t>(1000023005): return "VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000023006): return "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000023007): return "VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR";
        case static_cast<uint64_t>(1000023008): return "VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR";
        case static_cast<uint64_t>(1000023009): return "VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR";
        case static_cast<uint64_t>(1000023010): return "VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR";
        case static_cast<uint64_t>(1000023011): return "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000023012): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000023013): return "VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR";
        case static_cast<uint64_t>(1000023014): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR";
        case static_cast<uint64_t>(1000023015): return "VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000023016): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000024000): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR";
        case static_cast<uint64_t>(1000024001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000024002): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR";
        case static_cast<uint64_t>(1000026000): return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000026001): return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000026002): return "VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV";
        case static_cast<uint64_t>(1000028000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT";
        case static_cast<uint64_t>(1000028001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000028002): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000038000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000038001): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000038002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR";
        case static_cast<uint64_t>(1000038003): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000038004): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000038005): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR";
        case static_cast<uint64_t>(1000038006): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR";
        case static_cast<uint64_t>(1000038007): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000038008): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR";
        case static_cast<uint64_t>(1000038009): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR";
        case static_cast<uint64_t>(1000038010): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000038011): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000038012): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR";
        case static_cast<uint64_t>(1000038013): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR";
        case static_cast<uint64_t>(1000039000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000039001): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000039002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR";
        case static_cast<uint64_t>(1000039003): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000039004): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000039005): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR";
        case static_cast<uint64_t>(1000039006): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR";
        case static_cast<uint64_t>(1000039007): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000039009): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR";
        case static_cast<uint64_t>(1000039010): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR";
        case static_cast<uint64_t>(1000039011): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000039012): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000039013): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR";
        case static_cast<uint64_t>(1000039014): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR";
        case static_cast<uint64_t>(1000040000): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000040001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000040003): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000040004): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000040005): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR";
        case static_cast<uint64_t>(1000040006): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000041000): return "VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD";
        case static_cast<uint64_t>(1000049000): return "VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP";
        case static_cast<uint64_t>(1000050000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV";
        case static_cast<uint64_t>(1000056000): return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000056001): return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV";
        case static_cast<uint64_t>(1000057000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV";
        case static_cast<uint64_t>(1000057001): return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV";
        case static_cast<uint64_t>(1000058000): return "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV";
        case static_cast<uint64_t>(1000061000): return "VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT";
        case static_cast<uint64_t>(1000062000): return "VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN";
        case static_cast<uint64_t>(1000067000): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT";
        case static_cast<uint64_t>(1000067001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT";
        case static_cast<uint64_t>(1000073000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000073001): return "VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000073002): return "VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000073003): return "VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000074000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR";
        case static_cast<uint64_t>(1000074001): return "VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000074002): return "VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR";
        case static_cast<uint64_t>(1000075000): return "VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR";
        case static_cast<uint64_t>(1000078000): return "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000078001): return "VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000078002): return "VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR";
        case static_cast<uint64_t>(1000078003): return "VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000079000): return "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR";
        case static_cast<uint64_t>(1000079001): return "VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR";
        case static_cast<uint64_t>(1000081000): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT";
        case static_cast<uint64_t>(1000081001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT";
        case static_cast<uint64_t>(1000081002): return "VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT";
        case static_cast<uint64_t>(1000084000): return "VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR";
        case static_cast<uint64_t>(1000087000): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000090000): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT";
        case static_cast<uint64_t>(1000091000): return "VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT";
        case static_cast<uint64_t>(1000091001): return "VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT";
        case static_cast<uint64_t>(1000091002): return "VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT";
        case static_cast<uint64_t>(1000091003): return "VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000092000): return "VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE";
        case static_cast<uint64_t>(1000098000): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000099000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000099001): return "VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000101000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000101001): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000102000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT";
        case static_cast<uint64_t>(1000102001): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000105000): return "VK_STRUCTURE_TYPE_HDR_METADATA_EXT";
        case static_cast<uint64_t>(1000110000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG";
        case static_cast<uint64_t>(1000111000): return "VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000114000): return "VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000114001): return "VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000114002): return "VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR";
        case static_cast<uint64_t>(1000115000): return "VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR";
        case static_cast<uint64_t>(1000115001): return "VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR";
        case static_cast<uint64_t>(1000116000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR";
        case static_cast<uint64_t>(1000116001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000116002): return "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000116003): return "VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR";
        case static_cast<uint64_t>(1000116004): return "VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR";
        case static_cast<uint64_t>(1000116005): return "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR";
        case static_cast<uint64_t>(1000116006): return "VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR";
        case static_cast<uint64_t>(1000119000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR";
        case static_cast<uint64_t>(1000119001): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR";
        case static_cast<uint64_t>(1000119002): return "VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR";
        case static_cast<uint64_t>(1000121000): return "VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR";
        case static_cast<uint64_t>(1000121001): return "VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR";
        case static_cast<uint64_t>(1000121002): return "VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR";
        case static_cast<uint64_t>(1000121003): return "VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR";
        case static_cast<uint64_t>(1000121004): return "VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR";
        case static_cast<uint64_t>(1000122000): return "VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK";
        case static_cast<uint64_t>(1000123000): return "VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK";
        case static_cast<uint64_t>(1000128000): return "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT";
        case static_cast<uint64_t>(1000128001): return "VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT";
        case static_cast<uint64_t>(1000128002): return "VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT";
        case static_cast<uint64_t>(1000128003): return "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT";
        case static_cast<uint64_t>(1000128004): return "VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000129000): return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID";
        case static_cast<uint64_t>(1000129001): return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID";
        case static_cast<uint64_t>(1000129002): return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID";
        case static_cast<uint64_t>(1000129003): return "VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID";
        case static_cast<uint64_t>(1000129004): return "VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID";
        case static_cast<uint64_t>(1000129005): return "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID";
        case static_cast<uint64_t>(1000129006): return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID";
        case static_cast<uint64_t>(1000134000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX";
        case static_cast<uint64_t>(1000134001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX";
        case static_cast<uint64_t>(1000134002): return "VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX";
        case static_cast<uint64_t>(1000134003): return "VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX";
        case static_cast<uint64_t>(1000134004): return "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX";
        case static_cast<uint64_t>(1000044008): return "VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD";
        case static_cast<uint64_t>(1000141000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR";
        case static_cast<uint64_t>(1000143000): return "VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT";
        case static_cast<uint64_t>(1000143001): return "VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT";
        case static_cast<uint64_t>(1000143002): return "VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000143003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000143004): return "VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000148000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT";
        case static_cast<uint64_t>(1000148001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000148002): return "VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000149000): return "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000152000): return "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000154000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV";
        case static_cast<uint64_t>(1000154001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV";
        case static_cast<uint64_t>(1000158000): return "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT";
        case static_cast<uint64_t>(1000158002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT";
        case static_cast<uint64_t>(1000158003): return "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000158004): return "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000158005): return "VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000158006): return "VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT";
        case static_cast<uint64_t>(1000160000): return "VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000160001): return "VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000163000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR";
        case static_cast<uint64_t>(1000163001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000164000): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000164001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV";
        case static_cast<uint64_t>(1000164002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV";
        case static_cast<uint64_t>(1000164005): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000165000): return "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000165001): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000165003): return "VK_STRUCTURE_TYPE_GEOMETRY_NV";
        case static_cast<uint64_t>(1000165004): return "VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV";
        case static_cast<uint64_t>(1000165005): return "VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV";
        case static_cast<uint64_t>(1000165006): return "VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV";
        case static_cast<uint64_t>(1000165007): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV";
        case static_cast<uint64_t>(1000165008): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV";
        case static_cast<uint64_t>(1000165009): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV";
        case static_cast<uint64_t>(1000165011): return "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000165012): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV";
        case static_cast<uint64_t>(1000166000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV";
        case static_cast<uint64_t>(1000166001): return "VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000170000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT";
        case static_cast<uint64_t>(1000170001): return "VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000178000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT";
        case static_cast<uint64_t>(1000178001): return "VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000178002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000181000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR";
        case static_cast<uint64_t>(1000183000): return "VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD";
        case static_cast<uint64_t>(1000185000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD";
        case static_cast<uint64_t>(1000187000): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000187001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000187002): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR";
        case static_cast<uint64_t>(1000187003): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000187004): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000187005): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000189000): return "VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD";
        case static_cast<uint64_t>(1000190000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000191000): return "VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP";
        case static_cast<uint64_t>(1000202000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV";
        case static_cast<uint64_t>(1000202001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV";
        case static_cast<uint64_t>(1000204000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV";
        case static_cast<uint64_t>(1000205000): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000205002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV";
        case static_cast<uint64_t>(1000206000): return "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV";
        case static_cast<uint64_t>(1000206001): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV";
        case static_cast<uint64_t>(1000314008): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV";
        case static_cast<uint64_t>(1000314009): return "VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV";
        case static_cast<uint64_t>(1000209000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL";
        case static_cast<uint64_t>(1000210000): return "VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL";
        case static_cast<uint64_t>(1000210001): return "VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL";
        case static_cast<uint64_t>(1000210002): return "VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL";
        case static_cast<uint64_t>(1000210003): return "VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL";
        case static_cast<uint64_t>(1000210004): return "VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL";
        case static_cast<uint64_t>(1000210005): return "VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL";
        case static_cast<uint64_t>(1000212000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000213000): return "VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD";
        case static_cast<uint64_t>(1000213001): return "VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD";
        case static_cast<uint64_t>(1000214000): return "VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000217000): return "VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000218000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT";
        case static_cast<uint64_t>(1000218001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000218002): return "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000044007): return "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT";
        case static_cast<uint64_t>(1000226000): return "VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR";
        case static_cast<uint64_t>(1000226001): return "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000226002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000226003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR";
        case static_cast<uint64_t>(1000226004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR";
        case static_cast<uint64_t>(1000044006): return "VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR";
        case static_cast<uint64_t>(1000227000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD";
        case static_cast<uint64_t>(1000229000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD";
        case static_cast<uint64_t>(1000234000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT";
        case static_cast<uint64_t>(1000235000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR";
        case static_cast<uint64_t>(1000237000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000238000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT";
        case static_cast<uint64_t>(1000238001): return "VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT";
        case static_cast<uint64_t>(1000239000): return "VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000240000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV";
        case static_cast<uint64_t>(1000244000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT";
        case static_cast<uint64_t>(1000244002): return "VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000247000): return "VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT";
        case static_cast<uint64_t>(1000248000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR";
        case static_cast<uint64_t>(1000249000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV";
        case static_cast<uint64_t>(1000249001): return "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV";
        case static_cast<uint64_t>(1000249002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV";
        case static_cast<uint64_t>(1000250000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV";
        case static_cast<uint64_t>(1000250001): return "VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000250002): return "VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV";
        case static_cast<uint64_t>(1000251000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT";
        case static_cast<uint64_t>(1000252000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT";
        case static_cast<uint64_t>(1000254000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT";
        case static_cast<uint64_t>(1000254001): return "VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000254002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000255000): return "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT";
        case static_cast<uint64_t>(1000255002): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT";
        case static_cast<uint64_t>(1000255001): return "VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT";
        case static_cast<uint64_t>(1000256000): return "VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000260000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT";
        case static_cast<uint64_t>(1000267000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT";
        case static_cast<uint64_t>(1000269000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR";
        case static_cast<uint64_t>(1000269001): return "VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR";
        case static_cast<uint64_t>(1000269002): return "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000269003): return "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR";
        case static_cast<uint64_t>(1000269004): return "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR";
        case static_cast<uint64_t>(1000269005): return "VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR";
        case static_cast<uint64_t>(1000272000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT";
        case static_cast<uint64_t>(1000272001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000272002): return "VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT";
        case static_cast<uint64_t>(1000273000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT";
        case static_cast<uint64_t>(1000277000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV";
        case static_cast<uint64_t>(1000277001): return "VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000277002): return "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000277003): return "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV";
        case static_cast<uint64_t>(1000277004): return "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000277005): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV";
        case static_cast<uint64_t>(1000277006): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV";
        case static_cast<uint64_t>(1000277007): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV";
        case static_cast<uint64_t>(1000278000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV";
        case static_cast<uint64_t>(1000278001): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV";
        case static_cast<uint64_t>(1000281000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT";
        case static_cast<uint64_t>(1000282000): return "VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM";
        case static_cast<uint64_t>(1000282001): return "VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM";
        case static_cast<uint64_t>(1000283000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT";
        case static_cast<uint64_t>(1000283001): return "VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT";
        case static_cast<uint64_t>(1000283002): return "VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT";
        case static_cast<uint64_t>(1000284000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT";
        case static_cast<uint64_t>(1000284001): return "VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000284002): return "VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT";
        case static_cast<uint64_t>(1000287000): return "VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000287001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000287002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT";
        case static_cast<uint64_t>(1000290000): return "VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000292000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV";
        case static_cast<uint64_t>(1000292001): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV";
        case static_cast<uint64_t>(1000292002): return "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000294000): return "VK_STRUCTURE_TYPE_PRESENT_ID_KHR";
        case static_cast<uint64_t>(1000294001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR";
        case static_cast<uint64_t>(1000299000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR";
        case static_cast<uint64_t>(1000299001): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR";
        case static_cast<uint64_t>(1000299002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR";
        case static_cast<uint64_t>(1000299003): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000299004): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR";
        case static_cast<uint64_t>(1000299005): return "VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000299006): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR";
        case static_cast<uint64_t>(1000299007): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000299008): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR";
        case static_cast<uint64_t>(1000299009): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR";
        case static_cast<uint64_t>(1000299010): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR";
        case static_cast<uint64_t>(1000300000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV";
        case static_cast<uint64_t>(1000300001): return "VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000307000): return "VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000307001): return "VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000307002): return "VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV";
        case static_cast<uint64_t>(1000307003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV";
        case static_cast<uint64_t>(1000307004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV";
        case static_cast<uint64_t>(1000309000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM";
        case static_cast<uint64_t>(1000309001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM";
        case static_cast<uint64_t>(1000309002): return "VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM";
        case static_cast<uint64_t>(1000309003): return "VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM";
        case static_cast<uint64_t>(1000309004): return "VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM";
        case static_cast<uint64_t>(1000309005): return "VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM";
        case static_cast<uint64_t>(1000310000): return "VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV";
        case static_cast<uint64_t>(1000311000): return "VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000311001): return "VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT";
        case static_cast<uint64_t>(1000311002): return "VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT";
        case static_cast<uint64_t>(1000311003): return "VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT";
        case static_cast<uint64_t>(1000311004): return "VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT";
        case static_cast<uint64_t>(1000311005): return "VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT";
        case static_cast<uint64_t>(1000311006): return "VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT";
        case static_cast<uint64_t>(1000311007): return "VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT";
        case static_cast<uint64_t>(1000311008): return "VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT";
        case static_cast<uint64_t>(1000311009): return "VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT";
        case static_cast<uint64_t>(1000311010): return "VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT";
        case static_cast<uint64_t>(1000311011): return "VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT";
        case static_cast<uint64_t>(1000316000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000316001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000316002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT";
        case static_cast<uint64_t>(1000316003): return "VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT";
        case static_cast<uint64_t>(1000316004): return "VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT";
        case static_cast<uint64_t>(1000316005): return "VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT";
        case static_cast<uint64_t>(1000316006): return "VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT";
        case static_cast<uint64_t>(1000316007): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT";
        case static_cast<uint64_t>(1000316008): return "VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT";
        case static_cast<uint64_t>(1000316010): return "VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000316011): return "VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT";
        case static_cast<uint64_t>(1000316012): return "VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT";
        case static_cast<uint64_t>(1000316009): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT";
        case static_cast<uint64_t>(1000320000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT";
        case static_cast<uint64_t>(1000320001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000320002): return "VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000321000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD";
        case static_cast<uint64_t>(1000203000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR";
        case static_cast<uint64_t>(1000322000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000323000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR";
        case static_cast<uint64_t>(1000326000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV";
        case static_cast<uint64_t>(1000326001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV";
        case static_cast<uint64_t>(1000326002): return "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000327000): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV";
        case static_cast<uint64_t>(1000327001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV";
        case static_cast<uint64_t>(1000327002): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV";
        case static_cast<uint64_t>(1000330000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT";
        case static_cast<uint64_t>(1000332000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT";
        case static_cast<uint64_t>(1000332001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000333000): return "VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM";
        case static_cast<uint64_t>(1000336000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR";
        case static_cast<uint64_t>(1000338000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT";
        case static_cast<uint64_t>(1000338001): return "VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT";
        case static_cast<uint64_t>(1000338004): return "VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000339000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT";
        case static_cast<uint64_t>(1000340000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT";
        case static_cast<uint64_t>(1000341000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT";
        case static_cast<uint64_t>(1000341001): return "VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT";
        case static_cast<uint64_t>(1000341002): return "VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT";
        case static_cast<uint64_t>(1000344000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT";
        case static_cast<uint64_t>(1000346000): return "VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000352000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT";
        case static_cast<uint64_t>(1000352001): return "VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT";
        case static_cast<uint64_t>(1000352002): return "VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT";
        case static_cast<uint64_t>(1000353000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000354000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT";
        case static_cast<uint64_t>(1000354001): return "VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT";
        case static_cast<uint64_t>(1000355000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT";
        case static_cast<uint64_t>(1000355001): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000356000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT";
        case static_cast<uint64_t>(1000364000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000364001): return "VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA";
        case static_cast<uint64_t>(1000364002): return "VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000365000): return "VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000365001): return "VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366000): return "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366001): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA";
        case static_cast<uint64_t>(1000366002): return "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366003): return "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA";
        case static_cast<uint64_t>(1000366004): return "VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366005): return "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366006): return "VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366007): return "VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000366008): return "VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA";
        case static_cast<uint64_t>(1000366009): return "VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA";
        case static_cast<uint64_t>(1000369000): return "VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI";
        case static_cast<uint64_t>(1000369001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI";
        case static_cast<uint64_t>(1000369002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI";
        case static_cast<uint64_t>(1000370000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI";
        case static_cast<uint64_t>(1000371000): return "VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV";
        case static_cast<uint64_t>(1000371001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV";
        case static_cast<uint64_t>(1000372000): return "VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT";
        case static_cast<uint64_t>(1000372001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT";
        case static_cast<uint64_t>(1000375000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT";
        case static_cast<uint64_t>(1000375001): return "VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT";
        case static_cast<uint64_t>(1000376000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT";
        case static_cast<uint64_t>(1000376001): return "VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT";
        case static_cast<uint64_t>(1000376002): return "VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT";
        case static_cast<uint64_t>(1000377000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT";
        case static_cast<uint64_t>(1000378000): return "VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX";
        case static_cast<uint64_t>(1000381000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT";
        case static_cast<uint64_t>(1000381001): return "VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000382000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT";
        case static_cast<uint64_t>(1000386000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR";
        case static_cast<uint64_t>(1000391000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT";
        case static_cast<uint64_t>(1000391001): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000392000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT";
        case static_cast<uint64_t>(1000392001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000393000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT";
        case static_cast<uint64_t>(1000395000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT";
        case static_cast<uint64_t>(1000395001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000396000): return "VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT";
        case static_cast<uint64_t>(1000396001): return "VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT";
        case static_cast<uint64_t>(1000396002): return "VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT";
        case static_cast<uint64_t>(1000396003): return "VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT";
        case static_cast<uint64_t>(1000396004): return "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT";
        case static_cast<uint64_t>(1000396005): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT";
        case static_cast<uint64_t>(1000396006): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000396007): return "VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000396008): return "VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT";
        case static_cast<uint64_t>(1000396009): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT";
        case static_cast<uint64_t>(1000397000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV";
        case static_cast<uint64_t>(1000397001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV";
        case static_cast<uint64_t>(1000397002): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV";
        case static_cast<uint64_t>(1000404000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI";
        case static_cast<uint64_t>(1000404001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI";
        case static_cast<uint64_t>(1000404002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI";
        case static_cast<uint64_t>(1000411000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT";
        case static_cast<uint64_t>(1000411001): return "VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000412000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT";
        case static_cast<uint64_t>(1000415000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000417000): return "VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000417001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM";
        case static_cast<uint64_t>(1000417002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000418000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT";
        case static_cast<uint64_t>(1000418001): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000420000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE";
        case static_cast<uint64_t>(1000420001): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE";
        case static_cast<uint64_t>(1000420002): return "VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE";
        case static_cast<uint64_t>(1000422000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT";
        case static_cast<uint64_t>(1000424000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM";
        case static_cast<uint64_t>(1000424001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000424002): return "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM";
        case static_cast<uint64_t>(1000424003): return "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM";
        case static_cast<uint64_t>(1000424004): return "VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM";
        case static_cast<uint64_t>(1000426000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV";
        case static_cast<uint64_t>(1000426001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV";
        case static_cast<uint64_t>(1000427000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV";
        case static_cast<uint64_t>(1000427001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV";
        case static_cast<uint64_t>(1000428000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV";
        case static_cast<uint64_t>(1000428001): return "VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV";
        case static_cast<uint64_t>(1000428002): return "VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV";
        case static_cast<uint64_t>(1000429008): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV";
        case static_cast<uint64_t>(1000429009): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV";
        case static_cast<uint64_t>(1000429010): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV";
        case static_cast<uint64_t>(1000430000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV";
        case static_cast<uint64_t>(1000434000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR";
        case static_cast<uint64_t>(1000437000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT";
        case static_cast<uint64_t>(1000440000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM";
        case static_cast<uint64_t>(1000440001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM";
        case static_cast<uint64_t>(1000440002): return "VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM";
        case static_cast<uint64_t>(1000451000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT";
        case static_cast<uint64_t>(1000451001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000453000): return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT";
        case static_cast<uint64_t>(1000455000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT";
        case static_cast<uint64_t>(1000455001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000458000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT";
        case static_cast<uint64_t>(1000458001): return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT";
        case static_cast<uint64_t>(1000458002): return "VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000458003): return "VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000459000): return "VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG";
        case static_cast<uint64_t>(1000459001): return "VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG";
        case static_cast<uint64_t>(1000460000): return "VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000460001): return "VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000460002): return "VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM";
        case static_cast<uint64_t>(1000460003): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM";
        case static_cast<uint64_t>(1000460004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000460005): return "VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000460006): return "VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM";
        case static_cast<uint64_t>(1000460007): return "VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM";
        case static_cast<uint64_t>(1000460008): return "VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM";
        case static_cast<uint64_t>(1000460009): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM";
        case static_cast<uint64_t>(1000460010): return "VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM";
        case static_cast<uint64_t>(1000460011): return "VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM";
        case static_cast<uint64_t>(1000460012): return "VK_STRUCTURE_TYPE_TENSOR_COPY_ARM";
        case static_cast<uint64_t>(1000460013): return "VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM";
        case static_cast<uint64_t>(1000460014): return "VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM";
        case static_cast<uint64_t>(1000460015): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM";
        case static_cast<uint64_t>(1000460016): return "VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000460017): return "VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000460018): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM";
        case static_cast<uint64_t>(1000460019): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000460020): return "VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM";
        case static_cast<uint64_t>(1000460021): return "VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM";
        case static_cast<uint64_t>(1000460022): return "VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM";
        case static_cast<uint64_t>(1000460023): return "VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM";
        case static_cast<uint64_t>(1000462000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT";
        case static_cast<uint64_t>(1000462001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000462002): return "VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000462003): return "VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT";
        case static_cast<uint64_t>(1000342000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT";
        case static_cast<uint64_t>(1000464000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV";
        case static_cast<uint64_t>(1000464001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV";
        case static_cast<uint64_t>(1000464002): return "VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV";
        case static_cast<uint64_t>(1000464003): return "VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV";
        case static_cast<uint64_t>(1000464004): return "VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000464005): return "VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV";
        case static_cast<uint64_t>(1000464010): return "VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV";
        case static_cast<uint64_t>(1000465000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT";
        case static_cast<uint64_t>(1000468000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID";
        case static_cast<uint64_t>(1000468001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID";
        case static_cast<uint64_t>(1000468002): return "VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID";
        case static_cast<uint64_t>(1000476000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD";
        case static_cast<uint64_t>(1000476001): return "VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD";
        case static_cast<uint64_t>(1000476002): return "VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD";
        case static_cast<uint64_t>(1000479000): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR";
        case static_cast<uint64_t>(1000479001): return "VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR";
        case static_cast<uint64_t>(1000479002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR";
        case static_cast<uint64_t>(1000480000): return "VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR";
        case static_cast<uint64_t>(1000480001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR";
        case static_cast<uint64_t>(1000480002): return "VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR";
        case static_cast<uint64_t>(1000481000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR";
        case static_cast<uint64_t>(1000482000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT";
        case static_cast<uint64_t>(1000482001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000482002): return "VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000483000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR";
        case static_cast<uint64_t>(1000483001): return "VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000483002): return "VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR";
        case static_cast<uint64_t>(1000483003): return "VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR";
        case static_cast<uint64_t>(1000483004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000483005): return "VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR";
        case static_cast<uint64_t>(1000483006): return "VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR";
        case static_cast<uint64_t>(1000483007): return "VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000483008): return "VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR";
        case static_cast<uint64_t>(1000483009): return "VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR";
        case static_cast<uint64_t>(1000484000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM";
        case static_cast<uint64_t>(1000484001): return "VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM";
        case static_cast<uint64_t>(1000485000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC";
        case static_cast<uint64_t>(1000485001): return "VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC";
        case static_cast<uint64_t>(1000274000): return "VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR";
        case static_cast<uint64_t>(1000274001): return "VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000274002): return "VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR";
        case static_cast<uint64_t>(1000275000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR";
        case static_cast<uint64_t>(1000275001): return "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR";
        case static_cast<uint64_t>(1000275002): return "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000275003): return "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR";
        case static_cast<uint64_t>(1000275004): return "VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000275005): return "VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR";
        case static_cast<uint64_t>(1000488000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM";
        case static_cast<uint64_t>(1000490000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV";
        case static_cast<uint64_t>(1000490001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV";
        case static_cast<uint64_t>(1000491000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV";
        case static_cast<uint64_t>(1000491001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV";
        case static_cast<uint64_t>(1000491002): return "VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV";
        case static_cast<uint64_t>(1000491004): return "VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV";
        case static_cast<uint64_t>(1000492000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV";
        case static_cast<uint64_t>(1000492001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV";
        case static_cast<uint64_t>(1000351000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT";
        case static_cast<uint64_t>(1000351002): return "VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000495000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT";
        case static_cast<uint64_t>(1000495001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000496000): return "VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000497000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM";
        case static_cast<uint64_t>(1000497001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000498000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT";
        case static_cast<uint64_t>(1000499000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT";
        case static_cast<uint64_t>(1000505000): return "VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV";
        case static_cast<uint64_t>(1000505001): return "VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV";
        case static_cast<uint64_t>(1000505002): return "VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV";
        case static_cast<uint64_t>(1000505003): return "VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV";
        case static_cast<uint64_t>(1000505004): return "VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV";
        case static_cast<uint64_t>(1000505005): return "VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV";
        case static_cast<uint64_t>(1000505006): return "VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV";
        case static_cast<uint64_t>(1000505007): return "VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000505008): return "VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV";
        case static_cast<uint64_t>(1000506000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR";
        case static_cast<uint64_t>(1000506001): return "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000506002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000507000): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507001): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507002): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM";
        case static_cast<uint64_t>(1000507003): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM";
        case static_cast<uint64_t>(1000507004): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM";
        case static_cast<uint64_t>(1000507005): return "VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM";
        case static_cast<uint64_t>(1000507006): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM";
        case static_cast<uint64_t>(1000507007): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507008): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM";
        case static_cast<uint64_t>(1000507009): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM";
        case static_cast<uint64_t>(1000507010): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507011): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM";
        case static_cast<uint64_t>(1000507012): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM";
        case static_cast<uint64_t>(1000507013): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507014): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM";
        case static_cast<uint64_t>(1000507016): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM";
        case static_cast<uint64_t>(1000507017): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000507018): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM";
        case static_cast<uint64_t>(1000507019): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM";
        case static_cast<uint64_t>(1000507015): return "VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM";
        case static_cast<uint64_t>(1000510000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM";
        case static_cast<uint64_t>(1000510001): return "VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM";
        case static_cast<uint64_t>(1000201000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR";
        case static_cast<uint64_t>(1000511000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000512000): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000512001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000512003): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000512004): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000512005): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000513000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000513001): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000513002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000513003): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR";
        case static_cast<uint64_t>(1000513004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR";
        case static_cast<uint64_t>(1000513005): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000513006): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR";
        case static_cast<uint64_t>(1000513007): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR";
        case static_cast<uint64_t>(1000513008): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000513009): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000513010): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR";
        case static_cast<uint64_t>(1000514000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR";
        case static_cast<uint64_t>(1000514001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000514002): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR";
        case static_cast<uint64_t>(1000514003): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR";
        case static_cast<uint64_t>(1000515000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR";
        case static_cast<uint64_t>(1000515001): return "VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR";
        case static_cast<uint64_t>(1000516000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV";
        case static_cast<uint64_t>(1000518000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM";
        case static_cast<uint64_t>(1000518001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM";
        case static_cast<uint64_t>(1000518002): return "VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM";
        case static_cast<uint64_t>(1000519000): return "VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM";
        case static_cast<uint64_t>(1000519001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM";
        case static_cast<uint64_t>(1000519002): return "VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM";
        case static_cast<uint64_t>(1000520000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM";
        case static_cast<uint64_t>(1000520001): return "VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM";
        case static_cast<uint64_t>(1000521000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM";
        case static_cast<uint64_t>(1000524000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT";
        case static_cast<uint64_t>(1000527000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR";
        case static_cast<uint64_t>(1000527001): return "VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT";
        case static_cast<uint64_t>(1000529000): return "VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX";
        case static_cast<uint64_t>(1000529001): return "VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX";
        case static_cast<uint64_t>(1000529002): return "VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX";
        case static_cast<uint64_t>(1000529003): return "VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX";
        case static_cast<uint64_t>(1000529004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX";
        case static_cast<uint64_t>(1000530000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT";
        case static_cast<uint64_t>(1000184000): return "VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR";
        case static_cast<uint64_t>(1000545007): return "VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT";
        case static_cast<uint64_t>(1000545008): return "VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT";
        case static_cast<uint64_t>(1000546000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV";
        case static_cast<uint64_t>(1000547000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM";
        case static_cast<uint64_t>(1000547001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM";
        case static_cast<uint64_t>(1000547002): return "VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM";
        case static_cast<uint64_t>(1000547003): return "VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM";
        case static_cast<uint64_t>(1000547004): return "VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM";
        case static_cast<uint64_t>(1000551000): return "VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000551001): return "VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV";
        case static_cast<uint64_t>(1000552000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000552001): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000552002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR";
        case static_cast<uint64_t>(1000552003): return "VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR";
        case static_cast<uint64_t>(1000552004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR";
        case static_cast<uint64_t>(1000553000): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000553001): return "VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000553002): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR";
        case static_cast<uint64_t>(1000553005): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000553009): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR";
        case static_cast<uint64_t>(1000553003): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000553004): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000553006): return "VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000553007): return "VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR";
        case static_cast<uint64_t>(1000553008): return "VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000555000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV";
        case static_cast<uint64_t>(1000556000): return "VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000556001): return "VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000556002): return "VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV";
        case static_cast<uint64_t>(1000556003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV";
        case static_cast<uint64_t>(1000558000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR";
        case static_cast<uint64_t>(1000559000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV";
        case static_cast<uint64_t>(1000562000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR";
        case static_cast<uint64_t>(1000562001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000562002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR";
        case static_cast<uint64_t>(1000562003): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000562004): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000563000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV";
        case static_cast<uint64_t>(1000564000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT";
        case static_cast<uint64_t>(1000567000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT";
        case static_cast<uint64_t>(1000568000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV";
        case static_cast<uint64_t>(1000569000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV";
        case static_cast<uint64_t>(1000569001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV";
        case static_cast<uint64_t>(1000569002): return "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV";
        case static_cast<uint64_t>(1000569003): return "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV";
        case static_cast<uint64_t>(1000569004): return "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV";
        case static_cast<uint64_t>(1000569005): return "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV";
        case static_cast<uint64_t>(1000569006): return "VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV";
        case static_cast<uint64_t>(1000569007): return "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV";
        case static_cast<uint64_t>(1000570000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV";
        case static_cast<uint64_t>(1000570001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV";
        case static_cast<uint64_t>(1000570002): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV";
        case static_cast<uint64_t>(1000570003): return "VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV";
        case static_cast<uint64_t>(1000570004): return "VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV";
        case static_cast<uint64_t>(1000570005): return "VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV";
        case static_cast<uint64_t>(1000572000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT";
        case static_cast<uint64_t>(1000572001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000572002): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT";
        case static_cast<uint64_t>(1000572003): return "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000572004): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT";
        case static_cast<uint64_t>(1000572006): return "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000572007): return "VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT";
        case static_cast<uint64_t>(1000572008): return "VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT";
        case static_cast<uint64_t>(1000572009): return "VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT";
        case static_cast<uint64_t>(1000572010): return "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT";
        case static_cast<uint64_t>(1000572011): return "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT";
        case static_cast<uint64_t>(1000572012): return "VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT";
        case static_cast<uint64_t>(1000572013): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT";
        case static_cast<uint64_t>(1000572014): return "VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT";
        case static_cast<uint64_t>(1000574000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR";
        case static_cast<uint64_t>(1000574002): return "VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR";
        case static_cast<uint64_t>(1000575000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA";
        case static_cast<uint64_t>(1000575001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA";
        case static_cast<uint64_t>(1000575002): return "VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA";
        case static_cast<uint64_t>(1000582000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT";
        case static_cast<uint64_t>(1000582001): return "VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT";
        case static_cast<uint64_t>(1000584000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR";
        case static_cast<uint64_t>(1000584001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000584002): return "VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000586000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR";
        case static_cast<uint64_t>(1000586001): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR";
        case static_cast<uint64_t>(1000586002): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR";
        case static_cast<uint64_t>(1000586003): return "VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR";
        case static_cast<uint64_t>(1000587000): return "VK_STRUCTURE_TYPE_OH_SURFACE_CREATE_INFO_OHOS";
        case static_cast<uint64_t>(1000590000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI";
        case static_cast<uint64_t>(1000590001): return "VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI";
        case static_cast<uint64_t>(1000593000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV";
        case static_cast<uint64_t>(1000593001): return "VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV";
        case static_cast<uint64_t>(1000593002): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV";
        case static_cast<uint64_t>(1000596000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM";
        case static_cast<uint64_t>(1000602000): return "VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT";
        case static_cast<uint64_t>(1000602001): return "VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000602002): return "VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT";
        case static_cast<uint64_t>(1000421000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR";
        case static_cast<uint64_t>(1000608000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT";
        case static_cast<uint64_t>(1000609000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM";
        case static_cast<uint64_t>(1000611000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE";
        case static_cast<uint64_t>(1000611001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE";
        case static_cast<uint64_t>(1000611002): return "VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE";
        case static_cast<uint64_t>(1000286000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR";
        case static_cast<uint64_t>(1000286001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000613000): return "VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV";
        case static_cast<uint64_t>(1000613001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV";
        case static_cast<uint64_t>(1000425000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT";
        case static_cast<uint64_t>(1000425001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT";
        case static_cast<uint64_t>(1000425002): return "VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT";
        case static_cast<uint64_t>(1000619003): return "VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT";
        case static_cast<uint64_t>(1000620000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT";
        case static_cast<uint64_t>(1000361000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR";
        case static_cast<uint64_t>(1000637000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC";
        case static_cast<uint64_t>(1000150007): return "VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR";
        case static_cast<uint64_t>(1000150000): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR";
        case static_cast<uint64_t>(1000150002): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR";
        case static_cast<uint64_t>(1000150003): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR";
        case static_cast<uint64_t>(1000150004): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR";
        case static_cast<uint64_t>(1000150005): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR";
        case static_cast<uint64_t>(1000150006): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR";
        case static_cast<uint64_t>(1000150009): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR";
        case static_cast<uint64_t>(1000150010): return "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR";
        case static_cast<uint64_t>(1000150011): return "VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR";
        case static_cast<uint64_t>(1000150012): return "VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR";
        case static_cast<uint64_t>(1000150013): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR";
        case static_cast<uint64_t>(1000150014): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000150017): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000150020): return "VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR";
        case static_cast<uint64_t>(1000347000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR";
        case static_cast<uint64_t>(1000347001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR";
        case static_cast<uint64_t>(1000150015): return "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000150016): return "VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000150018): return "VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR";
        case static_cast<uint64_t>(1000348013): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR";
        case static_cast<uint64_t>(1000328000): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT";
        case static_cast<uint64_t>(1000328001): return "VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT";
        default: return "VkStructureType_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSubgroupFeatureFlagBits>(VkSubgroupFeatureFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SUBGROUP_FEATURE_BASIC_BIT";
        case static_cast<uint64_t>(2): return "VK_SUBGROUP_FEATURE_VOTE_BIT";
        case static_cast<uint64_t>(4): return "VK_SUBGROUP_FEATURE_ARITHMETIC_BIT";
        case static_cast<uint64_t>(8): return "VK_SUBGROUP_FEATURE_BALLOT_BIT";
        case static_cast<uint64_t>(16): return "VK_SUBGROUP_FEATURE_SHUFFLE_BIT";
        case static_cast<uint64_t>(32): return "VK_SUBGROUP_FEATURE_SHUFFLE_RELATIVE_BIT";
        case static_cast<uint64_t>(64): return "VK_SUBGROUP_FEATURE_CLUSTERED_BIT";
        case static_cast<uint64_t>(128): return "VK_SUBGROUP_FEATURE_QUAD_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SUBGROUP_FEATURE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(512): return "VK_SUBGROUP_FEATURE_ROTATE_BIT";
        case static_cast<uint64_t>(1024): return "VK_SUBGROUP_FEATURE_ROTATE_CLUSTERED_BIT";
        case static_cast<uint64_t>(256): return "VK_SUBGROUP_FEATURE_PARTITIONED_BIT_NV";
        default: return "VkSubgroupFeatureFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSubmitFlagBits>(VkSubmitFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SUBMIT_PROTECTED_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_SUBMIT_FLAG_BITS_MAX_ENUM";
        default: return "VkSubmitFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSubpassContents>(VkSubpassContents type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SUBPASS_CONTENTS_INLINE";
        case static_cast<uint64_t>(1): return "VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS";
        case static_cast<uint64_t>(2147483647): return "VK_SUBPASS_CONTENTS_MAX_ENUM";
        case static_cast<uint64_t>(1000451000): return "VK_SUBPASS_CONTENTS_INLINE_AND_SECONDARY_COMMAND_BUFFERS_KHR";
        default: return "VkSubpassContents_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSubpassDescriptionFlagBits>(VkSubpassDescriptionFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_SUBPASS_DESCRIPTION_FRAGMENT_REGION_BIT_QCOM";
        case static_cast<uint64_t>(8): return "VK_SUBPASS_DESCRIPTION_SHADER_RESOLVE_BIT_QCOM";
        case static_cast<uint64_t>(256): return "VK_SUBPASS_DESCRIPTION_TILE_SHADING_APRON_BIT_QCOM";
        case static_cast<uint64_t>(16): return "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_COLOR_ACCESS_BIT_EXT";
        case static_cast<uint64_t>(32): return "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_DEPTH_ACCESS_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_SUBPASS_DESCRIPTION_RASTERIZATION_ORDER_ATTACHMENT_STENCIL_ACCESS_BIT_EXT";
        case static_cast<uint64_t>(128): return "VK_SUBPASS_DESCRIPTION_ENABLE_LEGACY_DITHERING_BIT_EXT";
        default: return "VkSubpassDescriptionFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSubpassMergeStatusEXT>(VkSubpassMergeStatusEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SUBPASS_MERGE_STATUS_MERGED_EXT";
        case static_cast<uint64_t>(1): return "VK_SUBPASS_MERGE_STATUS_DISALLOWED_EXT";
        case static_cast<uint64_t>(2): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SIDE_EFFECTS_EXT";
        case static_cast<uint64_t>(3): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SAMPLES_MISMATCH_EXT";
        case static_cast<uint64_t>(4): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_VIEWS_MISMATCH_EXT";
        case static_cast<uint64_t>(5): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_ALIASING_EXT";
        case static_cast<uint64_t>(6): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPENDENCIES_EXT";
        case static_cast<uint64_t>(7): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INCOMPATIBLE_INPUT_ATTACHMENT_EXT";
        case static_cast<uint64_t>(8): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_TOO_MANY_ATTACHMENTS_EXT";
        case static_cast<uint64_t>(9): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_INSUFFICIENT_STORAGE_EXT";
        case static_cast<uint64_t>(10): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_DEPTH_STENCIL_COUNT_EXT";
        case static_cast<uint64_t>(11): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_RESOLVE_ATTACHMENT_REUSE_EXT";
        case static_cast<uint64_t>(12): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_SINGLE_SUBPASS_EXT";
        case static_cast<uint64_t>(13): return "VK_SUBPASS_MERGE_STATUS_NOT_MERGED_UNSPECIFIED_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_SUBPASS_MERGE_STATUS_EXT_MAX_ENUM";
        default: return "VkSubpassMergeStatusEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSurfaceCounterFlagBitsEXT>(VkSurfaceCounterFlagBitsEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SURFACE_COUNTER_VBLANK_BIT_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_SURFACE_COUNTER_FLAG_BITS_EXT_MAX_ENUM";
        default: return "VkSurfaceCounterFlagBitsEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSurfaceTransformFlagBitsKHR>(VkSurfaceTransformFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_SURFACE_TRANSFORM_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkSurfaceTransformFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSwapchainCreateFlagBitsKHR>(VkSwapchainCreateFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_SWAPCHAIN_CREATE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_SWAPCHAIN_CREATE_SPLIT_INSTANCE_BIND_REGIONS_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_SWAPCHAIN_CREATE_PROTECTED_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_SWAPCHAIN_CREATE_MUTABLE_FORMAT_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_SWAPCHAIN_CREATE_PRESENT_ID_2_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_SWAPCHAIN_CREATE_PRESENT_WAIT_2_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_SWAPCHAIN_CREATE_DEFERRED_MEMORY_ALLOCATION_BIT_KHR";
        default: return "VkSwapchainCreateFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkSystemAllocationScope>(VkSystemAllocationScope type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_SYSTEM_ALLOCATION_SCOPE_COMMAND";
        case static_cast<uint64_t>(1): return "VK_SYSTEM_ALLOCATION_SCOPE_OBJECT";
        case static_cast<uint64_t>(2): return "VK_SYSTEM_ALLOCATION_SCOPE_CACHE";
        case static_cast<uint64_t>(3): return "VK_SYSTEM_ALLOCATION_SCOPE_DEVICE";
        case static_cast<uint64_t>(4): return "VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE";
        case static_cast<uint64_t>(2147483647): return "VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM";
        default: return "VkSystemAllocationScope_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkTensorTilingARM>(VkTensorTilingARM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_TENSOR_TILING_OPTIMAL_ARM";
        case static_cast<uint64_t>(1): return "VK_TENSOR_TILING_LINEAR_ARM";
        case static_cast<uint64_t>(2147483647): return "VK_TENSOR_TILING_ARM_MAX_ENUM";
        default: return "VkTensorTilingARM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkTessellationDomainOrigin>(VkTessellationDomainOrigin type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_TESSELLATION_DOMAIN_ORIGIN_UPPER_LEFT";
        case static_cast<uint64_t>(1): return "VK_TESSELLATION_DOMAIN_ORIGIN_LOWER_LEFT";
        case static_cast<uint64_t>(2147483647): return "VK_TESSELLATION_DOMAIN_ORIGIN_MAX_ENUM";
        default: return "VkTessellationDomainOrigin_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkTileShadingRenderPassFlagBitsQCOM>(VkTileShadingRenderPassFlagBitsQCOM type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_TILE_SHADING_RENDER_PASS_ENABLE_BIT_QCOM";
        case static_cast<uint64_t>(2): return "VK_TILE_SHADING_RENDER_PASS_PER_TILE_EXECUTION_BIT_QCOM";
        case static_cast<uint64_t>(2147483647): return "VK_TILE_SHADING_RENDER_PASS_FLAG_BITS_QCOM_MAX_ENUM";
        default: return "VkTileShadingRenderPassFlagBitsQCOM_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkTimeDomainKHR>(VkTimeDomainKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_TIME_DOMAIN_DEVICE_KHR";
        case static_cast<uint64_t>(1): return "VK_TIME_DOMAIN_CLOCK_MONOTONIC_KHR";
        case static_cast<uint64_t>(2): return "VK_TIME_DOMAIN_CLOCK_MONOTONIC_RAW_KHR";
        case static_cast<uint64_t>(3): return "VK_TIME_DOMAIN_QUERY_PERFORMANCE_COUNTER_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_TIME_DOMAIN_KHR_MAX_ENUM";
        default: return "VkTimeDomainKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkToolPurposeFlagBits>(VkToolPurposeFlagBits type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_TOOL_PURPOSE_VALIDATION_BIT";
        case static_cast<uint64_t>(2): return "VK_TOOL_PURPOSE_PROFILING_BIT";
        case static_cast<uint64_t>(4): return "VK_TOOL_PURPOSE_TRACING_BIT";
        case static_cast<uint64_t>(8): return "VK_TOOL_PURPOSE_ADDITIONAL_FEATURES_BIT";
        case static_cast<uint64_t>(16): return "VK_TOOL_PURPOSE_MODIFYING_FEATURES_BIT";
        case static_cast<uint64_t>(2147483647): return "VK_TOOL_PURPOSE_FLAG_BITS_MAX_ENUM";
        case static_cast<uint64_t>(32): return "VK_TOOL_PURPOSE_DEBUG_REPORTING_BIT_EXT";
        case static_cast<uint64_t>(64): return "VK_TOOL_PURPOSE_DEBUG_MARKERS_BIT_EXT";
        default: return "VkToolPurposeFlagBits_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkValidationCacheHeaderVersionEXT>(VkValidationCacheHeaderVersionEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VALIDATION_CACHE_HEADER_VERSION_ONE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_VALIDATION_CACHE_HEADER_VERSION_EXT_MAX_ENUM";
        default: return "VkValidationCacheHeaderVersionEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkValidationCheckEXT>(VkValidationCheckEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VALIDATION_CHECK_ALL_EXT";
        case static_cast<uint64_t>(1): return "VK_VALIDATION_CHECK_SHADERS_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_VALIDATION_CHECK_EXT_MAX_ENUM";
        default: return "VkValidationCheckEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkValidationFeatureDisableEXT>(VkValidationFeatureDisableEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VALIDATION_FEATURE_DISABLE_ALL_EXT";
        case static_cast<uint64_t>(1): return "VK_VALIDATION_FEATURE_DISABLE_SHADERS_EXT";
        case static_cast<uint64_t>(2): return "VK_VALIDATION_FEATURE_DISABLE_THREAD_SAFETY_EXT";
        case static_cast<uint64_t>(3): return "VK_VALIDATION_FEATURE_DISABLE_API_PARAMETERS_EXT";
        case static_cast<uint64_t>(4): return "VK_VALIDATION_FEATURE_DISABLE_OBJECT_LIFETIMES_EXT";
        case static_cast<uint64_t>(5): return "VK_VALIDATION_FEATURE_DISABLE_CORE_CHECKS_EXT";
        case static_cast<uint64_t>(6): return "VK_VALIDATION_FEATURE_DISABLE_UNIQUE_HANDLES_EXT";
        case static_cast<uint64_t>(7): return "VK_VALIDATION_FEATURE_DISABLE_SHADER_VALIDATION_CACHE_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_VALIDATION_FEATURE_DISABLE_EXT_MAX_ENUM";
        default: return "VkValidationFeatureDisableEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkValidationFeatureEnableEXT>(VkValidationFeatureEnableEXT type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_EXT";
        case static_cast<uint64_t>(1): return "VK_VALIDATION_FEATURE_ENABLE_GPU_ASSISTED_RESERVE_BINDING_SLOT_EXT";
        case static_cast<uint64_t>(2): return "VK_VALIDATION_FEATURE_ENABLE_BEST_PRACTICES_EXT";
        case static_cast<uint64_t>(3): return "VK_VALIDATION_FEATURE_ENABLE_DEBUG_PRINTF_EXT";
        case static_cast<uint64_t>(4): return "VK_VALIDATION_FEATURE_ENABLE_SYNCHRONIZATION_VALIDATION_EXT";
        case static_cast<uint64_t>(2147483647): return "VK_VALIDATION_FEATURE_ENABLE_EXT_MAX_ENUM";
        default: return "VkValidationFeatureEnableEXT_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVendorId>(VkVendorId type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(65536): return "VK_VENDOR_ID_KHRONOS";
        case static_cast<uint64_t>(65537): return "VK_VENDOR_ID_VIV";
        case static_cast<uint64_t>(65538): return "VK_VENDOR_ID_VSI";
        case static_cast<uint64_t>(65539): return "VK_VENDOR_ID_KAZAN";
        case static_cast<uint64_t>(65540): return "VK_VENDOR_ID_CODEPLAY";
        case static_cast<uint64_t>(65541): return "VK_VENDOR_ID_MESA";
        case static_cast<uint64_t>(65542): return "VK_VENDOR_ID_POCL";
        case static_cast<uint64_t>(65543): return "VK_VENDOR_ID_MOBILEYE";
        case static_cast<uint64_t>(2147483647): return "VK_VENDOR_ID_MAX_ENUM";
        default: return "VkVendorId_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVertexInputRate>(VkVertexInputRate type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VERTEX_INPUT_RATE_VERTEX";
        case static_cast<uint64_t>(1): return "VK_VERTEX_INPUT_RATE_INSTANCE";
        case static_cast<uint64_t>(2147483647): return "VK_VERTEX_INPUT_RATE_MAX_ENUM";
        default: return "VkVertexInputRate_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoCapabilityFlagBitsKHR>(VkVideoCapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_CAPABILITY_PROTECTED_CONTENT_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_CAPABILITY_SEPARATE_REFERENCE_IMAGES_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoCapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoChromaSubsamplingFlagBitsKHR>(VkVideoChromaSubsamplingFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_CHROMA_SUBSAMPLING_INVALID_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_CHROMA_SUBSAMPLING_MONOCHROME_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_CHROMA_SUBSAMPLING_420_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_CHROMA_SUBSAMPLING_422_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_CHROMA_SUBSAMPLING_444_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_CHROMA_SUBSAMPLING_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoChromaSubsamplingFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoCodecOperationFlagBitsKHR>(VkVideoCodecOperationFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_CODEC_OPERATION_NONE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_CODEC_OPERATION_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(65536): return "VK_VIDEO_CODEC_OPERATION_ENCODE_H264_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_VIDEO_CODEC_OPERATION_ENCODE_H265_BIT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_CODEC_OPERATION_DECODE_H264_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_CODEC_OPERATION_DECODE_H265_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_CODEC_OPERATION_DECODE_AV1_BIT_KHR";
        case static_cast<uint64_t>(262144): return "VK_VIDEO_CODEC_OPERATION_ENCODE_AV1_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_CODEC_OPERATION_DECODE_VP9_BIT_KHR";
        default: return "VkVideoCodecOperationFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoCodingControlFlagBitsKHR>(VkVideoCodingControlFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_CODING_CONTROL_RESET_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_CODING_CONTROL_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_VIDEO_CODING_CONTROL_ENCODE_RATE_CONTROL_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_CODING_CONTROL_ENCODE_QUALITY_LEVEL_BIT_KHR";
        default: return "VkVideoCodingControlFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoComponentBitDepthFlagBitsKHR>(VkVideoComponentBitDepthFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_COMPONENT_BIT_DEPTH_INVALID_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_COMPONENT_BIT_DEPTH_8_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_COMPONENT_BIT_DEPTH_10_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_COMPONENT_BIT_DEPTH_12_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_COMPONENT_BIT_DEPTH_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoComponentBitDepthFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoDecodeCapabilityFlagBitsKHR>(VkVideoDecodeCapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_COINCIDE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_DECODE_CAPABILITY_DPB_AND_OUTPUT_DISTINCT_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_DECODE_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoDecodeCapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoDecodeH264PictureLayoutFlagBitsKHR>(VkVideoDecodeH264PictureLayoutFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_PROGRESSIVE_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_INTERLEAVED_LINES_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_DECODE_H264_PICTURE_LAYOUT_INTERLACED_SEPARATE_PLANES_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_DECODE_H2_64_PICTURE_LAYOUT_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoDecodeH264PictureLayoutFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoDecodeUsageFlagBitsKHR>(VkVideoDecodeUsageFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_DECODE_USAGE_DEFAULT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_DECODE_USAGE_TRANSCODING_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_DECODE_USAGE_OFFLINE_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_DECODE_USAGE_STREAMING_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_DECODE_USAGE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoDecodeUsageFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1CapabilityFlagBitsKHR>(VkVideoEncodeAV1CapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_PER_RATE_CONTROL_GROUP_MIN_MAX_Q_INDEX_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_GENERATE_OBU_EXTENSION_HEADER_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_PRIMARY_REFERENCE_CDF_ONLY_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_FRAME_SIZE_OVERRIDE_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_MOTION_VECTOR_SCALING_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(32): return "VK_VIDEO_ENCODE_AV1_CAPABILITY_COMPOUND_PREDICTION_INTRA_REFRESH_BIT_KHR";
        default: return "VkVideoEncodeAV1CapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1PredictionModeKHR>(VkVideoEncodeAV1PredictionModeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_INTRA_ONLY_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_SINGLE_REFERENCE_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_UNIDIRECTIONAL_COMPOUND_KHR";
        case static_cast<uint64_t>(3): return "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_BIDIRECTIONAL_COMPOUND_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_PREDICTION_MODE_KHR_MAX_ENUM";
        default: return "VkVideoEncodeAV1PredictionModeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1RateControlFlagBitsKHR>(VkVideoEncodeAV1RateControlFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REGULAR_GOP_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeAV1RateControlFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1RateControlGroupKHR>(VkVideoEncodeAV1RateControlGroupKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_INTRA_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_PREDICTIVE_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_BIPREDICTIVE_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_RATE_CONTROL_GROUP_KHR_MAX_ENUM";
        default: return "VkVideoEncodeAV1RateControlGroupKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1StdFlagBitsKHR>(VkVideoEncodeAV1StdFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_STD_UNIFORM_TILE_SPACING_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_STD_SKIP_MODE_PRESENT_UNSET_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_AV1_STD_PRIMARY_REF_FRAME_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_AV1_STD_DELTA_Q_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_STD_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeAV1StdFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeAV1SuperblockSizeFlagBitsKHR>(VkVideoEncodeAV1SuperblockSizeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_64_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_128_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_AV1_SUPERBLOCK_SIZE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeAV1SuperblockSizeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeCapabilityFlagBitsKHR>(VkVideoEncodeCapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_CAPABILITY_PRECEDING_EXTERNALLY_ENCODED_BYTES_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_CAPABILITY_INSUFFICIENT_BITSTREAM_BUFFER_RANGE_DETECTION_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_CAPABILITY_QUANTIZATION_DELTA_MAP_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_CAPABILITY_EMPHASIS_MAP_BIT_KHR";
        default: return "VkVideoEncodeCapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeContentFlagBitsKHR>(VkVideoEncodeContentFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_CONTENT_DEFAULT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_CONTENT_CAMERA_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_CONTENT_DESKTOP_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_CONTENT_RENDERED_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_CONTENT_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeContentFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeFeedbackFlagBitsKHR>(VkVideoEncodeFeedbackFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BUFFER_OFFSET_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_BYTES_WRITTEN_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_FEEDBACK_BITSTREAM_HAS_OVERRIDES_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_FEEDBACK_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeFeedbackFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeFlagBitsKHR>(VkVideoEncodeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_INTRA_REFRESH_BIT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_WITH_QUANTIZATION_DELTA_MAP_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_WITH_EMPHASIS_MAP_BIT_KHR";
        default: return "VkVideoEncodeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH264CapabilityFlagBitsKHR>(VkVideoEncodeH264CapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H264_CAPABILITY_HRD_COMPLIANCE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H264_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H264_CAPABILITY_ROW_UNALIGNED_SLICE_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H264_CAPABILITY_DIFFERENT_SLICE_TYPE_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_VIDEO_ENCODE_H264_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_VIDEO_ENCODE_H264_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_VIDEO_ENCODE_H264_CAPABILITY_PER_SLICE_CONSTANT_QP_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_VIDEO_ENCODE_H264_CAPABILITY_GENERATE_PREFIX_NALU_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_64_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1024): return "VK_VIDEO_ENCODE_H264_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_VIDEO_ENCODE_H264_CAPABILITY_MB_QP_DIFF_WRAPAROUND_BIT_KHR";
        default: return "VkVideoEncodeH264CapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH264RateControlFlagBitsKHR>(VkVideoEncodeH264RateControlFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H264_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REGULAR_GOP_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H264_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H264_RATE_CONTROL_TEMPORAL_LAYER_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_64_RATE_CONTROL_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH264RateControlFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH264StdFlagBitsKHR>(VkVideoEncodeH264StdFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H264_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H264_STD_QPPRIME_Y_ZERO_TRANSFORM_BYPASS_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H264_STD_SCALING_MATRIX_PRESENT_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H264_STD_CHROMA_QP_INDEX_OFFSET_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H264_STD_SECOND_CHROMA_QP_INDEX_OFFSET_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_VIDEO_ENCODE_H264_STD_PIC_INIT_QP_MINUS26_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_EXPLICIT_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_VIDEO_ENCODE_H264_STD_WEIGHTED_BIPRED_IDC_IMPLICIT_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_VIDEO_ENCODE_H264_STD_TRANSFORM_8X8_MODE_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(1024): return "VK_VIDEO_ENCODE_H264_STD_DIRECT_SPATIAL_MV_PRED_FLAG_UNSET_BIT_KHR";
        case static_cast<uint64_t>(2048): return "VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_UNSET_BIT_KHR";
        case static_cast<uint64_t>(4096): return "VK_VIDEO_ENCODE_H264_STD_ENTROPY_CODING_MODE_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_VIDEO_ENCODE_H264_STD_DIRECT_8X8_INFERENCE_FLAG_UNSET_BIT_KHR";
        case static_cast<uint64_t>(16384): return "VK_VIDEO_ENCODE_H264_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(32768): return "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_DISABLED_BIT_KHR";
        case static_cast<uint64_t>(65536): return "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_ENABLED_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_VIDEO_ENCODE_H264_STD_DEBLOCKING_FILTER_PARTIAL_BIT_KHR";
        case static_cast<uint64_t>(524288): return "VK_VIDEO_ENCODE_H264_STD_SLICE_QP_DELTA_BIT_KHR";
        case static_cast<uint64_t>(1048576): return "VK_VIDEO_ENCODE_H264_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_64_STD_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH264StdFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH265CapabilityFlagBitsKHR>(VkVideoEncodeH265CapabilityFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H265_CAPABILITY_HRD_COMPLIANCE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H265_CAPABILITY_PREDICTION_WEIGHT_TABLE_GENERATED_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H265_CAPABILITY_ROW_UNALIGNED_SLICE_SEGMENT_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H265_CAPABILITY_DIFFERENT_SLICE_SEGMENT_TYPE_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L0_LIST_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_VIDEO_ENCODE_H265_CAPABILITY_B_FRAME_IN_L1_LIST_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_VIDEO_ENCODE_H265_CAPABILITY_PER_PICTURE_TYPE_MIN_MAX_QP_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_VIDEO_ENCODE_H265_CAPABILITY_PER_SLICE_SEGMENT_CONSTANT_QP_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_TILES_PER_SLICE_SEGMENT_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_VIDEO_ENCODE_H265_CAPABILITY_MULTIPLE_SLICE_SEGMENTS_PER_TILE_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_65_CAPABILITY_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(2048): return "VK_VIDEO_ENCODE_H265_CAPABILITY_B_PICTURE_INTRA_REFRESH_BIT_KHR";
        case static_cast<uint64_t>(1024): return "VK_VIDEO_ENCODE_H265_CAPABILITY_CU_QP_DIFF_WRAPAROUND_BIT_KHR";
        default: return "VkVideoEncodeH265CapabilityFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH265CtbSizeFlagBitsKHR>(VkVideoEncodeH265CtbSizeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H265_CTB_SIZE_16_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H265_CTB_SIZE_32_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H265_CTB_SIZE_64_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_65_CTB_SIZE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH265CtbSizeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH265RateControlFlagBitsKHR>(VkVideoEncodeH265RateControlFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H265_RATE_CONTROL_ATTEMPT_HRD_COMPLIANCE_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REGULAR_GOP_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_FLAT_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H265_RATE_CONTROL_REFERENCE_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H265_RATE_CONTROL_TEMPORAL_SUB_LAYER_PATTERN_DYADIC_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_65_RATE_CONTROL_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH265RateControlFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH265StdFlagBitsKHR>(VkVideoEncodeH265StdFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H265_STD_SEPARATE_COLOR_PLANE_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H265_STD_SAMPLE_ADAPTIVE_OFFSET_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H265_STD_SCALING_LIST_DATA_PRESENT_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H265_STD_PCM_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_ENCODE_H265_STD_SPS_TEMPORAL_MVP_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_VIDEO_ENCODE_H265_STD_INIT_QP_MINUS26_BIT_KHR";
        case static_cast<uint64_t>(64): return "VK_VIDEO_ENCODE_H265_STD_WEIGHTED_PRED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(128): return "VK_VIDEO_ENCODE_H265_STD_WEIGHTED_BIPRED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(256): return "VK_VIDEO_ENCODE_H265_STD_LOG2_PARALLEL_MERGE_LEVEL_MINUS2_BIT_KHR";
        case static_cast<uint64_t>(512): return "VK_VIDEO_ENCODE_H265_STD_SIGN_DATA_HIDING_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(1024): return "VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(2048): return "VK_VIDEO_ENCODE_H265_STD_TRANSFORM_SKIP_ENABLED_FLAG_UNSET_BIT_KHR";
        case static_cast<uint64_t>(4096): return "VK_VIDEO_ENCODE_H265_STD_PPS_SLICE_CHROMA_QP_OFFSETS_PRESENT_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(8192): return "VK_VIDEO_ENCODE_H265_STD_TRANSQUANT_BYPASS_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(16384): return "VK_VIDEO_ENCODE_H265_STD_CONSTRAINED_INTRA_PRED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(32768): return "VK_VIDEO_ENCODE_H265_STD_ENTROPY_CODING_SYNC_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(65536): return "VK_VIDEO_ENCODE_H265_STD_DEBLOCKING_FILTER_OVERRIDE_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(131072): return "VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENTS_ENABLED_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(262144): return "VK_VIDEO_ENCODE_H265_STD_DEPENDENT_SLICE_SEGMENT_FLAG_SET_BIT_KHR";
        case static_cast<uint64_t>(524288): return "VK_VIDEO_ENCODE_H265_STD_SLICE_QP_DELTA_BIT_KHR";
        case static_cast<uint64_t>(1048576): return "VK_VIDEO_ENCODE_H265_STD_DIFFERENT_SLICE_QP_DELTA_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_65_STD_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH265StdFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeH265TransformBlockSizeFlagBitsKHR>(VkVideoEncodeH265TransformBlockSizeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_4_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_8_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_16_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_H265_TRANSFORM_BLOCK_SIZE_32_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_H2_65_TRANSFORM_BLOCK_SIZE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeH265TransformBlockSizeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeIntraRefreshModeFlagBitsKHR>(VkVideoEncodeIntraRefreshModeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_NONE_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_PER_PICTURE_PARTITION_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_BASED_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_ROW_BASED_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_BLOCK_COLUMN_BASED_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_INTRA_REFRESH_MODE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeIntraRefreshModeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeRateControlModeFlagBitsKHR>(VkVideoEncodeRateControlModeFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DEFAULT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_DISABLED_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_CBR_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_VBR_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_RATE_CONTROL_MODE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeRateControlModeFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeTuningModeKHR>(VkVideoEncodeTuningModeKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_TUNING_MODE_DEFAULT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_TUNING_MODE_HIGH_QUALITY_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_TUNING_MODE_LOW_LATENCY_KHR";
        case static_cast<uint64_t>(3): return "VK_VIDEO_ENCODE_TUNING_MODE_ULTRA_LOW_LATENCY_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_TUNING_MODE_LOSSLESS_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_TUNING_MODE_KHR_MAX_ENUM";
        default: return "VkVideoEncodeTuningModeKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoEncodeUsageFlagBitsKHR>(VkVideoEncodeUsageFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIDEO_ENCODE_USAGE_DEFAULT_KHR";
        case static_cast<uint64_t>(1): return "VK_VIDEO_ENCODE_USAGE_TRANSCODING_BIT_KHR";
        case static_cast<uint64_t>(2): return "VK_VIDEO_ENCODE_USAGE_STREAMING_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_ENCODE_USAGE_RECORDING_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_ENCODE_USAGE_CONFERENCING_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_ENCODE_USAGE_FLAG_BITS_KHR_MAX_ENUM";
        default: return "VkVideoEncodeUsageFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoSessionCreateFlagBitsKHR>(VkVideoSessionCreateFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(1): return "VK_VIDEO_SESSION_CREATE_PROTECTED_CONTENT_BIT_KHR";
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_SESSION_CREATE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(2): return "VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_PARAMETER_OPTIMIZATIONS_BIT_KHR";
        case static_cast<uint64_t>(4): return "VK_VIDEO_SESSION_CREATE_INLINE_QUERIES_BIT_KHR";
        case static_cast<uint64_t>(8): return "VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_QUANTIZATION_DELTA_MAP_BIT_KHR";
        case static_cast<uint64_t>(16): return "VK_VIDEO_SESSION_CREATE_ALLOW_ENCODE_EMPHASIS_MAP_BIT_KHR";
        case static_cast<uint64_t>(32): return "VK_VIDEO_SESSION_CREATE_INLINE_SESSION_PARAMETERS_BIT_KHR";
        default: return "VkVideoSessionCreateFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkVideoSessionParametersCreateFlagBitsKHR>(VkVideoSessionParametersCreateFlagBitsKHR type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(2147483647): return "VK_VIDEO_SESSION_PARAMETERS_CREATE_FLAG_BITS_KHR_MAX_ENUM";
        case static_cast<uint64_t>(1): return "VK_VIDEO_SESSION_PARAMETERS_CREATE_QUANTIZATION_MAP_COMPATIBLE_BIT_KHR";
        default: return "VkVideoSessionParametersCreateFlagBitsKHR_UNKNOWN";
      }
    }

    template <> constexpr const char* enumString<VkViewportCoordinateSwizzleNV>(VkViewportCoordinateSwizzleNV type) {
      switch(static_cast<uint64_t>(type)) {
        case static_cast<uint64_t>(0): return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV";
        case static_cast<uint64_t>(1): return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV";
        case static_cast<uint64_t>(2): return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV";
        case static_cast<uint64_t>(3): return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV";
        case static_cast<uint64_t>(4): return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV";
        case static_cast<uint64_t>(5): return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV";
        case static_cast<uint64_t>(6): return "VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV";
        case static_cast<uint64_t>(7): return "VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV";
        case static_cast<uint64_t>(2147483647): return "VK_VIEWPORT_COORDINATE_SWIZZLE_NV_MAX_ENUM";
        default: return "VkViewportCoordinateSwizzleNV_UNKNOWN";
      }
    }
  }
  template <typename Type>
  constexpr VkStructureType ResolveSType();

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureBuildGeometryInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureBuildGeometryInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureBuildSizesInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureBuildSizesInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureCreateInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureCreateInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureCreateInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureCreateInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureDeviceAddressInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureDeviceAddressInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryAabbsDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryAabbsDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryInstancesDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryInstancesDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryLinearSweptSpheresDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryLinearSweptSpheresDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_LINEAR_SWEPT_SPHERES_DATA_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryMotionTrianglesDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryMotionTrianglesDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometrySpheresDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometrySpheresDataNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_SPHERES_DATA_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureGeometryTrianglesDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureGeometryTrianglesDataKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureMemoryRequirementsInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureMemoryRequirementsInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureMotionInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureMotionInfoNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureTrianglesDisplacementMicromapNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureTrianglesDisplacementMicromapNV>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureTrianglesOpacityMicromapEXT>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureTrianglesOpacityMicromapEXT>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkAccelerationStructureVersionInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAccelerationStructureVersionInfoKHR>() { return VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAcquireNextImageInfoKHR>() { return VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAcquireNextImageInfoKHR>() { return VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAcquireProfilingLockInfoKHR>() { return VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAcquireProfilingLockInfoKHR>() { return VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkAmigoProfilingSubmitInfoSEC>() { return VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC; }
  template <> constexpr VkStructureType ResolveSType<const VkAmigoProfilingSubmitInfoSEC>() { return VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC; }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidHardwareBufferFormatProperties2ANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidHardwareBufferFormatProperties2ANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidHardwareBufferFormatPropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidHardwareBufferFormatPropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidHardwareBufferFormatResolvePropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidHardwareBufferFormatResolvePropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidHardwareBufferPropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidHardwareBufferPropertiesANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidHardwareBufferUsageANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidHardwareBufferUsageANDROID>() { return VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkAndroidSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkAndroidSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkAntiLagDataAMD>() { return VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkAntiLagDataAMD>() { return VK_STRUCTURE_TYPE_ANTI_LAG_DATA_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkAntiLagPresentationInfoAMD>() { return VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkAntiLagPresentationInfoAMD>() { return VK_STRUCTURE_TYPE_ANTI_LAG_PRESENTATION_INFO_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkApplicationInfo>() { return VK_STRUCTURE_TYPE_APPLICATION_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkApplicationInfo>() { return VK_STRUCTURE_TYPE_APPLICATION_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentDescription2>() { return VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentDescription2>() { return VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentDescriptionStencilLayout>() { return VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentDescriptionStencilLayout>() { return VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentFeedbackLoopInfoEXT>() { return VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentFeedbackLoopInfoEXT>() { return VK_STRUCTURE_TYPE_ATTACHMENT_FEEDBACK_LOOP_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentReference2>() { return VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentReference2>() { return VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentReferenceStencilLayout>() { return VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentReferenceStencilLayout>() { return VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT; }

  template <> constexpr VkStructureType ResolveSType<VkAttachmentSampleCountInfoAMD>() { return VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkAttachmentSampleCountInfoAMD>() { return VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkBindAccelerationStructureMemoryInfoNV>() { return VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkBindAccelerationStructureMemoryInfoNV>() { return VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkBindBufferMemoryDeviceGroupInfo>() { return VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindBufferMemoryDeviceGroupInfo>() { return VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindBufferMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindBufferMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindDataGraphPipelineSessionMemoryInfoARM>() { return VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkBindDataGraphPipelineSessionMemoryInfoARM>() { return VK_STRUCTURE_TYPE_BIND_DATA_GRAPH_PIPELINE_SESSION_MEMORY_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkBindDescriptorBufferEmbeddedSamplersInfoEXT>() { return VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkBindDescriptorBufferEmbeddedSamplersInfoEXT>() { return VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkBindDescriptorSetsInfo>() { return VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindDescriptorSetsInfo>() { return VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindImageMemoryDeviceGroupInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindImageMemoryDeviceGroupInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindImageMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindImageMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindImageMemorySwapchainInfoKHR>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkBindImageMemorySwapchainInfoKHR>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkBindImagePlaneMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindImagePlaneMemoryInfo>() { return VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindMemoryStatus>() { return VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS; }
  template <> constexpr VkStructureType ResolveSType<const VkBindMemoryStatus>() { return VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS; }

  template <> constexpr VkStructureType ResolveSType<VkBindSparseInfo>() { return VK_STRUCTURE_TYPE_BIND_SPARSE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBindSparseInfo>() { return VK_STRUCTURE_TYPE_BIND_SPARSE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBindTensorMemoryInfoARM>() { return VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkBindTensorMemoryInfoARM>() { return VK_STRUCTURE_TYPE_BIND_TENSOR_MEMORY_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkBindVideoSessionMemoryInfoKHR>() { return VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkBindVideoSessionMemoryInfoKHR>() { return VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkBlitImageCubicWeightsInfoQCOM>() { return VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkBlitImageCubicWeightsInfoQCOM>() { return VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkBlitImageInfo2>() { return VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkBlitImageInfo2>() { return VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkBufferCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_BUFFER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferCollectionBufferCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCollectionBufferCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_BUFFER_CREATE_INFO_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferCollectionConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCollectionConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CONSTRAINTS_INFO_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferCollectionCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCollectionCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_CREATE_INFO_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferCollectionImageCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCollectionImageCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_IMAGE_CREATE_INFO_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferCollectionPropertiesFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCollectionPropertiesFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_COLLECTION_PROPERTIES_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkBufferConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_BUFFER_CONSTRAINTS_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkBufferCopy2>() { return VK_STRUCTURE_TYPE_BUFFER_COPY_2; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCopy2>() { return VK_STRUCTURE_TYPE_BUFFER_COPY_2; }

  template <> constexpr VkStructureType ResolveSType<VkBufferCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBufferDeviceAddressCreateInfoEXT>() { return VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferDeviceAddressCreateInfoEXT>() { return VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkBufferDeviceAddressInfo>() { return VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferDeviceAddressInfo>() { return VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBufferImageCopy2>() { return VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferImageCopy2>() { return VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2; }

  template <> constexpr VkStructureType ResolveSType<VkBufferMemoryBarrier>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferMemoryBarrier>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER; }

  template <> constexpr VkStructureType ResolveSType<VkBufferMemoryBarrier2>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferMemoryBarrier2>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2; }

  template <> constexpr VkStructureType ResolveSType<VkBufferMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkBufferOpaqueCaptureAddressCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferOpaqueCaptureAddressCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBufferUsageFlags2CreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferUsageFlags2CreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBufferViewCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkBufferViewCreateInfo>() { return VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkBuildPartitionedAccelerationStructureInfoNV>() { return VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkBuildPartitionedAccelerationStructureInfoNV>() { return VK_STRUCTURE_TYPE_BUILD_PARTITIONED_ACCELERATION_STRUCTURE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCalibratedTimestampInfoKHR>() { return VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkCalibratedTimestampInfoKHR>() { return VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkCheckpointData2NV>() { return VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCheckpointData2NV>() { return VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCheckpointDataNV>() { return VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCheckpointDataNV>() { return VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV; }

  template <> constexpr VkStructureType ResolveSType<VkClusterAccelerationStructureClustersBottomLevelInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkClusterAccelerationStructureClustersBottomLevelInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_CLUSTERS_BOTTOM_LEVEL_INPUT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkClusterAccelerationStructureCommandsInfoNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkClusterAccelerationStructureCommandsInfoNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_COMMANDS_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkClusterAccelerationStructureInputInfoNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkClusterAccelerationStructureInputInfoNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_INPUT_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkClusterAccelerationStructureMoveObjectsInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkClusterAccelerationStructureMoveObjectsInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_MOVE_OBJECTS_INPUT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkClusterAccelerationStructureTriangleClusterInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkClusterAccelerationStructureTriangleClusterInputNV>() { return VK_STRUCTURE_TYPE_CLUSTER_ACCELERATION_STRUCTURE_TRIANGLE_CLUSTER_INPUT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferAllocateInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferAllocateInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferBeginInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferBeginInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferInheritanceConditionalRenderingInfoEXT>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferInheritanceConditionalRenderingInfoEXT>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferInheritanceInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferInheritanceInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferInheritanceRenderPassTransformInfoQCOM>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferInheritanceRenderPassTransformInfoQCOM>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferInheritanceRenderingInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferInheritanceRenderingInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferInheritanceViewportScissorInfoNV>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferInheritanceViewportScissorInfoNV>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCommandBufferSubmitInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandBufferSubmitInfo>() { return VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCommandPoolCreateInfo>() { return VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCommandPoolCreateInfo>() { return VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkComputePipelineCreateInfo>() { return VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkComputePipelineCreateInfo>() { return VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkComputePipelineIndirectBufferInfoNV>() { return VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkComputePipelineIndirectBufferInfoNV>() { return VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkConditionalRenderingBeginInfoEXT>() { return VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkConditionalRenderingBeginInfoEXT>() { return VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkConvertCooperativeVectorMatrixInfoNV>() { return VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkConvertCooperativeVectorMatrixInfoNV>() { return VK_STRUCTURE_TYPE_CONVERT_COOPERATIVE_VECTOR_MATRIX_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCooperativeMatrixFlexibleDimensionsPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCooperativeMatrixFlexibleDimensionsPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_FLEXIBLE_DIMENSIONS_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCooperativeMatrixPropertiesKHR>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkCooperativeMatrixPropertiesKHR>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkCooperativeMatrixPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCooperativeMatrixPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCooperativeVectorPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCooperativeVectorPropertiesNV>() { return VK_STRUCTURE_TYPE_COOPERATIVE_VECTOR_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkCopyAccelerationStructureInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyAccelerationStructureInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkCopyAccelerationStructureToMemoryInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyAccelerationStructureToMemoryInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkCopyBufferInfo2>() { return VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyBufferInfo2>() { return VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkCopyBufferToImageInfo2>() { return VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyBufferToImageInfo2>() { return VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkCopyCommandTransformInfoQCOM>() { return VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyCommandTransformInfoQCOM>() { return VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkCopyDescriptorSet>() { return VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyDescriptorSet>() { return VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET; }

  template <> constexpr VkStructureType ResolveSType<VkCopyImageInfo2>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyImageInfo2>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkCopyImageToBufferInfo2>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyImageToBufferInfo2>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkCopyImageToImageInfo>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyImageToImageInfo>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCopyImageToMemoryInfo>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyImageToMemoryInfo>() { return VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCopyMemoryToAccelerationStructureInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyMemoryToAccelerationStructureInfoKHR>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkCopyMemoryToImageInfo>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyMemoryToImageInfo>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkCopyMemoryToMicromapInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyMemoryToMicromapInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkCopyMicromapInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyMicromapInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkCopyMicromapToMemoryInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyMicromapToMemoryInfoEXT>() { return VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkCopyTensorInfoARM>() { return VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkCopyTensorInfoARM>() { return VK_STRUCTURE_TYPE_COPY_TENSOR_INFO_ARM; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkCudaFunctionCreateInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCudaFunctionCreateInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_FUNCTION_CREATE_INFO_NV; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkCudaLaunchInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCudaLaunchInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_LAUNCH_INFO_NV; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkCudaModuleCreateInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkCudaModuleCreateInfoNV>() { return VK_STRUCTURE_TYPE_CUDA_MODULE_CREATE_INFO_NV; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkD3D12FenceSubmitInfoKHR>() { return VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkD3D12FenceSubmitInfoKHR>() { return VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineCompilerControlCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineCompilerControlCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_COMPILER_CONTROL_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineConstantARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineConstantARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CONSTANT_TENSOR_SEMI_STRUCTURED_SPARSITY_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineDispatchInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineDispatchInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_DISPATCH_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineIdentifierCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineIdentifierCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_IDENTIFIER_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelinePropertyQueryResultARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelinePropertyQueryResultARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_PROPERTY_QUERY_RESULT_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineResourceInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineResourceInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_RESOURCE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineSessionBindPointRequirementARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineSessionBindPointRequirementARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENT_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineSessionBindPointRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineSessionBindPointRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_BIND_POINT_REQUIREMENTS_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineSessionCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineSessionCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineSessionMemoryRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineSessionMemoryRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SESSION_MEMORY_REQUIREMENTS_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphPipelineShaderModuleCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphPipelineShaderModuleCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PIPELINE_SHADER_MODULE_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDataGraphProcessingEngineCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDataGraphProcessingEngineCreateInfoARM>() { return VK_STRUCTURE_TYPE_DATA_GRAPH_PROCESSING_ENGINE_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDebugMarkerMarkerInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugMarkerMarkerInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugMarkerObjectNameInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugMarkerObjectNameInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugMarkerObjectTagInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugMarkerObjectTagInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugReportCallbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugReportCallbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugUtilsLabelEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugUtilsLabelEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugUtilsMessengerCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugUtilsMessengerCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugUtilsMessengerCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugUtilsMessengerCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugUtilsObjectNameInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugUtilsObjectNameInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDebugUtilsObjectTagInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDebugUtilsObjectTagInfoEXT>() { return VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDedicatedAllocationBufferCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDedicatedAllocationBufferCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDedicatedAllocationImageCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDedicatedAllocationImageCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDedicatedAllocationMemoryAllocateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDedicatedAllocationMemoryAllocateInfoNV>() { return VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDependencyInfo>() { return VK_STRUCTURE_TYPE_DEPENDENCY_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDependencyInfo>() { return VK_STRUCTURE_TYPE_DEPENDENCY_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDepthBiasInfoEXT>() { return VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDepthBiasInfoEXT>() { return VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDepthBiasRepresentationInfoEXT>() { return VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDepthBiasRepresentationInfoEXT>() { return VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorAddressInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorAddressInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_ADDRESS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorBufferBindingInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorBufferBindingInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorBufferBindingPushDescriptorBufferHandleEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorBufferBindingPushDescriptorBufferHandleEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_BUFFER_BINDING_PUSH_DESCRIPTOR_BUFFER_HANDLE_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorGetInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorGetInfoEXT>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_GET_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorGetTensorInfoARM>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorGetTensorInfoARM>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_GET_TENSOR_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorPoolCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorPoolCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorPoolInlineUniformBlockCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorPoolInlineUniformBlockCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetAllocateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetAllocateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetBindingReferenceVALVE>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetBindingReferenceVALVE>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetLayoutBindingFlagsCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetLayoutBindingFlagsCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetLayoutCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetLayoutCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetLayoutHostMappingInfoVALVE>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetLayoutHostMappingInfoVALVE>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetLayoutSupport>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetLayoutSupport>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetVariableDescriptorCountAllocateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetVariableDescriptorCountAllocateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorSetVariableDescriptorCountLayoutSupport>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorSetVariableDescriptorCountLayoutSupport>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT; }

  template <> constexpr VkStructureType ResolveSType<VkDescriptorUpdateTemplateCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDescriptorUpdateTemplateCreateInfo>() { return VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceAddressBindingCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceAddressBindingCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceBufferMemoryRequirements>() { return VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceBufferMemoryRequirements>() { return VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceDeviceMemoryReportCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceDeviceMemoryReportCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceDiagnosticsConfigCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceDiagnosticsConfigCreateInfoNV>() { return VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceEventInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceEventInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceFaultCountsEXT>() { return VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceFaultCountsEXT>() { return VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceFaultInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceFaultInfoEXT>() { return VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupBindSparseInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupBindSparseInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupCommandBufferBeginInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupCommandBufferBeginInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupDeviceCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupPresentCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupPresentCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupPresentInfoKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupPresentInfoKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupRenderPassBeginInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupRenderPassBeginInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupSubmitInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupSubmitInfo>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceGroupSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceGroupSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceImageMemoryRequirements>() { return VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceImageMemoryRequirements>() { return VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceImageSubresourceInfo>() { return VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceImageSubresourceInfo>() { return VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceMemoryOpaqueCaptureAddressInfo>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceMemoryOpaqueCaptureAddressInfo>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceMemoryOverallocationCreateInfoAMD>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceMemoryOverallocationCreateInfoAMD>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceMemoryReportCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceMemoryReportCallbackDataEXT>() { return VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDevicePipelineBinaryInternalCacheControlKHR>() { return VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDevicePipelineBinaryInternalCacheControlKHR>() { return VK_STRUCTURE_TYPE_DEVICE_PIPELINE_BINARY_INTERNAL_CACHE_CONTROL_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDevicePrivateDataCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDevicePrivateDataCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceQueueCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceQueueCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceQueueGlobalPriorityCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceQueueGlobalPriorityCreateInfo>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceQueueInfo2>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceQueueInfo2>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceQueueShaderCoreControlCreateInfoARM>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceQueueShaderCoreControlCreateInfoARM>() { return VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDeviceTensorMemoryRequirementsARM>() { return VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkDeviceTensorMemoryRequirementsARM>() { return VK_STRUCTURE_TYPE_DEVICE_TENSOR_MEMORY_REQUIREMENTS_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkDirectDriverLoadingInfoLUNARG>() { return VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG; }
  template <> constexpr VkStructureType ResolveSType<const VkDirectDriverLoadingInfoLUNARG>() { return VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG; }

  template <> constexpr VkStructureType ResolveSType<VkDirectDriverLoadingListLUNARG>() { return VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG; }
  template <> constexpr VkStructureType ResolveSType<const VkDirectDriverLoadingListLUNARG>() { return VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG; }

#ifdef VK_USE_PLATFORM_DIRECTFB_EXT
  template <> constexpr VkStructureType ResolveSType<VkDirectFBSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDirectFBSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkDispatchTileInfoQCOM>() { return VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkDispatchTileInfoQCOM>() { return VK_STRUCTURE_TYPE_DISPATCH_TILE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayEventInfoEXT>() { return VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayEventInfoEXT>() { return VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayModeCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayModeCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayModeProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayModeProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayModeStereoPropertiesNV>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayModeStereoPropertiesNV>() { return VK_STRUCTURE_TYPE_DISPLAY_MODE_STEREO_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayNativeHdrSurfaceCapabilitiesAMD>() { return VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayNativeHdrSurfaceCapabilitiesAMD>() { return VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayPlaneCapabilities2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayPlaneCapabilities2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayPlaneInfo2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayPlaneInfo2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayPlaneProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayPlaneProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayPowerInfoEXT>() { return VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayPowerInfoEXT>() { return VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayPresentInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayPresentInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplayProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplayProperties2KHR>() { return VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplaySurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplaySurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkDisplaySurfaceStereoCreateInfoNV>() { return VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkDisplaySurfaceStereoCreateInfoNV>() { return VK_STRUCTURE_TYPE_DISPLAY_SURFACE_STEREO_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkDrmFormatModifierPropertiesList2EXT>() { return VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDrmFormatModifierPropertiesList2EXT>() { return VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkDrmFormatModifierPropertiesListEXT>() { return VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkDrmFormatModifierPropertiesListEXT>() { return VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkEventCreateInfo>() { return VK_STRUCTURE_TYPE_EVENT_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkEventCreateInfo>() { return VK_STRUCTURE_TYPE_EVENT_CREATE_INFO; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkExecutionGraphPipelineCreateInfoAMDX>() { return VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX; }
  template <> constexpr VkStructureType ResolveSType<const VkExecutionGraphPipelineCreateInfoAMDX>() { return VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_CREATE_INFO_AMDX; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkExecutionGraphPipelineScratchSizeAMDX>() { return VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX; }
  template <> constexpr VkStructureType ResolveSType<const VkExecutionGraphPipelineScratchSizeAMDX>() { return VK_STRUCTURE_TYPE_EXECUTION_GRAPH_PIPELINE_SCRATCH_SIZE_AMDX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkExportFenceCreateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkExportFenceCreateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkExportFenceWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkExportFenceWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkExportMemoryAllocateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMemoryAllocateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkExportMemoryAllocateInfoNV>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMemoryAllocateInfoNV>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkExportMemoryWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMemoryWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkExportMemoryWin32HandleInfoNV>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMemoryWin32HandleInfoNV>() { return VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalBufferInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalBufferInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_BUFFER_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalCommandQueueInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalCommandQueueInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_COMMAND_QUEUE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalDeviceInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalDeviceInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_DEVICE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalIOSurfaceInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalIOSurfaceInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_IO_SURFACE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalObjectCreateInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalObjectCreateInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECT_CREATE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalObjectsInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalObjectsInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_OBJECTS_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalSharedEventInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalSharedEventInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_SHARED_EVENT_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkExportMetalTextureInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExportMetalTextureInfoEXT>() { return VK_STRUCTURE_TYPE_EXPORT_METAL_TEXTURE_INFO_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkExportSemaphoreCreateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkExportSemaphoreCreateInfo>() { return VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkExportSemaphoreWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkExportSemaphoreWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkExternalBufferProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalBufferProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkExternalComputeQueueCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalComputeQueueCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkExternalComputeQueueDataParamsNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalComputeQueueDataParamsNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DATA_PARAMS_NV; }

  template <> constexpr VkStructureType ResolveSType<VkExternalComputeQueueDeviceCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalComputeQueueDeviceCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_COMPUTE_QUEUE_DEVICE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkExternalFenceProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalFenceProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES; }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkExternalFormatANDROID>() { return VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalFormatANDROID>() { return VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkExternalFormatQNX>() { return VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalFormatQNX>() { return VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_QNX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkExternalImageFormatProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalImageFormatProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkExternalMemoryAcquireUnmodifiedEXT>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalMemoryAcquireUnmodifiedEXT>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkExternalMemoryBufferCreateInfo>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalMemoryBufferCreateInfo>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkExternalMemoryImageCreateInfo>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalMemoryImageCreateInfo>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkExternalMemoryImageCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalMemoryImageCreateInfoNV>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkExternalMemoryTensorCreateInfoARM>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalMemoryTensorCreateInfoARM>() { return VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_TENSOR_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkExternalSemaphoreProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalSemaphoreProperties>() { return VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkExternalTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkExternalTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_EXTERNAL_TENSOR_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkFenceCreateInfo>() { return VK_STRUCTURE_TYPE_FENCE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkFenceCreateInfo>() { return VK_STRUCTURE_TYPE_FENCE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkFenceGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkFenceGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkFenceGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkFenceGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkFilterCubicImageViewImageFormatPropertiesEXT>() { return VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkFilterCubicImageViewImageFormatPropertiesEXT>() { return VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkFormatProperties2>() { return VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkFormatProperties2>() { return VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkFormatProperties3>() { return VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3; }
  template <> constexpr VkStructureType ResolveSType<const VkFormatProperties3>() { return VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3; }

  template <> constexpr VkStructureType ResolveSType<VkFragmentShadingRateAttachmentInfoKHR>() { return VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkFragmentShadingRateAttachmentInfoKHR>() { return VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkFrameBoundaryEXT>() { return VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkFrameBoundaryEXT>() { return VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkFrameBoundaryTensorsARM>() { return VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkFrameBoundaryTensorsARM>() { return VK_STRUCTURE_TYPE_FRAME_BOUNDARY_TENSORS_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkFramebufferAttachmentImageInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkFramebufferAttachmentImageInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkFramebufferAttachmentsCreateInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkFramebufferAttachmentsCreateInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkFramebufferCreateInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkFramebufferCreateInfo>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkFramebufferMixedSamplesCombinationNV>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkFramebufferMixedSamplesCombinationNV>() { return VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsInfoNV>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsInfoNV>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsMemoryRequirementsInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsMemoryRequirementsInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsMemoryRequirementsInfoNV>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsMemoryRequirementsInfoNV>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsPipelineInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsPipelineInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_PIPELINE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkGeneratedCommandsShaderInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkGeneratedCommandsShaderInfoEXT>() { return VK_STRUCTURE_TYPE_GENERATED_COMMANDS_SHADER_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkGeometryAABBNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGeometryAABBNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGeometryNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGeometryNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGeometryTrianglesNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGeometryTrianglesNV>() { return VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGetLatencyMarkerInfoNV>() { return VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGetLatencyMarkerInfoNV>() { return VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGraphicsPipelineCreateInfo>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkGraphicsPipelineCreateInfo>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkGraphicsPipelineLibraryCreateInfoEXT>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkGraphicsPipelineLibraryCreateInfoEXT>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkGraphicsPipelineShaderGroupsCreateInfoNV>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGraphicsPipelineShaderGroupsCreateInfoNV>() { return VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkGraphicsShaderGroupCreateInfoNV>() { return VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkGraphicsShaderGroupCreateInfoNV>() { return VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkHdrMetadataEXT>() { return VK_STRUCTURE_TYPE_HDR_METADATA_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkHdrMetadataEXT>() { return VK_STRUCTURE_TYPE_HDR_METADATA_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkHdrVividDynamicMetadataHUAWEI>() { return VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkHdrVividDynamicMetadataHUAWEI>() { return VK_STRUCTURE_TYPE_HDR_VIVID_DYNAMIC_METADATA_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkHeadlessSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkHeadlessSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkHostImageCopyDevicePerformanceQuery>() { return VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY; }
  template <> constexpr VkStructureType ResolveSType<const VkHostImageCopyDevicePerformanceQuery>() { return VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY; }

  template <> constexpr VkStructureType ResolveSType<VkHostImageLayoutTransitionInfo>() { return VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkHostImageLayoutTransitionInfo>() { return VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO; }

#ifdef VK_USE_PLATFORM_IOS_MVK
  template <> constexpr VkStructureType ResolveSType<VkIOSSurfaceCreateInfoMVK>() { return VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK; }
  template <> constexpr VkStructureType ResolveSType<const VkIOSSurfaceCreateInfoMVK>() { return VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImageAlignmentControlCreateInfoMESA>() { return VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA; }
  template <> constexpr VkStructureType ResolveSType<const VkImageAlignmentControlCreateInfoMESA>() { return VK_STRUCTURE_TYPE_IMAGE_ALIGNMENT_CONTROL_CREATE_INFO_MESA; }

  template <> constexpr VkStructureType ResolveSType<VkImageBlit2>() { return VK_STRUCTURE_TYPE_IMAGE_BLIT_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageBlit2>() { return VK_STRUCTURE_TYPE_IMAGE_BLIT_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageCompressionControlEXT>() { return VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageCompressionControlEXT>() { return VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageCompressionPropertiesEXT>() { return VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageCompressionPropertiesEXT>() { return VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT; }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImageConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImageConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGE_CONSTRAINTS_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImageCopy2>() { return VK_STRUCTURE_TYPE_IMAGE_COPY_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageCopy2>() { return VK_STRUCTURE_TYPE_IMAGE_COPY_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkImageDrmFormatModifierExplicitCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageDrmFormatModifierExplicitCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageDrmFormatModifierListCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageDrmFormatModifierListCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageDrmFormatModifierPropertiesEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageDrmFormatModifierPropertiesEXT>() { return VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT; }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImageFormatConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImageFormatConstraintsInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_CONSTRAINTS_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImageFormatListCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImageFormatListCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkImageFormatProperties2>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageFormatProperties2>() { return VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageMemoryBarrier>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; }
  template <> constexpr VkStructureType ResolveSType<const VkImageMemoryBarrier>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER; }

  template <> constexpr VkStructureType ResolveSType<VkImageMemoryBarrier2>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageMemoryBarrier2>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2; }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImagePipeSurfaceCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImagePipeSurfaceCreateInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImagePlaneMemoryRequirementsInfo>() { return VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImagePlaneMemoryRequirementsInfo>() { return VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkImageResolve2>() { return VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageResolve2>() { return VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageSparseMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageSparseMemoryRequirementsInfo2>() { return VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageStencilUsageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImageStencilUsageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkImageSubresource2>() { return VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2; }
  template <> constexpr VkStructureType ResolveSType<const VkImageSubresource2>() { return VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2; }

  template <> constexpr VkStructureType ResolveSType<VkImageSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImageSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkImageToMemoryCopy>() { return VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY; }
  template <> constexpr VkStructureType ResolveSType<const VkImageToMemoryCopy>() { return VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewASTCDecodeModeEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewASTCDecodeModeEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewMinLodCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewMinLodCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewSampleWeightCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewSampleWeightCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewSlicedCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewSlicedCreateInfoEXT>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkImageViewUsageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkImageViewUsageCreateInfo>() { return VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO; }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkImportAndroidHardwareBufferInfoANDROID>() { return VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkImportAndroidHardwareBufferInfoANDROID>() { return VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImportFenceFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportFenceFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkImportFenceWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportFenceWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImportMemoryBufferCollectionFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryBufferCollectionFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_BUFFER_COLLECTION_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImportMemoryFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkImportMemoryHostPointerInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryHostPointerInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT; }

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkImportMemoryMetalHandleInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryMetalHandleInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_METAL_HANDLE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkImportMemoryWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkImportMemoryWin32HandleInfoNV>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryWin32HandleInfoNV>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImportMemoryZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMemoryZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkImportMetalBufferInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMetalBufferInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_BUFFER_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkImportMetalIOSurfaceInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMetalIOSurfaceInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_IO_SURFACE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkImportMetalSharedEventInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMetalSharedEventInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_SHARED_EVENT_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkImportMetalTextureInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkImportMetalTextureInfoEXT>() { return VK_STRUCTURE_TYPE_IMPORT_METAL_TEXTURE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkImportScreenBufferInfoQNX>() { return VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkImportScreenBufferInfoQNX>() { return VK_STRUCTURE_TYPE_IMPORT_SCREEN_BUFFER_INFO_QNX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkImportSemaphoreFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportSemaphoreFdInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkImportSemaphoreWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkImportSemaphoreWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkImportSemaphoreZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkImportSemaphoreZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkIndirectCommandsLayoutCreateInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectCommandsLayoutCreateInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectCommandsLayoutCreateInfoNV>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectCommandsLayoutCreateInfoNV>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectCommandsLayoutTokenEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectCommandsLayoutTokenEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectCommandsLayoutTokenNV>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectCommandsLayoutTokenNV>() { return VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectExecutionSetCreateInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectExecutionSetCreateInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectExecutionSetPipelineInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectExecutionSetPipelineInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_PIPELINE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectExecutionSetShaderInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectExecutionSetShaderInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkIndirectExecutionSetShaderLayoutInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkIndirectExecutionSetShaderLayoutInfoEXT>() { return VK_STRUCTURE_TYPE_INDIRECT_EXECUTION_SET_SHADER_LAYOUT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkInitializePerformanceApiInfoINTEL>() { return VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkInitializePerformanceApiInfoINTEL>() { return VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkInstanceCreateInfo>() { return VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkInstanceCreateInfo>() { return VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkLatencySleepInfoNV>() { return VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkLatencySleepInfoNV>() { return VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkLatencySleepModeInfoNV>() { return VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkLatencySleepModeInfoNV>() { return VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkLatencySubmissionPresentIdNV>() { return VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkLatencySubmissionPresentIdNV>() { return VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV; }

  template <> constexpr VkStructureType ResolveSType<VkLatencySurfaceCapabilitiesNV>() { return VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkLatencySurfaceCapabilitiesNV>() { return VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkLatencyTimingsFrameReportNV>() { return VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkLatencyTimingsFrameReportNV>() { return VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkLayerSettingsCreateInfoEXT>() { return VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkLayerSettingsCreateInfoEXT>() { return VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT; }

#ifdef VK_USE_PLATFORM_MACOS_MVK
  template <> constexpr VkStructureType ResolveSType<VkMacOSSurfaceCreateInfoMVK>() { return VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK; }
  template <> constexpr VkStructureType ResolveSType<const VkMacOSSurfaceCreateInfoMVK>() { return VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMappedMemoryRange>() { return VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE; }
  template <> constexpr VkStructureType ResolveSType<const VkMappedMemoryRange>() { return VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryAllocateFlagsInfo>() { return VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryAllocateFlagsInfo>() { return VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryBarrier>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryBarrier>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryBarrier2>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER_2; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryBarrier2>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER_2; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryBarrierAccessFlags3KHR>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryBarrierAccessFlags3KHR>() { return VK_STRUCTURE_TYPE_MEMORY_BARRIER_ACCESS_FLAGS_3_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryDedicatedAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryDedicatedAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryDedicatedAllocateInfoTensorARM>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryDedicatedAllocateInfoTensorARM>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_TENSOR_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryDedicatedRequirements>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryDedicatedRequirements>() { return VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryFdPropertiesKHR>() { return VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryFdPropertiesKHR>() { return VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR; }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkMemoryGetAndroidHardwareBufferInfoANDROID>() { return VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetAndroidHardwareBufferInfoANDROID>() { return VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMemoryGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR; }

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkMemoryGetMetalHandleInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetMetalHandleInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_GET_METAL_HANDLE_INFO_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMemoryGetRemoteAddressInfoNV>() { return VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetRemoteAddressInfoNV>() { return VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkMemoryGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkMemoryGetZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryGetZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMemoryHostPointerPropertiesEXT>() { return VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryHostPointerPropertiesEXT>() { return VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryMapInfo>() { return VK_STRUCTURE_TYPE_MEMORY_MAP_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryMapInfo>() { return VK_STRUCTURE_TYPE_MEMORY_MAP_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryMapPlacedInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryMapPlacedInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT; }

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkMemoryMetalHandlePropertiesEXT>() { return VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryMetalHandlePropertiesEXT>() { return VK_STRUCTURE_TYPE_MEMORY_METAL_HANDLE_PROPERTIES_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMemoryOpaqueCaptureAddressAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryOpaqueCaptureAddressAllocateInfo>() { return VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryPriorityAllocateInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryPriorityAllocateInfoEXT>() { return VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryRequirements2>() { return VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryRequirements2>() { return VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryToImageCopy>() { return VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryToImageCopy>() { return VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY; }

  template <> constexpr VkStructureType ResolveSType<VkMemoryUnmapInfo>() { return VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryUnmapInfo>() { return VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkMemoryWin32HandlePropertiesKHR>() { return VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryWin32HandlePropertiesKHR>() { return VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkMemoryZirconHandlePropertiesFUCHSIA>() { return VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkMemoryZirconHandlePropertiesFUCHSIA>() { return VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA; }
#endif

#ifdef VK_USE_PLATFORM_METAL_EXT
  template <> constexpr VkStructureType ResolveSType<VkMetalSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMetalSurfaceCreateInfoEXT>() { return VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkMicromapBuildInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMicromapBuildInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMicromapBuildSizesInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMicromapBuildSizesInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMicromapCreateInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMicromapCreateInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMicromapVersionInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMicromapVersionInfoEXT>() { return VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMultisamplePropertiesEXT>() { return VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMultisamplePropertiesEXT>() { return VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMultisampledRenderToSingleSampledInfoEXT>() { return VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMultisampledRenderToSingleSampledInfoEXT>() { return VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkMutableDescriptorTypeCreateInfoEXT>() { return VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkMutableDescriptorTypeCreateInfoEXT>() { return VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT; }

#ifdef VK_USE_PLATFORM_OHOS
  template <> constexpr VkStructureType ResolveSType<VkOHSurfaceCreateInfoOHOS>() { return VK_STRUCTURE_TYPE_OH_SURFACE_CREATE_INFO_OHOS; }
  template <> constexpr VkStructureType ResolveSType<const VkOHSurfaceCreateInfoOHOS>() { return VK_STRUCTURE_TYPE_OH_SURFACE_CREATE_INFO_OHOS; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkOpaqueCaptureDescriptorDataCreateInfoEXT>() { return VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkOpaqueCaptureDescriptorDataCreateInfoEXT>() { return VK_STRUCTURE_TYPE_OPAQUE_CAPTURE_DESCRIPTOR_DATA_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkOpticalFlowExecuteInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOpticalFlowExecuteInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkOpticalFlowImageFormatInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOpticalFlowImageFormatInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkOpticalFlowImageFormatPropertiesNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOpticalFlowImageFormatPropertiesNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkOpticalFlowSessionCreateInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOpticalFlowSessionCreateInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkOpticalFlowSessionCreatePrivateDataInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOpticalFlowSessionCreatePrivateDataInfoNV>() { return VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkOutOfBandQueueTypeInfoNV>() { return VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkOutOfBandQueueTypeInfoNV>() { return VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPartitionedAccelerationStructureFlagsNV>() { return VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPartitionedAccelerationStructureFlagsNV>() { return VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_FLAGS_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPartitionedAccelerationStructureInstancesInputNV>() { return VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPartitionedAccelerationStructureInstancesInputNV>() { return VK_STRUCTURE_TYPE_PARTITIONED_ACCELERATION_STRUCTURE_INSTANCES_INPUT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPerTileBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPerTileBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_PER_TILE_BEGIN_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPerTileEndInfoQCOM>() { return VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPerTileEndInfoQCOM>() { return VK_STRUCTURE_TYPE_PER_TILE_END_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceConfigurationAcquireInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceConfigurationAcquireInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceCounterDescriptionKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceCounterDescriptionKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceCounterKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceCounterKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceMarkerInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceMarkerInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceOverrideInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceOverrideInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceQuerySubmitInfoKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceQuerySubmitInfoKHR>() { return VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPerformanceStreamMarkerInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkPerformanceStreamMarkerInfoINTEL>() { return VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevice16BitStorageFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevice16BitStorageFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevice4444FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevice4444FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevice8BitStorageFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevice8BitStorageFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceASTCDecodeFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceASTCDecodeFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAccelerationStructureFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAccelerationStructureFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAccelerationStructurePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAccelerationStructurePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAddressBindingReportFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAddressBindingReportFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAmigoProfilingFeaturesSEC>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAmigoProfilingFeaturesSEC>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAntiLagFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAntiLagFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ANTI_LAG_FEATURES_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceBufferDeviceAddressFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceBufferDeviceAddressFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceClusterAccelerationStructureFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceClusterAccelerationStructureFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceClusterAccelerationStructurePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceClusterAccelerationStructurePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_ACCELERATION_STRUCTURE_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCoherentMemoryFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCoherentMemoryFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceColorWriteEnableFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceColorWriteEnableFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCommandBufferInheritanceFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMMAND_BUFFER_INHERITANCE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceConditionalRenderingFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceConditionalRenderingFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceConservativeRasterizationPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrix2FeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrix2FeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrix2PropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrix2PropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_2_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrixFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrixFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrixFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrixFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrixPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrixPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeMatrixPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeMatrixPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeVectorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeVectorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCooperativeVectorPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCooperativeVectorPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_VECTOR_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCopyMemoryIndirectPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCopyMemoryIndirectPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COPY_MEMORY_INDIRECT_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCornerSampledImageFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCornerSampledImageFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCoverageReductionModeFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCoverageReductionModeFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCubicClampFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCubicClampFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCubicWeightsFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCubicWeightsFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCudaKernelLaunchFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCudaKernelLaunchFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_FEATURES_NV; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCudaKernelLaunchPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCudaKernelLaunchPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUDA_KERNEL_LAUNCH_PROPERTIES_NV; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCustomBorderColorFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCustomBorderColorFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceCustomBorderColorPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceCustomBorderColorPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDataGraphFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDataGraphFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DATA_GRAPH_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthBiasControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthBiasControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthClampControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthClampControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_CONTROL_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthClampZeroOneFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthClipControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthClipControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthClipEnableFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthClipEnableFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDepthStencilResolveProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDepthStencilResolveProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorBufferDensityMapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_DENSITY_MAP_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorBufferFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorBufferFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorBufferPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorBufferPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorBufferTensorFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorBufferTensorFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorBufferTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorBufferTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_BUFFER_TENSOR_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorIndexingFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorIndexingFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorIndexingProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorIndexingProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDiscardRectanglePropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDiscardRectanglePropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDisplacementMicromapFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDisplacementMicromapFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDisplacementMicromapPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDisplacementMicromapPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDriverProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDriverProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDrmPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDrmPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDynamicRenderingFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDynamicRenderingFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDynamicRenderingLocalReadFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDynamicRenderingLocalReadFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExclusiveScissorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExclusiveScissorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalBufferInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalBufferInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalComputeQueuePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalComputeQueuePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_COMPUTE_QUEUE_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalFenceInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalFenceInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO; }

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID; }
#endif

#ifdef VK_USE_PLATFORM_ANDROID_KHR
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalFormatResolvePropertiesANDROID>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalImageFormatInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalImageFormatInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalMemoryHostPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV; }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_SCREEN_BUFFER_FEATURES_QNX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalSemaphoreInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalSemaphoreInfo>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceExternalTensorInfoARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceExternalTensorInfoARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_TENSOR_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFaultFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFaultFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFeatures2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFeatures2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFloatControlsProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFloatControlsProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFormatPackFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFormatPackFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FORMAT_PACK_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_FEATURES_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_LAYERED_PROPERTIES_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentDensityMapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShadingRateKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShadingRateKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFragmentShadingRatePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceFrameBoundaryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceFrameBoundaryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceGlobalPriorityQueryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceGlobalPriorityQueryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceGroupProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceGroupProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceHdrVividFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceHdrVividFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HDR_VIVID_FEATURES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceHostImageCopyFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceHostImageCopyFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceHostImageCopyProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceHostImageCopyProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceHostQueryResetFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceHostQueryResetFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceIDProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceIDProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageAlignmentControlFeaturesMESA>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageAlignmentControlFeaturesMESA>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_FEATURES_MESA; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageAlignmentControlPropertiesMESA>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageAlignmentControlPropertiesMESA>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ALIGNMENT_CONTROL_PROPERTIES_MESA; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageCompressionControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageCompressionControlFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageDrmFormatModifierInfoEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageFormatInfo2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageFormatInfo2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageProcessing2FeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageProcessing2FeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageProcessing2PropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageProcessing2PropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageProcessingFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageProcessingFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageProcessingPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageProcessingPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageRobustnessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageRobustnessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageViewImageFormatInfoEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageViewImageFormatInfoEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImageViewMinLodFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImageViewMinLodFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceImagelessFramebufferFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceImagelessFramebufferFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceIndexTypeUint8Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceIndexTypeUint8Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceInheritedViewportScissorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceInheritedViewportScissorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceInlineUniformBlockFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceInlineUniformBlockFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceInlineUniformBlockProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceInlineUniformBlockProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLayeredApiPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLayeredApiPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLayeredApiPropertiesListKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLayeredApiPropertiesListKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_PROPERTIES_LIST_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLayeredApiVulkanPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLayeredApiVulkanPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_API_VULKAN_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLayeredDriverPropertiesMSFT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLayeredDriverPropertiesMSFT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLegacyDitheringFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLegacyDitheringFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_VERTEX_ATTRIBUTES_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLineRasterizationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLineRasterizationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLineRasterizationProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLineRasterizationProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceLinearColorAttachmentFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceLinearColorAttachmentFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance3Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance3Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance4Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance4Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance4Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance4Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance5Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance5Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance5Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance5Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance6Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance6Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance6Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance6Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance7FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance7FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance7PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance7PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_7_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance8FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance8FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_8_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance9FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance9FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMaintenance9PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMaintenance9PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_9_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMapMemoryPlacedPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMemoryBudgetPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMemoryBudgetPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMemoryDecompressionFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMemoryDecompressionFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMemoryDecompressionPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMemoryDecompressionPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_DECOMPRESSION_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMemoryPriorityFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMemoryPriorityFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMemoryProperties2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMemoryProperties2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMeshShaderFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMeshShaderFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMeshShaderFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMeshShaderFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMeshShaderPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMeshShaderPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMeshShaderPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMeshShaderPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiDrawFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiDrawFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiDrawPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiDrawPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiviewFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiviewFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMultiviewProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMultiviewProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceNestedCommandBufferFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceNestedCommandBufferFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceNestedCommandBufferPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceNestedCommandBufferPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceOpacityMicromapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceOpacityMicromapFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceOpacityMicromapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceOpacityMicromapPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceOpticalFlowFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceOpticalFlowFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceOpticalFlowPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceOpticalFlowPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePCIBusInfoPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePCIBusInfoPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PARTITIONED_ACCELERATION_STRUCTURE_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePerStageDescriptorSetFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePerStageDescriptorSetFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePerformanceQueryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePerformanceQueryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePerformanceQueryPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePerformanceQueryPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineBinaryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineBinaryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineBinaryPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineBinaryPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_BINARY_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CACHE_INCREMENTAL_MODE_FEATURES_SEC; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineCreationCacheControlFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineCreationCacheControlFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineOpacityMicromapFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_OPACITY_MICROMAP_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelinePropertiesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelinePropertiesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROPERTIES_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineProtectedAccessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineProtectedAccessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineRobustnessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineRobustnessFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePipelineRobustnessProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePipelineRobustnessProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePointClippingProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePointClippingProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePortabilitySubsetFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePortabilitySubsetFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePortabilitySubsetPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePortabilitySubsetPropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentBarrierFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentBarrierFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentId2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentId2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_2_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentIdFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentIdFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentMeteringFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentMeteringFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_METERING_FEATURES_NV; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_MODE_FIFO_LATEST_READY_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentWait2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentWait2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_2_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePresentWaitFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePresentWaitFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePrivateDataFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePrivateDataFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceProperties2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceProperties2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceProtectedMemoryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceProtectedMemoryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceProtectedMemoryProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceProtectedMemoryProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceProvokingVertexFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceProvokingVertexFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceProvokingVertexPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceProvokingVertexPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDevicePushDescriptorProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDevicePushDescriptorProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRawAccessChainsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRawAccessChainsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayQueryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayQueryFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_LINEAR_SWEPT_SPHERES_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingPipelinePropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRayTracingValidationFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRayTracingValidationFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRenderPassStripedFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRenderPassStripedFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRenderPassStripedPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRenderPassStripedPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRobustness2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRobustness2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceRobustness2PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceRobustness2PropertiesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSampleLocationsPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSampleLocationsPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSamplerFilterMinmaxProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSamplerFilterMinmaxProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSamplerYcbcrConversionFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSamplerYcbcrConversionFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceScalarBlockLayoutFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceScalarBlockLayoutFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSchedulingControlsFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSchedulingControlsFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSchedulingControlsPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSchedulingControlsPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderAtomicInt64Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderAtomicInt64Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderBfloat16FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderBfloat16FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_BFLOAT16_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderClockFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderClockFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderCoreProperties2AMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderCoreProperties2AMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderCorePropertiesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderCorePropertiesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderCorePropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderCorePropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderDrawParametersFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderDrawParametersFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderEnqueueFeaturesAMDX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderEnqueueFeaturesAMDX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_FEATURES_AMDX; }
#endif

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderEnqueuePropertiesAMDX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderEnqueuePropertiesAMDX>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ENQUEUE_PROPERTIES_AMDX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderExpectAssumeFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderExpectAssumeFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderFloat16Int8Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderFloat16Int8Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderFloat8FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderFloat8FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT8_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderFloatControls2Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderFloatControls2Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderImageFootprintFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderImageFootprintFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderIntegerDotProductFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderIntegerDotProductFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderIntegerDotProductProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderIntegerDotProductProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderObjectFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderObjectFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderObjectPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderObjectPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderQuadControlFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderQuadControlFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_RELAXED_EXTENDED_INSTRUCTION_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_REPLICATED_COMPOSITES_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderSubgroupRotateFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderSubgroupRotateFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderTerminateInvocationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderTerminateInvocationFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderTileImageFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderTileImageFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShaderTileImagePropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShaderTileImagePropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShadingRateImageFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShadingRateImageFeaturesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceShadingRateImagePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceShadingRateImagePropertiesNV>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSparseImageFormatInfo2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSparseImageFormatInfo2>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubgroupProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubgroupProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubgroupSizeControlFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubgroupSizeControlFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubgroupSizeControlProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubgroupSizeControlProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_FEATURES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSubpassShadingPropertiesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSubpassShadingPropertiesHUAWEI>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_SHADING_PROPERTIES_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSurfaceInfo2KHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSurfaceInfo2KHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceSynchronization2Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceSynchronization2Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTensorFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTensorFeaturesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_FEATURES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTensorPropertiesARM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TENSOR_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTexelBufferAlignmentProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTexelBufferAlignmentProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTextureCompressionASTCHDRFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTileMemoryHeapFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTileMemoryHeapPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTileMemoryHeapPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_MEMORY_HEAP_PROPERTIES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTilePropertiesFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTilePropertiesFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTileShadingFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTileShadingFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTileShadingPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTileShadingPropertiesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_SHADING_PROPERTIES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTimelineSemaphoreFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTimelineSemaphoreFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTimelineSemaphoreProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTimelineSemaphoreProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceToolProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceToolProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTransformFeedbackFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTransformFeedbackFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceTransformFeedbackPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceTransformFeedbackPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFIED_IMAGE_LAYOUTS_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVariablePointersFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVariablePointersFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVertexAttributeDivisorFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVertexAttributeDivisorFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVertexAttributeDivisorProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVertexAttributeDivisorProperties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_ROBUSTNESS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoDecodeVP9FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_DECODE_VP9_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoEncodeAV1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_AV1_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_INTRA_REFRESH_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUANTIZATION_MAP_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoFormatInfoKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoFormatInfoKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoMaintenance1FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVideoMaintenance2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVideoMaintenance2FeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_2_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan11Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan11Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan11Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan11Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan12Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan12Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan12Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan12Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan13Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan13Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan13Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan13Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan14Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan14Features>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkan14Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkan14Properties>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceVulkanMemoryModelFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceVulkanMemoryModelFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_DEVICE_MEMORY_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES; }
  template <> constexpr VkStructureType ResolveSType<const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>() { return VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineBinaryCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineBinaryCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineBinaryDataInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineBinaryDataInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_DATA_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineBinaryHandlesInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineBinaryHandlesInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_HANDLES_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineBinaryInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineBinaryInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineBinaryKeyKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineBinaryKeyKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_BINARY_KEY_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCacheCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCacheCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineColorBlendAdvancedStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineColorBlendAdvancedStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineColorBlendStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineColorBlendStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineColorWriteCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineColorWriteCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCompilerControlCreateInfoAMD>() { return VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCompilerControlCreateInfoAMD>() { return VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCoverageModulationStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCoverageModulationStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCoverageReductionStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCoverageReductionStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCoverageToColorStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCoverageToColorStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCreateFlags2CreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCreateFlags2CreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineCreationFeedbackCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineCreationFeedbackCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineDepthStencilStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineDepthStencilStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineDiscardRectangleStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineDiscardRectangleStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineDynamicStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineDynamicStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineExecutableInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineExecutableInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineExecutableInternalRepresentationKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineExecutableInternalRepresentationKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineExecutablePropertiesKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineExecutablePropertiesKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineExecutableStatisticKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineExecutableStatisticKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineFragmentDensityMapLayeredCreateInfoVALVE>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineFragmentDensityMapLayeredCreateInfoVALVE>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_DENSITY_MAP_LAYERED_CREATE_INFO_VALVE; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineFragmentShadingRateEnumStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineFragmentShadingRateEnumStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineFragmentShadingRateStateCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineFragmentShadingRateStateCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineIndirectDeviceAddressInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineIndirectDeviceAddressInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineInputAssemblyStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineInputAssemblyStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineLayoutCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineLayoutCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineLibraryCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineLibraryCreateInfoKHR>() { return VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineMultisampleStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineMultisampleStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelinePropertiesIdentifierEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelinePropertiesIdentifierEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_PROPERTIES_IDENTIFIER_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationConservativeStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationConservativeStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationDepthClipStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationDepthClipStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationLineStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationLineStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationStateRasterizationOrderAMD>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationStateRasterizationOrderAMD>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRasterizationStateStreamCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRasterizationStateStreamCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRenderingCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRenderingCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRepresentativeFragmentTestStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineRobustnessCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineRobustnessCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineSampleLocationsStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineSampleLocationsStateCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineShaderStageCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineShaderStageCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineShaderStageModuleIdentifierCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineShaderStageModuleIdentifierCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkPipelineShaderStageNodeCreateInfoAMDX>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineShaderStageNodeCreateInfoAMDX>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_NODE_CREATE_INFO_AMDX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineTessellationDomainOriginStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineTessellationDomainOriginStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineTessellationStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineTessellationStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineVertexInputDivisorStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineVertexInputDivisorStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineVertexInputStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineVertexInputStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportDepthClampControlCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportDepthClampControlCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLAMP_CONTROL_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportDepthClipControlCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportDepthClipControlCreateInfoEXT>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportExclusiveScissorStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportExclusiveScissorStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportShadingRateImageStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportShadingRateImageStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportStateCreateInfo>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportSwizzleStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportSwizzleStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkPipelineViewportWScalingStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkPipelineViewportWScalingStateCreateInfoNV>() { return VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV; }

#ifdef VK_USE_PLATFORM_GGP
  template <> constexpr VkStructureType ResolveSType<VkPresentFrameTokenGGP>() { return VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentFrameTokenGGP>() { return VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkPresentId2KHR>() { return VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentId2KHR>() { return VK_STRUCTURE_TYPE_PRESENT_ID_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPresentIdKHR>() { return VK_STRUCTURE_TYPE_PRESENT_ID_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentIdKHR>() { return VK_STRUCTURE_TYPE_PRESENT_ID_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPresentInfoKHR>() { return VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentInfoKHR>() { return VK_STRUCTURE_TYPE_PRESENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPresentRegionsKHR>() { return VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentRegionsKHR>() { return VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPresentTimesInfoGOOGLE>() { return VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentTimesInfoGOOGLE>() { return VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE; }

  template <> constexpr VkStructureType ResolveSType<VkPresentWait2InfoKHR>() { return VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkPresentWait2InfoKHR>() { return VK_STRUCTURE_TYPE_PRESENT_WAIT_2_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkPrivateDataSlotCreateInfo>() { return VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPrivateDataSlotCreateInfo>() { return VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkProtectedSubmitInfo>() { return VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkProtectedSubmitInfo>() { return VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPushConstantsInfo>() { return VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPushConstantsInfo>() { return VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPushDescriptorSetInfo>() { return VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPushDescriptorSetInfo>() { return VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkPushDescriptorSetWithTemplateInfo>() { return VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkPushDescriptorSetWithTemplateInfo>() { return VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkQueryLowLatencySupportNV>() { return VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkQueryLowLatencySupportNV>() { return VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV; }

  template <> constexpr VkStructureType ResolveSType<VkQueryPoolCreateInfo>() { return VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkQueryPoolCreateInfo>() { return VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkQueryPoolPerformanceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkQueryPoolPerformanceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkQueryPoolPerformanceQueryCreateInfoINTEL>() { return VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL; }
  template <> constexpr VkStructureType ResolveSType<const VkQueryPoolPerformanceQueryCreateInfoINTEL>() { return VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL; }

  template <> constexpr VkStructureType ResolveSType<VkQueryPoolVideoEncodeFeedbackCreateInfoKHR>() { return VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR>() { return VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyCheckpointProperties2NV>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyCheckpointProperties2NV>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyCheckpointPropertiesNV>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyCheckpointPropertiesNV>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyDataGraphProcessingEnginePropertiesARM>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyDataGraphProcessingEnginePropertiesARM>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROCESSING_ENGINE_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyDataGraphPropertiesARM>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyDataGraphPropertiesARM>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_DATA_GRAPH_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyGlobalPriorityProperties>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyGlobalPriorityProperties>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyOwnershipTransferPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyOwnershipTransferPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_OWNERSHIP_TRANSFER_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyProperties2>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyProperties2>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyQueryResultStatusPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyQueryResultStatusPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkQueueFamilyVideoPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkQueueFamilyVideoPropertiesKHR>() { return VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingPipelineClusterAccelerationStructureCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CLUSTER_ACCELERATION_STRUCTURE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingPipelineCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingPipelineCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingPipelineCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingPipelineCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingPipelineInterfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingPipelineInterfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingShaderGroupCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingShaderGroupCreateInfoKHR>() { return VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRayTracingShaderGroupCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkRayTracingShaderGroupCreateInfoNV>() { return VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkReleaseCapturedPipelineDataInfoKHR>() { return VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkReleaseCapturedPipelineDataInfoKHR>() { return VK_STRUCTURE_TYPE_RELEASE_CAPTURED_PIPELINE_DATA_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkReleaseSwapchainImagesInfoKHR>() { return VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkReleaseSwapchainImagesInfoKHR>() { return VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassAttachmentBeginInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassAttachmentBeginInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassBeginInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassBeginInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassCreateInfo2>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassCreateInfo2>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassCreationControlEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassCreationControlEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassCreationFeedbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassCreationFeedbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassFragmentDensityMapCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassFragmentDensityMapCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassFragmentDensityMapOffsetEndInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassFragmentDensityMapOffsetEndInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassInputAttachmentAspectCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassInputAttachmentAspectCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassMultiviewCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassMultiviewCreateInfo>() { return VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassSampleLocationsBeginInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassSampleLocationsBeginInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassStripeBeginInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassStripeBeginInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassStripeInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassStripeInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassStripeSubmitInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassStripeSubmitInfoARM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassSubpassFeedbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassSubpassFeedbackCreateInfoEXT>() { return VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassTileShadingCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassTileShadingCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_TILE_SHADING_CREATE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkRenderPassTransformBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderPassTransformBeginInfoQCOM>() { return VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingAreaInfo>() { return VK_STRUCTURE_TYPE_RENDERING_AREA_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingAreaInfo>() { return VK_STRUCTURE_TYPE_RENDERING_AREA_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingAttachmentInfo>() { return VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingAttachmentInfo>() { return VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingAttachmentLocationInfo>() { return VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingAttachmentLocationInfo>() { return VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingEndInfoEXT>() { return VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingEndInfoEXT>() { return VK_STRUCTURE_TYPE_RENDERING_END_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingFragmentDensityMapAttachmentInfoEXT>() { return VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingFragmentDensityMapAttachmentInfoEXT>() { return VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingFragmentShadingRateAttachmentInfoKHR>() { return VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingFragmentShadingRateAttachmentInfoKHR>() { return VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingInfo>() { return VK_STRUCTURE_TYPE_RENDERING_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingInfo>() { return VK_STRUCTURE_TYPE_RENDERING_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkRenderingInputAttachmentIndexInfo>() { return VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkRenderingInputAttachmentIndexInfo>() { return VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkResolveImageInfo2>() { return VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkResolveImageInfo2>() { return VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkSampleLocationsInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSampleLocationsInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerBlockMatchWindowCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerBlockMatchWindowCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerBorderColorComponentMappingCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerBorderColorComponentMappingCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerCaptureDescriptorDataInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_CAPTURE_DESCRIPTOR_DATA_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerCubicWeightsCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerCubicWeightsCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerCustomBorderColorCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerCustomBorderColorCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerReductionModeCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerReductionModeCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerYcbcrConversionCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerYcbcrConversionCreateInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerYcbcrConversionImageFormatProperties>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerYcbcrConversionImageFormatProperties>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerYcbcrConversionInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerYcbcrConversionInfo>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM>() { return VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM; }

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkScreenBufferFormatPropertiesQNX>() { return VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkScreenBufferFormatPropertiesQNX>() { return VK_STRUCTURE_TYPE_SCREEN_BUFFER_FORMAT_PROPERTIES_QNX; }
#endif

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkScreenBufferPropertiesQNX>() { return VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkScreenBufferPropertiesQNX>() { return VK_STRUCTURE_TYPE_SCREEN_BUFFER_PROPERTIES_QNX; }
#endif

#ifdef VK_USE_PLATFORM_SCREEN_QNX
  template <> constexpr VkStructureType ResolveSType<VkScreenSurfaceCreateInfoQNX>() { return VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX; }
  template <> constexpr VkStructureType ResolveSType<const VkScreenSurfaceCreateInfoQNX>() { return VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreCreateInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreCreateInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreGetFdInfoKHR>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkSemaphoreGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreGetWin32HandleInfoKHR>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkSemaphoreGetZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreGetZirconHandleInfoFUCHSIA>() { return VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreSignalInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreSignalInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreSubmitInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreSubmitInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreTypeCreateInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreTypeCreateInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSemaphoreWaitInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSemaphoreWaitInfo>() { return VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSetDescriptorBufferOffsetsInfoEXT>() { return VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSetDescriptorBufferOffsetsInfoEXT>() { return VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSetLatencyMarkerInfoNV>() { return VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkSetLatencyMarkerInfoNV>() { return VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV; }

#ifdef VK_ENABLE_BETA_EXTENSIONS
  template <> constexpr VkStructureType ResolveSType<VkSetPresentConfigNV>() { return VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkSetPresentConfigNV>() { return VK_STRUCTURE_TYPE_SET_PRESENT_CONFIG_NV; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkShaderCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkShaderCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkShaderModuleCreateInfo>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkShaderModuleCreateInfo>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkShaderModuleIdentifierEXT>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkShaderModuleIdentifierEXT>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkShaderModuleValidationCacheCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkShaderModuleValidationCacheCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSharedPresentSurfaceCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSharedPresentSurfaceCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSparseImageFormatProperties2>() { return VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSparseImageFormatProperties2>() { return VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2; }

  template <> constexpr VkStructureType ResolveSType<VkSparseImageMemoryRequirements2>() { return VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSparseImageMemoryRequirements2>() { return VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2; }

#ifdef VK_USE_PLATFORM_GGP
  template <> constexpr VkStructureType ResolveSType<VkStreamDescriptorSurfaceCreateInfoGGP>() { return VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP; }
  template <> constexpr VkStructureType ResolveSType<const VkStreamDescriptorSurfaceCreateInfoGGP>() { return VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkSubmitInfo>() { return VK_STRUCTURE_TYPE_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSubmitInfo>() { return VK_STRUCTURE_TYPE_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSubmitInfo2>() { return VK_STRUCTURE_TYPE_SUBMIT_INFO_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSubmitInfo2>() { return VK_STRUCTURE_TYPE_SUBMIT_INFO_2; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassBeginInfo>() { return VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassBeginInfo>() { return VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassDependency2>() { return VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassDependency2>() { return VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassDescription2>() { return VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassDescription2>() { return VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassDescriptionDepthStencilResolve>() { return VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassDescriptionDepthStencilResolve>() { return VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassEndInfo>() { return VK_STRUCTURE_TYPE_SUBPASS_END_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassEndInfo>() { return VK_STRUCTURE_TYPE_SUBPASS_END_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassResolvePerformanceQueryEXT>() { return VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassResolvePerformanceQueryEXT>() { return VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSubpassShadingPipelineCreateInfoHUAWEI>() { return VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI; }
  template <> constexpr VkStructureType ResolveSType<const VkSubpassShadingPipelineCreateInfoHUAWEI>() { return VK_STRUCTURE_TYPE_SUBPASS_SHADING_PIPELINE_CREATE_INFO_HUAWEI; }

  template <> constexpr VkStructureType ResolveSType<VkSubresourceHostMemcpySize>() { return VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE; }
  template <> constexpr VkStructureType ResolveSType<const VkSubresourceHostMemcpySize>() { return VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE; }

  template <> constexpr VkStructureType ResolveSType<VkSubresourceLayout2>() { return VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2; }
  template <> constexpr VkStructureType ResolveSType<const VkSubresourceLayout2>() { return VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilities2EXT>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilities2EXT>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilities2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilities2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilitiesFullScreenExclusiveEXT>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilitiesFullScreenExclusiveEXT>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilitiesPresentBarrierNV>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilitiesPresentBarrierNV>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilitiesPresentId2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilitiesPresentId2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_ID_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceCapabilitiesPresentWait2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceCapabilitiesPresentWait2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_WAIT_2_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceFormat2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceFormat2KHR>() { return VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR; }

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkSurfaceFullScreenExclusiveInfoEXT>() { return VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceFullScreenExclusiveInfoEXT>() { return VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkSurfaceFullScreenExclusiveWin32InfoEXT>() { return VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceFullScreenExclusiveWin32InfoEXT>() { return VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkSurfacePresentModeCompatibilityKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfacePresentModeCompatibilityKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSurfacePresentModeKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfacePresentModeKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSurfacePresentScalingCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfacePresentScalingCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSurfaceProtectedCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSurfaceProtectedCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainCounterCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainCounterCreateInfoEXT>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainDisplayNativeHdrCreateInfoAMD>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainDisplayNativeHdrCreateInfoAMD>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainLatencyCreateInfoNV>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainLatencyCreateInfoNV>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainPresentBarrierCreateInfoNV>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainPresentBarrierCreateInfoNV>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainPresentFenceInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainPresentFenceInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainPresentModeInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainPresentModeInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainPresentModesCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainPresentModesCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkSwapchainPresentScalingCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkSwapchainPresentScalingCreateInfoKHR>() { return VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_KHR; }

#ifdef VK_USE_PLATFORM_FUCHSIA
  template <> constexpr VkStructureType ResolveSType<VkSysmemColorSpaceFUCHSIA>() { return VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA; }
  template <> constexpr VkStructureType ResolveSType<const VkSysmemColorSpaceFUCHSIA>() { return VK_STRUCTURE_TYPE_SYSMEM_COLOR_SPACE_FUCHSIA; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkTensorCaptureDescriptorDataInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorCaptureDescriptorDataInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_CAPTURE_DESCRIPTOR_DATA_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorCopyARM>() { return VK_STRUCTURE_TYPE_TENSOR_COPY_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorCopyARM>() { return VK_STRUCTURE_TYPE_TENSOR_COPY_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorCreateInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorCreateInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorDependencyInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorDependencyInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_DEPENDENCY_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorDescriptionARM>() { return VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorDescriptionARM>() { return VK_STRUCTURE_TYPE_TENSOR_DESCRIPTION_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorFormatPropertiesARM>() { return VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorFormatPropertiesARM>() { return VK_STRUCTURE_TYPE_TENSOR_FORMAT_PROPERTIES_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorMemoryBarrierARM>() { return VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorMemoryBarrierARM>() { return VK_STRUCTURE_TYPE_TENSOR_MEMORY_BARRIER_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorMemoryRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorMemoryRequirementsInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_MEMORY_REQUIREMENTS_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorViewCaptureDescriptorDataInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorViewCaptureDescriptorDataInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_VIEW_CAPTURE_DESCRIPTOR_DATA_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTensorViewCreateInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkTensorViewCreateInfoARM>() { return VK_STRUCTURE_TYPE_TENSOR_VIEW_CREATE_INFO_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkTextureLODGatherFormatPropertiesAMD>() { return VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD; }
  template <> constexpr VkStructureType ResolveSType<const VkTextureLODGatherFormatPropertiesAMD>() { return VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD; }

  template <> constexpr VkStructureType ResolveSType<VkTileMemoryBindInfoQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkTileMemoryBindInfoQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_BIND_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkTileMemoryRequirementsQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkTileMemoryRequirementsQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_REQUIREMENTS_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkTileMemorySizeInfoQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkTileMemorySizeInfoQCOM>() { return VK_STRUCTURE_TYPE_TILE_MEMORY_SIZE_INFO_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkTilePropertiesQCOM>() { return VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM; }
  template <> constexpr VkStructureType ResolveSType<const VkTilePropertiesQCOM>() { return VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM; }

  template <> constexpr VkStructureType ResolveSType<VkTimelineSemaphoreSubmitInfo>() { return VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO; }
  template <> constexpr VkStructureType ResolveSType<const VkTimelineSemaphoreSubmitInfo>() { return VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO; }

  template <> constexpr VkStructureType ResolveSType<VkValidationCacheCreateInfoEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkValidationCacheCreateInfoEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkValidationFeaturesEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkValidationFeaturesEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkValidationFlagsEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkValidationFlagsEXT>() { return VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkVertexInputAttributeDescription2EXT>() { return VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkVertexInputAttributeDescription2EXT>() { return VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkVertexInputBindingDescription2EXT>() { return VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkVertexInputBindingDescription2EXT>() { return VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT; }

#ifdef VK_USE_PLATFORM_VI_NN
  template <> constexpr VkStructureType ResolveSType<VkViSurfaceCreateInfoNN>() { return VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN; }
  template <> constexpr VkStructureType ResolveSType<const VkViSurfaceCreateInfoNN>() { return VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkVideoBeginCodingInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoBeginCodingInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoCodingControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoCodingControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_INLINE_SESSION_PARAMETERS_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeAV1SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeAV1SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_INLINE_SESSION_PARAMETERS_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH264SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH264SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265InlineSessionParametersInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_INLINE_SESSION_PARAMETERS_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeH265SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeH265SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeUsageInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeUsageInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeVP9CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeVP9CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeVP9PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeVP9PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoDecodeVP9ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoDecodeVP9ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_DECODE_VP9_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_GOP_REMAINING_FRAME_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUALITY_LEVEL_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_QUANTIZATION_MAP_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_RATE_CONTROL_LAYER_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeAV1SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeAV1SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264NaluSliceInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264NaluSliceInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUANTIZATION_MAP_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264SessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264SessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH264SessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH264SessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265CapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265DpbSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265GopRemainingFrameInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265NaluSliceSegmentInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265NaluSliceSegmentInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265PictureInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265ProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265QualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265QuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUANTIZATION_MAP_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265RateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265RateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265SessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265SessionParametersAddInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265SessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265SessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265SessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeH265SessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeH265SessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeIntraRefreshCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeIntraRefreshCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeIntraRefreshInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeIntraRefreshInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_INTRA_REFRESH_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeQualityLevelInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeQualityLevelInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeQualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeQualityLevelPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeQuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeQuantizationMapCapabilitiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_CAPABILITIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeQuantizationMapInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeQuantizationMapInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUANTIZATION_MAP_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeRateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeRateControlInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeRateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeRateControlLayerInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeSessionIntraRefreshCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeSessionIntraRefreshCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_INTRA_REFRESH_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeSessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeSessionParametersFeedbackInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeSessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeSessionParametersGetInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEncodeUsageInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEncodeUsageInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoEndCodingInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoEndCodingInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoFormatAV1QuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoFormatAV1QuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_AV1_QUANTIZATION_MAP_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoFormatH265QuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoFormatH265QuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_H265_QUANTIZATION_MAP_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoFormatPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoFormatPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoFormatQuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoFormatQuantizationMapPropertiesKHR>() { return VK_STRUCTURE_TYPE_VIDEO_FORMAT_QUANTIZATION_MAP_PROPERTIES_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoInlineQueryInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoInlineQueryInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoPictureResourceInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoPictureResourceInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoProfileInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoProfileListInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoProfileListInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoReferenceIntraRefreshInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoReferenceIntraRefreshInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_REFERENCE_INTRA_REFRESH_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoReferenceSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoReferenceSlotInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoSessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoSessionCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoSessionMemoryRequirementsKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoSessionMemoryRequirementsKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoSessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoSessionParametersCreateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkVideoSessionParametersUpdateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkVideoSessionParametersUpdateInfoKHR>() { return VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR; }

#ifdef VK_USE_PLATFORM_WAYLAND_KHR
  template <> constexpr VkStructureType ResolveSType<VkWaylandSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkWaylandSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkWin32KeyedMutexAcquireReleaseInfoKHR>() { return VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkWin32KeyedMutexAcquireReleaseInfoKHR>() { return VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkWin32KeyedMutexAcquireReleaseInfoNV>() { return VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkWin32KeyedMutexAcquireReleaseInfoNV>() { return VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV; }
#endif

#ifdef VK_USE_PLATFORM_WIN32_KHR
  template <> constexpr VkStructureType ResolveSType<VkWin32SurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkWin32SurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR; }
#endif

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSet>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSet>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET; }

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSetAccelerationStructureKHR>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSetAccelerationStructureKHR>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR; }

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSetAccelerationStructureNV>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSetAccelerationStructureNV>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV; }

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSetInlineUniformBlock>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSetInlineUniformBlock>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK; }

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSetPartitionedAccelerationStructureNV>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSetPartitionedAccelerationStructureNV>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_PARTITIONED_ACCELERATION_STRUCTURE_NV; }

  template <> constexpr VkStructureType ResolveSType<VkWriteDescriptorSetTensorARM>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteDescriptorSetTensorARM>() { return VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_TENSOR_ARM; }

  template <> constexpr VkStructureType ResolveSType<VkWriteIndirectExecutionSetPipelineEXT>() { return VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteIndirectExecutionSetPipelineEXT>() { return VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_PIPELINE_EXT; }

  template <> constexpr VkStructureType ResolveSType<VkWriteIndirectExecutionSetShaderEXT>() { return VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT; }
  template <> constexpr VkStructureType ResolveSType<const VkWriteIndirectExecutionSetShaderEXT>() { return VK_STRUCTURE_TYPE_WRITE_INDIRECT_EXECUTION_SET_SHADER_EXT; }

#ifdef VK_USE_PLATFORM_XCB_KHR
  template <> constexpr VkStructureType ResolveSType<VkXcbSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkXcbSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR; }
#endif

#ifdef VK_USE_PLATFORM_XLIB_KHR
  template <> constexpr VkStructureType ResolveSType<VkXlibSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR; }
  template <> constexpr VkStructureType ResolveSType<const VkXlibSurfaceCreateInfoKHR>() { return VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR; }
#endif
}

namespace vkroots {

  static VkResult implicit_wrap_CreateInstance(
    const VkInstanceCreateInfo*  pCreateInfo,
    const VkAllocationCallbacks* pAllocator,
          VkInstance*            pInstance) {
    VkInstanceProcAddrFuncs instanceProcAddrFuncs;
    VkResult procAddrRes = GetProcAddrs(pCreateInfo, &instanceProcAddrFuncs);
    if (procAddrRes != VK_SUCCESS)
      return procAddrRes;
    PFN_vkCreateInstance createInstanceProc = (PFN_vkCreateInstance) instanceProcAddrFuncs.NextGetInstanceProcAddr(nullptr, "vkCreateInstance");
    VkResult ret = createInstanceProc(pCreateInfo, pAllocator, pInstance);
    if (ret == VK_SUCCESS)
      tables::CreateDispatchTable(instanceProcAddrFuncs.NextGetInstanceProcAddr, instanceProcAddrFuncs.NextGetPhysicalDeviceProcAddr, *pInstance);
    return ret;
  }

}
namespace vkroots {

  static void implicit_wrap_DestroyInstance(
          VkInstance             instance,
    const VkAllocationCallbacks* pAllocator) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(instance);
    // Implemented in the Dispatch class, goes to DestroyInstanceWrapper.
    // Make sure we call ours here.
    dispatch->DestroyInstance(instance, pAllocator);
  }

}
namespace vkroots {
  
  static VkResult implicit_wrap_CreateDevice(
            VkPhysicalDevice       physicalDevice,
      const VkDeviceCreateInfo*    pCreateInfo,
      const VkAllocationCallbacks* pAllocator,
            VkDevice*              pDevice) {
    const VkInstanceDispatch* dispatch = tables::LookupInstanceDispatch(physicalDevice);
    PFN_vkGetDeviceProcAddr deviceProcAddr;
    VkResult procAddrRes = GetProcAddrs(pCreateInfo, &deviceProcAddr);
    if (procAddrRes != VK_SUCCESS)
      return procAddrRes;
    VkResult ret = dispatch->_RealCreateDevice(physicalDevice, pCreateInfo, pAllocator, pDevice);
    if (ret == VK_SUCCESS)
      tables::CreateDispatchTable(pCreateInfo, deviceProcAddr, physicalDevice, *pDevice);
    return ret;
  }

}
namespace vkroots {

  static void implicit_wrap_DestroyDevice(
          VkDevice               device,
    const VkAllocationCallbacks* pAllocator) {
    const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
    // Implemented in the Dispatch class, goes to DestroyDeviceWrapper.
    // Make sure we call ours here.
    dispatch->DestroyDevice(device, pAllocator);
  }

}
namespace vkroots {
      static VkResult implicit_wrap_AllocateCommandBuffers(VkDevice device, const VkCommandBufferAllocateInfo *pAllocateInfo, VkCommandBuffer *pCommandBuffers){
          const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
          VkResult ret = dispatch->_RealAllocateCommandBuffers(device, pAllocateInfo, pCommandBuffers);
          if (ret == VK_SUCCESS) {
              for (uint32_t i = 0; i < pAllocateInfo->commandBufferCount; i++)
                tables::AssignDispatchTable(pCommandBuffers[i], dispatch);
          }
          return ret;
      };
      static void implicit_wrap_FreeCommandBuffers(VkDevice device, VkCommandPool commandPool, uint32_t commandBufferCount, const VkCommandBuffer *pCommandBuffers){
          const VkDeviceDispatch* dispatch = tables::LookupDeviceDispatch(device);
          for (uint32_t i = 0; i < commandBufferCount; i++)
            tables::UnassignDispatchTable(pCommandBuffers[i]);
          dispatch->_RealFreeCommandBuffers(device, commandPool, commandBufferCount, pCommandBuffers);
      };
}

namespace vkroots::tables {

  static inline void CreateDispatchTable(PFN_vkGetInstanceProcAddr nextInstanceProcAddr, PFN_GetPhysicalDeviceProcAddr nextPhysDevProcAddr, VkInstance instance) {
    auto instanceDispatch = InstanceDispatches.insert(instance, std::make_unique<VkInstanceDispatch>(nextInstanceProcAddr, instance));
    auto physicalDeviceDispatch = PhysicalDeviceInstanceDispatches.insert(instance, std::make_unique<VkPhysicalDeviceDispatch>(nextPhysDevProcAddr, instance, instanceDispatch));

    uint32_t physicalDeviceCount;
    VkResult res = instanceDispatch->EnumeratePhysicalDevices(instance, &physicalDeviceCount, nullptr);
    assert(res == VK_SUCCESS); // Not like we can do anything else with the result lol.
    if (res != VK_SUCCESS) return;
    std::vector<VkPhysicalDevice> physicalDevices(physicalDeviceCount);
    res = instanceDispatch->EnumeratePhysicalDevices(instance, &physicalDeviceCount, physicalDevices.data());
    assert(res == VK_SUCCESS); // Not like we can do anything else with the result lol.
    if (res != VK_SUCCESS) return;

    for (VkPhysicalDevice physicalDevice : physicalDevices)
      PhysicalDeviceDispatches.insert(physicalDevice, RawPointer(physicalDeviceDispatch));
  }

  static inline void CreateDispatchTable(const VkDeviceCreateInfo* pCreateInfo, PFN_vkGetDeviceProcAddr nextProcAddr, VkPhysicalDevice physicalDevice, VkDevice device) {
    auto physicalDeviceDispatch = vkroots::tables::LookupPhysicalDeviceDispatch(physicalDevice);
    auto deviceDispatch = DeviceDispatches.insert(device, std::make_unique<VkDeviceDispatch>(nextProcAddr, device, physicalDevice, physicalDeviceDispatch, pCreateInfo));

    for (uint32_t i = 0; i < pCreateInfo->queueCreateInfoCount; i++) {
      const auto &queueInfo = pCreateInfo->pQueueCreateInfos[i];
      for (uint32_t j = 0; j < queueInfo.queueCount; j++) {
        VkQueue queue;
        deviceDispatch->GetDeviceQueue(device, queueInfo.queueFamilyIndex, j, &queue);

        QueueDispatches.insert(queue, RawPointer(deviceDispatch));
      }
    }
  }

  static inline void DestroyDispatchTable(VkInstance instance) {
    const VkInstanceDispatch* instanceDispatch = InstanceDispatches.find(instance);
    assert(instanceDispatch);
    if (!instanceDispatch)
      return;

    uint32_t physicalDeviceCount;
    VkResult res = instanceDispatch->EnumeratePhysicalDevices(instance, &physicalDeviceCount, nullptr);
    assert(res == VK_SUCCESS); // Not like we can do anything else with the result lol.
    if (res == VK_SUCCESS) {
      std::vector<VkPhysicalDevice> physicalDevices(physicalDeviceCount);
      res = instanceDispatch->EnumeratePhysicalDevices(instance, &physicalDeviceCount, physicalDevices.data());
      assert(res == VK_SUCCESS); // Not like we can do anything else with the result lol.
      if (res == VK_SUCCESS) {
        for (VkPhysicalDevice physicalDevice : physicalDevices)
          PhysicalDeviceDispatches.remove(physicalDevice);
      }
    }

    PhysicalDeviceInstanceDispatches.remove(instance);
    InstanceDispatches.remove(instance);
  }

  static inline void DestroyDispatchTable(VkDevice device) {
    const VkDeviceDispatch* deviceDispatch = DeviceDispatches.find(device);
    assert(deviceDispatch);
    if (!deviceDispatch)
      return;

    for (const auto& queueInfo : deviceDispatch->DeviceQueueInfos) {
      for (uint32_t i = 0; i < queueInfo.queueCount; i++) {
        VkQueue queue;
        deviceDispatch->GetDeviceQueue(device, queueInfo.queueFamilyIndex, i, &queue);
        QueueDispatches.remove(queue);
      }
    }

    DeviceDispatches.remove(device);
  }

}


namespace vkroots::helpers {

  template <typename Func>
  inline void delimitStringView(std::string_view view, std::string_view delim, Func func) {
    size_t pos = 0;
    while ((pos = view.find(delim)) != std::string_view::npos) {
      std::string_view token = view.substr(0, pos);
      if (!func(token))
        return;
      view = view.substr(pos + 1);
    }
    func(view);
  }

  template <typename T, typename ArrType, typename Op>
  inline VkResult array(ArrType& arr, uint32_t *pCount, T* pOut, Op func) {
    const uint32_t count = uint32_t(arr.size());

    if (!pOut) {
      *pCount = count;
      return VK_SUCCESS;
    }

    const uint32_t outCount = std::min(*pCount, count);
    for (uint32_t i = 0; i < outCount; i++)
      func(pOut[i], arr[i]);

    *pCount = outCount;
    return count != outCount
      ? VK_INCOMPLETE
      : VK_SUCCESS;
  }

  template <typename T, typename ArrType>
  inline VkResult array(ArrType& arr, uint32_t *pCount, T* pOut) {
    return array(arr, pCount, pOut, [](T& x, const T& y) { x = y; });
  }

  template <typename Func, typename OutArray, typename... Args>
  uint32_t enumerate(Func function, OutArray& outArray, Args&&... arguments) {
    uint32_t count = 0;
    function(arguments..., &count, nullptr);

    outArray.resize(count);
    if (!count)
        return 0;

    function(std::forward<Args>(arguments)..., &count, outArray.data());
    return count;
  }

  template <typename Func, typename InArray, typename OutType, typename... Args>
  VkResult append(Func function, const InArray& inArray, uint32_t* pOutCount, OutType* pOut, Args&&... arguments) {
    uint32_t baseCount = 0;
    function(std::forward<Args>(arguments)..., &baseCount, nullptr);

    const uint32_t totalCount = baseCount + uint32_t(inArray.size());
    if (!pOut) {
      *pOutCount = totalCount;
      return VK_SUCCESS;
    }

    if (*pOutCount < totalCount) {
      function(std::forward<Args>(arguments)..., pOutCount, pOut);
      return VK_INCOMPLETE;
    }

    function(std::forward<Args>(arguments)..., &baseCount, pOut);
    for (size_t i = 0; i < inArray.size(); i++)
      pOut[baseCount + i] = inArray[i];
    return VK_SUCCESS;
  }

  template <typename SearchType, VkStructureType StructureTypeEnum, typename ChainBaseType>
  SearchType *chain(ChainBaseType* pNext) {
    for (VkBaseOutStructure* pBaseOut = reinterpret_cast<VkBaseOutStructure*>(pNext); pBaseOut; pBaseOut = pBaseOut->pNext) {
      if (pBaseOut->sType == StructureTypeEnum)
        return reinterpret_cast<SearchType*>(pBaseOut);
    }
    return nullptr;
  }

  template <typename Key, typename Data>
  class SynchronizedMapObject {
  public:
    using MapKey = Key;
    using MapData = SynchronizedMapObject<Key, Data>;

    SynchronizedMapObject(std::shared_ptr<Data> data)
      : m_data{std::move(data)} {
    }
    SynchronizedMapObject(const SynchronizedMapObject<Key, Data>& other)
      : m_data{other.m_data} {
    }
    SynchronizedMapObject(SynchronizedMapObject<Key, Data>&& other)
      : m_data{std::move(other.m_data)} {
    }
    SynchronizedMapObject(std::nullptr_t) {
    }

    SynchronizedMapObject& operator = (std::nullptr_t) {
      m_data = nullptr;
      return *this;
    }

    SynchronizedMapObject& operator = (const SynchronizedMapObject& other) {
      m_data = other.m_data;
    }

    SynchronizedMapObject& operator = (SynchronizedMapObject&& other) {
      m_data = std::move(other.m_data);
    }

    static SynchronizedMapObject<Key, Data> get(const Key& key) {
      std::unique_lock lock{ s_mutex };
      auto iter = s_map.find(key);
      if (iter == s_map.end())
        return nullptr;
      return iter->second;
    }

    static SynchronizedMapObject<Key, Data> create(const Key& key, Data data) {
      std::unique_lock lock{ s_mutex };
      auto val = s_map.emplace(
        std::piecewise_construct,
        std::forward_as_tuple(key),
        std::forward_as_tuple(std::make_shared<Data>(std::move(data))));
      return val.first->second;
    }

    static bool remove(const Key& key) {
      std::unique_lock lock{ s_mutex };
      auto iter = s_map.find(key);
      if (iter == s_map.end())
        return false;
      s_map.erase(iter);
      return true;
    }

    Data* get() {
      return m_data.get();
    }

    const Data* get() const {
      return m_data.get();
    }

    Data* operator->() {
      return get();
    }

    const Data* operator->() const {
      return get();
    }

    bool has() const {
      return m_data != nullptr;
    }

    operator bool() const {
      return has();
    }

  private:

    std::shared_ptr<Data> m_data;

    static std::mutex s_mutex;
    static std::unordered_map<MapKey, MapData> s_map;
  };

#define VKROOTS_DEFINE_SYNCHRONIZED_MAP_TYPE(name, key) \
  using name = ::vkroots::helpers::SynchronizedMapObject<key, name##Data>;

#define VKROOTS_IMPLEMENT_SYNCHRONIZED_MAP_TYPE(x) \
  template <> std::mutex x::s_mutex = {}; \
  template <> std::unordered_map<x::MapKey, x::MapData> x::s_map = {};

}

namespace vkroots {
  template <typename Type, typename UserData = uint64_t>
  class ChainPatcher {
  public:
    template <typename AnyStruct>
    ChainPatcher(const AnyStruct *obj, std::function<bool(UserData&, Type *)> func) {
      const Type *type = vkroots::FindInChain<Type>(obj);
      if (type) {
        func(m_ctx, const_cast<Type *>(type));
      } else {
        if (func(m_ctx, &m_value)) {
          AnyStruct *mutObj = const_cast<AnyStruct*>(obj);
          m_value.sType = ResolveSType<Type>();
          m_value.pNext = const_cast<void*>(std::exchange(mutObj->pNext, reinterpret_cast<const void*>(&m_value)));
        }
      }
    }

    template <typename AnyStruct>
    ChainPatcher(const AnyStruct *obj, std::function<bool(Type *)> func)
      : ChainPatcher(obj, [&](UserData& ctx, Type *obj) { return func(obj); }) {
    }

  private:
    Type m_value{};
    UserData m_ctx;
  };
}
namespace vkroots {

  template <typename InstanceOverrides, typename PhysicalDeviceOverrides, typename DeviceOverrides>
  VkResult NegotiateLoaderLayerInterfaceVersion(VkNegotiateLayerInterface* pVersionStruct) {
    if (pVersionStruct->loaderLayerInterfaceVersion < 2)
      return VK_ERROR_INITIALIZATION_FAILED;
    pVersionStruct->loaderLayerInterfaceVersion = 2;

    // Can't optimize away not having instance overrides from the layer, need to track device creation and instance dispatch and stuff.
    pVersionStruct->pfnGetInstanceProcAddr       = std::is_base_of<NoOverrides, InstanceOverrides>::value && std::is_base_of<NoOverrides, PhysicalDeviceOverrides>::value && std::is_base_of<NoOverrides, DeviceOverrides>::value
                                                     ? nullptr
                                                     : &GetInstanceProcAddr<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    pVersionStruct->pfnGetPhysicalDeviceProcAddr = std::is_base_of<NoOverrides, PhysicalDeviceOverrides>::value && std::is_base_of<NoOverrides, DeviceOverrides>::value
                                                     ? nullptr
                                                     : &GetPhysicalDeviceProcAddr<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;
    pVersionStruct->pfnGetDeviceProcAddr         = std::is_base_of<NoOverrides, DeviceOverrides>::value
                                                     ? nullptr
                                                     : &GetDeviceProcAddr<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>;

    return VK_SUCCESS;
  }

}

// Sadly, can't include this in VKROOTS_DEFINE_LAYER_INTERFACES
// as we need the stupid pragma comment for stdcall aliasing on Win32.
// So you can only have one layer interface per compilation unit.
#ifndef VKROOTS_NEGOTIATION_INTERFACE
#define VKROOTS_NEGOTIATION_INTERFACE vkNegotiateLoaderLayerInterfaceVersion
#endif

#ifdef _WIN32

// Define VK_LAYER_EXPORT to dllexport.
# undef VK_LAYER_EXPORT
# define VK_LAYER_EXPORT extern "C" __declspec(dllexport)

// Fix stdcall aliasing on 32-bit Windows.
# ifndef _WIN64
#  pragma comment(linker, "/EXPORT:" #VKROOTS_NEGOTIATION_INTERFACE "=_" #VKROOTS_NEGOTIATION_INTERFACE "@8")
# endif

#elif defined(__GNUC__)

# undef VK_LAYER_EXPORT
# define VK_LAYER_EXPORT extern "C" __attribute__((visibility("default")))

#endif

#define VKROOTS_DEFINE_LAYER_INTERFACES(InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides)                                   \
  VK_LAYER_EXPORT VKAPI_ATTR VkResult VKAPI_CALL VKROOTS_NEGOTIATION_INTERFACE(VkNegotiateLayerInterface* pVersionStruct) {            \
    return vkroots::NegotiateLoaderLayerInterfaceVersion<InstanceOverrides, PhysicalDeviceOverrides, DeviceOverrides>(pVersionStruct); \
  }
